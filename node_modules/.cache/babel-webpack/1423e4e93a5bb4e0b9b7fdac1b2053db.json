{"ast":null,"code":"/**\n * AgoraWebSDK_N-v4.5.0-0-g87245ad6 Copyright AgoraInc.\n */\n\n/*\n Determine if an object is a Buffer\n\n @author   Feross Aboukhadijeh <https://feross.org>\n @license  MIT\n *****************************************************************************\n Copyright (c) Microsoft Corporation. All rights reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n this file except in compliance with the License. You may obtain a copy of the\n License at http://www.apache.org/licenses/LICENSE-2.0\n\n THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n MERCHANTABLITY OR NON-INFRINGEMENT.\n\n See the Apache Version 2.0 License for specific language governing permissions\n and limitations under the License.\n*****************************************************************************/\n'use strict';\n\nvar _asyncToGenerator = require(\"/Users/homero/fereg-call/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\n!function (ub, Db) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = Db() : \"function\" == typeof define && define.amd ? define(Db) : (ub = \"undefined\" != typeof globalThis ? globalThis : ub || self).AgoraRTC = Db();\n}(this, function () {\n  function ub(d, f, a) {\n    return d(a = {\n      path: f,\n      exports: {},\n      require: function (a, c) {\n        throw Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n      }\n    }, a.exports), a.exports;\n  }\n\n  function Db(d, f, a) {\n    return (d = d.match(f)) && d.length >= a && pa(d[a], 10);\n  }\n\n  function jc(d, f, a) {\n    if (d.RTCPeerConnection) {\n      d = d.RTCPeerConnection.prototype;\n      var b = d.addEventListener;\n\n      d.addEventListener = function (c, d) {\n        if (c !== f) return b.apply(this, arguments);\n\n        let e = b => {\n          (b = a(b)) && d(b);\n        };\n\n        return this._eventMap = this._eventMap || {}, this._eventMap[d] = e, b.apply(this, [c, e]);\n      };\n\n      var c = d.removeEventListener;\n\n      d.removeEventListener = function (a, b) {\n        if (a !== f || !this._eventMap || !this._eventMap[b]) return c.apply(this, arguments);\n        let d = this._eventMap[b];\n        return delete this._eventMap[b], c.apply(this, [a, d]);\n      };\n\n      Y(d, \"on\" + f, {\n        get() {\n          return this[\"_on\" + f];\n        },\n\n        set(a) {\n          this[\"_on\" + f] && (this.removeEventListener(f, this[\"_on\" + f]), delete this[\"_on\" + f]);\n          a && this.addEventListener(f, this[\"_on\" + f] = a);\n        },\n\n        enumerable: !0,\n        configurable: !0\n      });\n    }\n  }\n\n  function dl(d) {\n    return \"boolean\" != typeof d ? Error(\"Argument type: \" + typeof d + \". Please use a boolean.\") : (kg = d, d ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n  }\n\n  function el(d) {\n    return \"boolean\" != typeof d ? Error(\"Argument type: \" + typeof d + \". Please use a boolean.\") : (lg = !d, \"adapter.js deprecation warnings \" + (d ? \"disabled\" : \"enabled\"));\n  }\n\n  function kb() {\n    \"object\" != typeof window || kg || \"undefined\" != typeof console && \"function\" == typeof console.log && console.log.apply(console, arguments);\n  }\n\n  function pd(d, f) {\n    lg && console.warn(d + \" is deprecated, please use \" + f + \" instead.\");\n  }\n\n  function Eb(d) {\n    let {\n      navigator: f\n    } = d,\n        a = {\n      browser: null,\n      version: null\n    };\n    if (void 0 === d || !d.navigator) return a.browser = \"Not a browser.\", a;\n    if (f.mozGetUserMedia) a.browser = \"firefox\", a.version = Db(f.userAgent, /Firefox\\/(\\d+)\\./, 1);else if (f.webkitGetUserMedia || !1 === d.isSecureContext && d.webkitRTCPeerConnection && !d.RTCIceGatherer) a.browser = \"chrome\", a.version = Db(f.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);else if (f.mediaDevices && f.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) a.browser = \"edge\", a.version = Db(f.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);else {\n      if (!d.RTCPeerConnection || !f.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) return a.browser = \"Not a supported browser.\", a;\n      a.browser = \"safari\";\n      a.version = Db(f.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n      a.supportsUnifiedPlan = d.RTCRtpTransceiver && \"currentDirection\" in d.RTCRtpTransceiver.prototype;\n    }\n    return a;\n  }\n\n  function mg(d) {\n    var f;\n    return \"[object Object]\" === Object.prototype.toString.call(d) ? qd(f = V(d)).call(f, function (a, b) {\n      var c = \"[object Object]\" === Object.prototype.toString.call(d[b]);\n      let e = c ? mg(d[b]) : d[b];\n      c = c && !V(e).length;\n      return void 0 === e || c ? a : Ga(a, {\n        [b]: e\n      });\n    }, {}) : d;\n  }\n\n  function ng(d, f, a) {\n    let b = a ? \"outbound-rtp\" : \"inbound-rtp\",\n        c = new aa();\n    if (null === f) return c;\n    let e = [];\n    return q(d).call(d, a => {\n      \"track\" === a.type && a.trackIdentifier === f.id && e.push(a);\n    }), q(e).call(e, a => {\n      q(d).call(d, e => {\n        e.type === b && e.trackId === a.id && function ua(a, b, c) {\n          var d;\n          b && !c.has(b.id) && (c.set(b.id, b), q(d = V(b)).call(d, d => {\n            if (og(d).call(d, \"Id\")) ua(a, a.get(b[d]), c);else if (og(d).call(d, \"Ids\")) {\n              var e;\n              q(e = b[d]).call(e, b => {\n                ua(a, a.get(b), c);\n              });\n            }\n          }));\n        }(d, e, c);\n      });\n    }), c;\n  }\n\n  function pg(d) {\n    let f = d && d.navigator;\n\n    if (f.mediaDevices) {\n      var a = Eb(d),\n          b = function (a) {\n        var b;\n        if (\"object\" != typeof a || a.mandatory || a.optional) return a;\n        const c = {};\n        var d;\n        (q(b = V(a)).call(b, b => {\n          if (\"require\" !== b && \"advanced\" !== b && \"mediaSource\" !== b) {\n            var d = \"object\" == typeof a[b] ? a[b] : {\n              ideal: a[b]\n            };\n            void 0 !== d.exact && \"number\" == typeof d.exact && (d.min = d.max = d.exact);\n\n            var e = function (a, b) {\n              return a ? a + b.charAt(0).toUpperCase() + Ha(b).call(b, 1) : \"deviceId\" === b ? \"sourceId\" : b;\n            };\n\n            if (void 0 !== d.ideal) {\n              c.optional = c.optional || [];\n              let a = {};\n              \"number\" == typeof d.ideal ? (a[e(\"min\", b)] = d.ideal, c.optional.push(a), a = {}, a[e(\"max\", b)] = d.ideal, c.optional.push(a)) : (a[e(\"\", b)] = d.ideal, c.optional.push(a));\n            }\n\n            var g;\n            void 0 !== d.exact && \"number\" != typeof d.exact ? (c.mandatory = c.mandatory || {}, c.mandatory[e(\"\", b)] = d.exact) : q(g = [\"min\", \"max\"]).call(g, a => {\n              void 0 !== d[a] && (c.mandatory = c.mandatory || {}, c.mandatory[e(a, b)] = d[a]);\n            });\n          }\n        }), a.advanced) && (c.optional = m(d = c.optional || []).call(d, a.advanced));\n        return c;\n      },\n          c = function (c, d) {\n        if (61 <= a.version) return d(c);\n\n        if ((c = JSON.parse(w(c))) && \"object\" == typeof c.audio) {\n          var e = function (a, b, c) {\n            b in a && !(c in a) && (a[c] = a[b], delete a[b]);\n          };\n\n          e((c = JSON.parse(w(c))).audio, \"autoGainControl\", \"googAutoGainControl\");\n          e(c.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n          c.audio = b(c.audio);\n        }\n\n        if (c && \"object\" == typeof c.video) {\n          let g = c.video.facingMode;\n          g = g && (\"object\" == typeof g ? g : {\n            ideal: g\n          });\n          e = 66 > a.version;\n\n          if (!(!g || \"user\" !== g.exact && \"environment\" !== g.exact && \"user\" !== g.ideal && \"environment\" !== g.ideal || f.mediaDevices.getSupportedConstraints && f.mediaDevices.getSupportedConstraints().facingMode && !e)) {\n            let a;\n            if (delete c.video.facingMode, \"environment\" === g.exact || \"environment\" === g.ideal ? a = [\"back\", \"rear\"] : \"user\" !== g.exact && \"user\" !== g.ideal || (a = [\"front\"]), a) return f.mediaDevices.enumerateDevices().then(e => {\n              e = I(e).call(e, a => \"videoinput\" === a.kind);\n              let h = R(e).call(e, b => qg(a).call(a, a => {\n                var c;\n                return ba(c = b.label.toLowerCase()).call(c, a);\n              }));\n              return !h && e.length && ba(a).call(a, \"back\") && (h = e[e.length - 1]), h && (c.video.deviceId = g.exact ? {\n                exact: h.deviceId\n              } : {\n                ideal: h.deviceId\n              }), c.video = b(c.video), rg(\"chrome: \" + w(c)), d(c);\n            });\n          }\n\n          c.video = b(c.video);\n        }\n\n        return rg(\"chrome: \" + w(c)), d(c);\n      },\n          e = function (b) {\n        return 64 <= a.version ? b : {\n          name: {\n            PermissionDeniedError: \"NotAllowedError\",\n            PermissionDismissedError: \"NotAllowedError\",\n            InvalidStateError: \"NotAllowedError\",\n            DevicesNotFoundError: \"NotFoundError\",\n            ConstraintNotSatisfiedError: \"OverconstrainedError\",\n            TrackStartError: \"NotReadableError\",\n            MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n            MediaDeviceKillSwitchOn: \"NotAllowedError\",\n            TabCaptureError: \"AbortError\",\n            ScreenCaptureError: \"AbortError\",\n            DeviceCaptureError: \"AbortError\"\n          }[b.name] || b.name,\n          message: b.message,\n          constraint: b.constraint || b.constraintName,\n\n          toString() {\n            return this.name + (this.message && \": \") + this.message;\n          }\n\n        };\n      };\n\n      d = function (a, b, d) {\n        c(a, a => {\n          f.webkitGetUserMedia(a, b, a => {\n            d && d(e(a));\n          });\n        });\n      };\n\n      if (f.getUserMedia = ra(d).call(d, f), f.mediaDevices.getUserMedia) {\n        var g;\n        let a = ra(g = f.mediaDevices.getUserMedia).call(g, f.mediaDevices);\n\n        f.mediaDevices.getUserMedia = function (b) {\n          return c(b, b => a(b).then(a => {\n            var c;\n            if (b.audio && !a.getAudioTracks().length || b.video && !a.getVideoTracks().length) throw q(c = a.getTracks()).call(c, a => {\n              a.stop();\n            }), new DOMException(\"\", \"NotFoundError\");\n            return a;\n          }, a => A.reject(e(a))));\n        };\n      }\n    }\n  }\n\n  function sg(d) {\n    d.MediaStream = d.MediaStream || d.webkitMediaStream;\n  }\n\n  function tg(d) {\n    if (\"object\" != typeof d || !d.RTCPeerConnection || \"ontrack\" in d.RTCPeerConnection.prototype) jc(d, \"track\", d => (d.transceiver || Y(d, \"transceiver\", {\n      value: {\n        receiver: d.receiver\n      }\n    }), d));else {\n      Y(d.RTCPeerConnection.prototype, \"ontrack\", {\n        get() {\n          return this._ontrack;\n        },\n\n        set(a) {\n          this._ontrack && this.removeEventListener(\"track\", this._ontrack);\n          this.addEventListener(\"track\", this._ontrack = a);\n        },\n\n        enumerable: !0,\n        configurable: !0\n      });\n      let f = d.RTCPeerConnection.prototype.setRemoteDescription;\n\n      d.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        return this._ontrackpoly || (this._ontrackpoly = a => {\n          var b;\n          a.stream.addEventListener(\"addtrack\", b => {\n            let c;\n            var g;\n            d.RTCPeerConnection.prototype.getReceivers ? c = R(g = this.getReceivers()).call(g, a => a.track && a.track.id === b.track.id) : c = {\n              track: b.track\n            };\n            g = new Event(\"track\");\n            g.track = b.track;\n            g.receiver = c;\n            g.transceiver = {\n              receiver: c\n            };\n            g.streams = [a.stream];\n            this.dispatchEvent(g);\n          });\n          q(b = a.stream.getTracks()).call(b, b => {\n            let c;\n            var g;\n            d.RTCPeerConnection.prototype.getReceivers ? c = R(g = this.getReceivers()).call(g, a => a.track && a.track.id === b.id) : c = {\n              track: b\n            };\n            g = new Event(\"track\");\n            g.track = b;\n            g.receiver = c;\n            g.transceiver = {\n              receiver: c\n            };\n            g.streams = [a.stream];\n            this.dispatchEvent(g);\n          });\n        }, this.addEventListener(\"addstream\", this._ontrackpoly)), f.apply(this, arguments);\n      };\n    }\n  }\n\n  function ug(d) {\n    if (\"object\" == typeof d && d.RTCPeerConnection && !(\"getSenders\" in d.RTCPeerConnection.prototype) && \"createDTMFSender\" in d.RTCPeerConnection.prototype) {\n      let f = function (a, b) {\n        return {\n          track: b,\n\n          get dtmf() {\n            return void 0 === this._dtmf && (\"audio\" === b.kind ? this._dtmf = a.createDTMFSender(b) : this._dtmf = null), this._dtmf;\n          },\n\n          _pc: a\n        };\n      };\n\n      if (!d.RTCPeerConnection.prototype.getSenders) {\n        d.RTCPeerConnection.prototype.getSenders = function () {\n          var a;\n          return this._senders = this._senders || [], Ha(a = this._senders).call(a);\n        };\n\n        let a = d.RTCPeerConnection.prototype.addTrack;\n\n        d.RTCPeerConnection.prototype.addTrack = function (b, c) {\n          let d = a.apply(this, arguments);\n          return d || (d = f(this, b), this._senders.push(d)), d;\n        };\n\n        let b = d.RTCPeerConnection.prototype.removeTrack;\n\n        d.RTCPeerConnection.prototype.removeTrack = function (a) {\n          var c;\n          b.apply(this, arguments);\n          let d = J(c = this._senders).call(c, a);\n          var e;\n          -1 !== d && Ia(e = this._senders).call(e, d, 1);\n        };\n      }\n\n      let a = d.RTCPeerConnection.prototype.addStream;\n\n      d.RTCPeerConnection.prototype.addStream = function (b) {\n        var c;\n        this._senders = this._senders || [];\n        a.apply(this, [b]);\n        q(c = b.getTracks()).call(c, a => {\n          this._senders.push(f(this, a));\n        });\n      };\n\n      let b = d.RTCPeerConnection.prototype.removeStream;\n\n      d.RTCPeerConnection.prototype.removeStream = function (a) {\n        var c;\n        this._senders = this._senders || [];\n        b.apply(this, [a]);\n        q(c = a.getTracks()).call(c, a => {\n          var b;\n          let c = R(b = this._senders).call(b, b => b.track === a);\n          var d, e;\n          c && Ia(d = this._senders).call(d, J(e = this._senders).call(e, c), 1);\n        });\n      };\n    } else if (\"object\" == typeof d && d.RTCPeerConnection && \"getSenders\" in d.RTCPeerConnection.prototype && \"createDTMFSender\" in d.RTCPeerConnection.prototype && d.RTCRtpSender && !(\"dtmf\" in d.RTCRtpSender.prototype)) {\n      let f = d.RTCPeerConnection.prototype.getSenders;\n\n      d.RTCPeerConnection.prototype.getSenders = function () {\n        let a = f.apply(this, []);\n        return q(a).call(a, a => a._pc = this), a;\n      };\n\n      Y(d.RTCRtpSender.prototype, \"dtmf\", {\n        get() {\n          return void 0 === this._dtmf && (\"audio\" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;\n        }\n\n      });\n    }\n  }\n\n  function vg(d) {\n    if (d.RTCPeerConnection) {\n      var f = d.RTCPeerConnection.prototype.getStats;\n\n      d.RTCPeerConnection.prototype.getStats = function () {\n        let [a, b, c] = arguments;\n        if (0 < arguments.length && \"function\" == typeof a) return f.apply(this, arguments);\n        if (0 === f.length && (0 === arguments.length || \"function\" != typeof a)) return f.apply(this, []);\n\n        let d = function (a) {\n          const b = {};\n          a = a.result();\n          return q(a).call(a, a => {\n            var c;\n            const d = {\n              id: a.id,\n              timestamp: a.timestamp,\n              type: {\n                localcandidate: \"local-candidate\",\n                remotecandidate: \"remote-candidate\"\n              }[a.type] || a.type\n            };\n            q(c = a.names()).call(c, b => {\n              d[b] = a.stat(b);\n            });\n            b[d.id] = d;\n          }), b;\n        },\n            g = function (a) {\n          var b;\n          return new aa(E(b = V(a)).call(b, b => [b, a[b]]));\n        };\n\n        return 2 <= arguments.length ? f.apply(this, [function (a) {\n          b(g(d(a)));\n        }, a]) : new A((a, b) => {\n          f.apply(this, [function (b) {\n            a(g(d(b)));\n          }, b]);\n        }).then(b, c);\n      };\n    }\n  }\n\n  function wg(d) {\n    if (\"object\" == typeof d && d.RTCPeerConnection && d.RTCRtpSender && d.RTCRtpReceiver) {\n      if (!(\"getStats\" in d.RTCRtpSender.prototype)) {\n        let a = d.RTCPeerConnection.prototype.getSenders;\n        a && (d.RTCPeerConnection.prototype.getSenders = function () {\n          let b = a.apply(this, []);\n          return q(b).call(b, a => a._pc = this), b;\n        });\n        let b = d.RTCPeerConnection.prototype.addTrack;\n        b && (d.RTCPeerConnection.prototype.addTrack = function () {\n          let a = b.apply(this, arguments);\n          return a._pc = this, a;\n        });\n\n        d.RTCRtpSender.prototype.getStats = function () {\n          let a = this;\n          return this._pc.getStats().then(b => ng(b, a.track, !0));\n        };\n      }\n\n      if (!(\"getStats\" in d.RTCRtpReceiver.prototype)) {\n        let a = d.RTCPeerConnection.prototype.getReceivers;\n        a && (d.RTCPeerConnection.prototype.getReceivers = function () {\n          let b = a.apply(this, []);\n          return q(b).call(b, a => a._pc = this), b;\n        });\n        jc(d, \"track\", a => (a.receiver._pc = a.srcElement, a));\n\n        d.RTCRtpReceiver.prototype.getStats = function () {\n          let a = this;\n          return this._pc.getStats().then(b => ng(b, a.track, !1));\n        };\n      }\n\n      if (\"getStats\" in d.RTCRtpSender.prototype && \"getStats\" in d.RTCRtpReceiver.prototype) {\n        var f = d.RTCPeerConnection.prototype.getStats;\n\n        d.RTCPeerConnection.prototype.getStats = function () {\n          if (0 < arguments.length && arguments[0] instanceof d.MediaStreamTrack) {\n            var a, b;\n            let c = arguments[0],\n                d,\n                g,\n                h;\n            return q(a = this.getSenders()).call(a, a => {\n              a.track === c && (d ? h = !0 : d = a);\n            }), q(b = this.getReceivers()).call(b, a => (a.track === c && (g ? h = !0 : g = a), a.track === c)), h || d && g ? A.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\")) : d ? d.getStats() : g ? g.getStats() : A.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n          }\n\n          return f.apply(this, arguments);\n        };\n      }\n    }\n  }\n\n  function xg(d) {\n    d.RTCPeerConnection.prototype.getLocalStreams = function () {\n      var a;\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, E(a = V(this._shimmedLocalStreams)).call(a, a => this._shimmedLocalStreams[a][0]);\n    };\n\n    let f = d.RTCPeerConnection.prototype.addTrack;\n\n    d.RTCPeerConnection.prototype.addTrack = function (a, b) {\n      var c;\n      if (!b) return f.apply(this, arguments);\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      let d = f.apply(this, arguments);\n      return this._shimmedLocalStreams[b.id] ? -1 === J(c = this._shimmedLocalStreams[b.id]).call(c, d) && this._shimmedLocalStreams[b.id].push(d) : this._shimmedLocalStreams[b.id] = [b, d], d;\n    };\n\n    let a = d.RTCPeerConnection.prototype.addStream;\n\n    d.RTCPeerConnection.prototype.addStream = function (b) {\n      var c, d, e;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      q(c = b.getTracks()).call(c, a => {\n        var b;\n        if (R(b = this.getSenders()).call(b, b => b.track === a)) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      });\n      let f = this.getSenders();\n      a.apply(this, arguments);\n      c = I(d = this.getSenders()).call(d, a => -1 === J(f).call(f, a));\n      this._shimmedLocalStreams[b.id] = m(e = [b]).call(e, c);\n    };\n\n    let b = d.RTCPeerConnection.prototype.removeStream;\n\n    d.RTCPeerConnection.prototype.removeStream = function (a) {\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[a.id], b.apply(this, arguments);\n    };\n\n    let c = d.RTCPeerConnection.prototype.removeTrack;\n\n    d.RTCPeerConnection.prototype.removeTrack = function (a) {\n      var b;\n      (this._shimmedLocalStreams = this._shimmedLocalStreams || {}, a) && q(b = V(this._shimmedLocalStreams)).call(b, b => {\n        var c;\n        let d = J(c = this._shimmedLocalStreams[b]).call(c, a);\n        var e;\n        -1 !== d && Ia(e = this._shimmedLocalStreams[b]).call(e, d, 1);\n        1 === this._shimmedLocalStreams[b].length && delete this._shimmedLocalStreams[b];\n      });\n      return c.apply(this, arguments);\n    };\n  }\n\n  function yg(d) {\n    function f(a, b) {\n      var c;\n      let d = b.sdp;\n      return q(c = V(a._reverseStreams || [])).call(c, b => {\n        b = a._reverseStreams[b];\n        d = d.replace(new RegExp(a._streams[b.id].id, \"g\"), b.id);\n      }), new RTCSessionDescription({\n        type: b.type,\n        sdp: d\n      });\n    }\n\n    function a(a, b) {\n      var c;\n      let d = b.sdp;\n      return q(c = V(a._reverseStreams || [])).call(c, b => {\n        b = a._reverseStreams[b];\n        d = d.replace(new RegExp(b.id, \"g\"), a._streams[b.id].id);\n      }), new RTCSessionDescription({\n        type: b.type,\n        sdp: d\n      });\n    }\n\n    var b;\n\n    if (d.RTCPeerConnection) {\n      var c = Eb(d);\n      if (d.RTCPeerConnection.prototype.addTrack && 65 <= c.version) return xg(d);\n      var e = d.RTCPeerConnection.prototype.getLocalStreams;\n\n      d.RTCPeerConnection.prototype.getLocalStreams = function () {\n        let a = e.apply(this);\n        return this._reverseStreams = this._reverseStreams || {}, E(a).call(a, a => this._reverseStreams[a.id]);\n      };\n\n      var g = d.RTCPeerConnection.prototype.addStream;\n\n      d.RTCPeerConnection.prototype.addStream = function (a) {\n        var b;\n        (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, q(b = a.getTracks()).call(b, a => {\n          var b;\n          if (R(b = this.getSenders()).call(b, b => b.track === a)) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        }), this._reverseStreams[a.id]) || (b = new d.MediaStream(a.getTracks()), this._streams[a.id] = b, this._reverseStreams[b.id] = a, a = b);\n        g.apply(this, [a]);\n      };\n\n      var h = d.RTCPeerConnection.prototype.removeStream;\n\n      d.RTCPeerConnection.prototype.removeStream = function (a) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        h.apply(this, [this._streams[a.id] || a]);\n        delete this._reverseStreams[this._streams[a.id] ? this._streams[a.id].id : a.id];\n        delete this._streams[a.id];\n      };\n\n      d.RTCPeerConnection.prototype.addTrack = function (a, b) {\n        var c, e, g;\n        if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        let h = Ha([]).call(arguments, 1);\n        if (1 !== h.length || !R(c = h[0].getTracks()).call(c, b => b === a)) throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n        if (R(e = this.getSenders()).call(e, b => b.track === a)) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        (c = this._streams[b.id]) ? (c.addTrack(a), A.resolve().then(() => {\n          this.dispatchEvent(new Event(\"negotiationneeded\"));\n        })) : (c = new d.MediaStream([a]), this._streams[b.id] = c, this._reverseStreams[c.id] = b, this.addStream(c));\n        return R(g = this.getSenders()).call(g, b => b.track === a);\n      };\n\n      q(b = [\"createOffer\", \"createAnswer\"]).call(b, function (a) {\n        let b = d.RTCPeerConnection.prototype[a];\n        d.RTCPeerConnection.prototype[a] = {\n          [a]() {\n            const a = arguments;\n            return arguments.length && \"function\" == typeof arguments[0] ? b.apply(this, [b => {\n              b = f(this, b);\n              a[0].apply(null, [b]);\n            }, b => {\n              a[1] && a[1].apply(null, b);\n            }, arguments[2]]) : b.apply(this, arguments).then(a => f(this, a));\n          }\n\n        }[a];\n      });\n      var p = d.RTCPeerConnection.prototype.setLocalDescription;\n\n      d.RTCPeerConnection.prototype.setLocalDescription = function () {\n        return arguments.length && arguments[0].type ? (arguments[0] = a(this, arguments[0]), p.apply(this, arguments)) : p.apply(this, arguments);\n      };\n\n      var r = Z(d.RTCPeerConnection.prototype, \"localDescription\");\n      Y(d.RTCPeerConnection.prototype, \"localDescription\", {\n        get() {\n          let a = r.get.apply(this);\n          return \"\" === a.type ? a : f(this, a);\n        }\n\n      });\n\n      d.RTCPeerConnection.prototype.removeTrack = function (a) {\n        var b;\n        if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        if (!a._pc) throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n        if (a._pc !== this) throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n        let c;\n        this._streams = this._streams || {};\n        q(b = V(this._streams)).call(b, b => {\n          var d;\n          R(d = this._streams[b].getTracks()).call(d, b => a.track === b) && (c = this._streams[b]);\n        });\n        c && (1 === c.getTracks().length ? this.removeStream(this._reverseStreams[c.id]) : c.removeTrack(a.track), this.dispatchEvent(new Event(\"negotiationneeded\")));\n      };\n    }\n  }\n\n  function se(d) {\n    let f = Eb(d);\n\n    if (!d.RTCPeerConnection && d.webkitRTCPeerConnection && (d.RTCPeerConnection = d.webkitRTCPeerConnection), d.RTCPeerConnection) {\n      var a;\n      53 > f.version && q(a = [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"]).call(a, function (a) {\n        let b = d.RTCPeerConnection.prototype[a];\n        d.RTCPeerConnection.prototype[a] = {\n          [a]() {\n            return arguments[0] = new (\"addIceCandidate\" === a ? d.RTCIceCandidate : d.RTCSessionDescription)(arguments[0]), b.apply(this, arguments);\n          }\n\n        }[a];\n      });\n      var b = d.RTCPeerConnection.prototype.addIceCandidate;\n\n      d.RTCPeerConnection.prototype.addIceCandidate = function () {\n        return arguments[0] ? 78 > f.version && arguments[0] && \"\" === arguments[0].candidate ? A.resolve() : b.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), A.resolve());\n      };\n    }\n  }\n\n  function zg(d) {\n    jc(d, \"negotiationneeded\", d => {\n      if (\"stable\" === d.target.signalingState) return d;\n    });\n  }\n\n  function Ag(d, f, a, b, c) {\n    f = G.writeRtpDescription(d.kind, f);\n    if (f += G.writeIceParameters(d.iceGatherer.getLocalParameters()), f += G.writeDtlsParameters(d.dtlsTransport.getLocalParameters(), \"offer\" === a ? \"actpass\" : c || \"active\"), f += \"a=mid:\" + d.mid + \"\\r\\n\", d.rtpSender && d.rtpReceiver ? f += \"a=sendrecv\\r\\n\" : d.rtpSender ? f += \"a=sendonly\\r\\n\" : d.rtpReceiver ? f += \"a=recvonly\\r\\n\" : f += \"a=inactive\\r\\n\", d.rtpSender) a = d.rtpSender._initialTrackId || d.rtpSender.track.id, d.rtpSender._initialTrackId = a, b = \"msid:\" + (b ? b.id : \"-\") + \" \" + a + \"\\r\\n\", f = f + (\"a=\" + b) + (\"a=ssrc:\" + d.sendEncodingParameters[0].ssrc + \" \" + b), d.sendEncodingParameters[0].rtx && (f += \"a=ssrc:\" + d.sendEncodingParameters[0].rtx.ssrc + \" \" + b, f += \"a=ssrc-group:FID \" + d.sendEncodingParameters[0].ssrc + \" \" + d.sendEncodingParameters[0].rtx.ssrc + \"\\r\\n\");\n    return f += \"a=ssrc:\" + d.sendEncodingParameters[0].ssrc + \" cname:\" + G.localCName + \"\\r\\n\", d.rtpSender && d.sendEncodingParameters[0].rtx && (f += \"a=ssrc:\" + d.sendEncodingParameters[0].rtx.ssrc + \" cname:\" + G.localCName + \"\\r\\n\"), f;\n  }\n\n  function rd(d, f) {\n    var a = {\n      codecs: [],\n      headerExtensions: [],\n      fecMechanisms: []\n    },\n        b = function (a, b) {\n      a = parseInt(a, 10);\n\n      for (var c = 0; c < b.length; c++) if (b[c].payloadType === a || b[c].preferredPayloadType === a) return b[c];\n    },\n        c = function (a, c, d, f) {\n      a = b(a.parameters.apt, d);\n      c = b(c.parameters.apt, f);\n      return a && c && a.name.toLowerCase() === c.name.toLowerCase();\n    };\n\n    return d.codecs.forEach(function (b) {\n      for (var e = 0; e < f.codecs.length; e++) {\n        var h = f.codecs[e];\n\n        if (b.name.toLowerCase() === h.name.toLowerCase() && b.clockRate === h.clockRate && (\"rtx\" !== b.name.toLowerCase() || !b.parameters || !h.parameters.apt || c(b, h, d.codecs, f.codecs))) {\n          (h = JSON.parse(JSON.stringify(h))).numChannels = Math.min(b.numChannels, h.numChannels);\n          a.codecs.push(h);\n          h.rtcpFeedback = h.rtcpFeedback.filter(function (a) {\n            for (var c = 0; c < b.rtcpFeedback.length; c++) if (b.rtcpFeedback[c].type === a.type && b.rtcpFeedback[c].parameter === a.parameter) return !0;\n\n            return !1;\n          });\n          break;\n        }\n      }\n    }), d.headerExtensions.forEach(function (b) {\n      for (var c = 0; c < f.headerExtensions.length; c++) {\n        var d = f.headerExtensions[c];\n\n        if (b.uri === d.uri) {\n          a.headerExtensions.push(d);\n          break;\n        }\n      }\n    }), a;\n  }\n\n  function Bg(d, f, a) {\n    return -1 !== {\n      offer: {\n        setLocalDescription: [\"stable\", \"have-local-offer\"],\n        setRemoteDescription: [\"stable\", \"have-remote-offer\"]\n      },\n      answer: {\n        setLocalDescription: [\"have-remote-offer\", \"have-local-pranswer\"],\n        setRemoteDescription: [\"have-local-offer\", \"have-remote-pranswer\"]\n      }\n    }[f][d].indexOf(a);\n  }\n\n  function te(d, f) {\n    var a = d.getRemoteCandidates().find(function (a) {\n      return f.foundation === a.foundation && f.ip === a.ip && f.port === a.port && f.priority === a.priority && f.protocol === a.protocol && f.type === a.type;\n    });\n    return a || d.addRemoteCandidate(f), !a;\n  }\n\n  function Ja(d, f) {\n    f = Error(f);\n    return f.name = d, f.code = {\n      NotSupportedError: 9,\n      InvalidStateError: 11,\n      InvalidAccessError: 15,\n      TypeError: void 0,\n      OperationError: void 0\n    }[d], f;\n  }\n\n  function Cg(d) {\n    var f;\n    d = d && d.navigator;\n    let a = ra(f = d.mediaDevices.getUserMedia).call(f, d.mediaDevices);\n\n    d.mediaDevices.getUserMedia = function (b) {\n      return a(b).catch(a => A.reject(function (a) {\n        return {\n          name: {\n            PermissionDeniedError: \"NotAllowedError\"\n          }[a.name] || a.name,\n          message: a.message,\n          constraint: a.constraint,\n\n          toString() {\n            return this.name;\n          }\n\n        };\n      }(a)));\n    };\n  }\n\n  function Dg(d) {\n    var f;\n    \"getDisplayMedia\" in d.navigator && d.navigator.mediaDevices && (d.navigator.mediaDevices && \"getDisplayMedia\" in d.navigator.mediaDevices || (d.navigator.mediaDevices.getDisplayMedia = ra(f = d.navigator.getDisplayMedia).call(f, d.navigator)));\n  }\n\n  function ue(d) {\n    let f = Eb(d);\n\n    if (d.RTCIceGatherer && (d.RTCIceCandidate || (d.RTCIceCandidate = function (a) {\n      return a;\n    }), d.RTCSessionDescription || (d.RTCSessionDescription = function (a) {\n      return a;\n    }), 15025 > f.version)) {\n      let a = Z(d.MediaStreamTrack.prototype, \"enabled\");\n      Y(d.MediaStreamTrack.prototype, \"enabled\", {\n        set(b) {\n          a.set.call(this, b);\n          let c = new Event(\"enabled\");\n          c.enabled = b;\n          this.dispatchEvent(c);\n        }\n\n      });\n    }\n\n    !d.RTCRtpSender || \"dtmf\" in d.RTCRtpSender.prototype || Y(d.RTCRtpSender.prototype, \"dtmf\", {\n      get() {\n        return void 0 === this._dtmf && (\"audio\" === this.track.kind ? this._dtmf = new d.RTCDtmfSender(this) : \"video\" === this.track.kind && (this._dtmf = null)), this._dtmf;\n      }\n\n    });\n    d.RTCDtmfSender && !d.RTCDTMFSender && (d.RTCDTMFSender = d.RTCDtmfSender);\n    let a = fl(d, f.version);\n\n    d.RTCPeerConnection = function (b) {\n      return b && b.iceServers && (b.iceServers = function (a, b) {\n        let c = !1;\n        return a = JSON.parse(w(a)), I(a).call(a, a => {\n          if (a && (a.urls || a.url)) {\n            var b = a.urls || a.url;\n            a.url && !a.urls && pd(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n            let d = \"string\" == typeof b;\n            return d && (b = [b]), b = I(b).call(b, a => 0 === J(a).call(a, \"stun:\") ? !1 : (a = sd(a).call(a, \"turn\") && !sd(a).call(a, \"turn:[\") && ba(a).call(a, \"transport=udp\")) && !c ? (c = !0, !0) : a && !c), delete a.url, a.urls = d ? b[0] : b, !!b.length;\n          }\n        });\n      }(b.iceServers, f.version), kb(\"ICE servers after filtering:\", b.iceServers)), new a(b);\n    };\n\n    d.RTCPeerConnection.prototype = a.prototype;\n  }\n\n  function Eg(d) {\n    !d.RTCRtpSender || \"replaceTrack\" in d.RTCRtpSender.prototype || (d.RTCRtpSender.prototype.replaceTrack = d.RTCRtpSender.prototype.setTrack);\n  }\n\n  function Fg(d) {\n    let f = Eb(d),\n        a = d && d.navigator;\n    d = d && d.MediaStreamTrack;\n\n    if (a.getUserMedia = function (b, d, g) {\n      pd(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n      a.mediaDevices.getUserMedia(b).then(d, g);\n    }, !(55 < f.version && \"autoGainControl\" in a.mediaDevices.getSupportedConstraints())) {\n      var b;\n\n      let c = function (a, b, c) {\n        b in a && !(c in a) && (a[c] = a[b], delete a[b]);\n      },\n          e = ra(b = a.mediaDevices.getUserMedia).call(b, a.mediaDevices);\n\n      if (a.mediaDevices.getUserMedia = function (a) {\n        return \"object\" == typeof a && \"object\" == typeof a.audio && (a = JSON.parse(w(a)), c(a.audio, \"autoGainControl\", \"mozAutoGainControl\"), c(a.audio, \"noiseSuppression\", \"mozNoiseSuppression\")), e(a);\n      }, d && d.prototype.getSettings) {\n        let a = d.prototype.getSettings;\n\n        d.prototype.getSettings = function () {\n          let b = a.apply(this, arguments);\n          return c(b, \"mozAutoGainControl\", \"autoGainControl\"), c(b, \"mozNoiseSuppression\", \"noiseSuppression\"), b;\n        };\n      }\n\n      if (d && d.prototype.applyConstraints) {\n        let a = d.prototype.applyConstraints;\n\n        d.prototype.applyConstraints = function (b) {\n          return \"audio\" === this.kind && \"object\" == typeof b && (b = JSON.parse(w(b)), c(b, \"autoGainControl\", \"mozAutoGainControl\"), c(b, \"noiseSuppression\", \"mozNoiseSuppression\")), a.apply(this, [b]);\n        };\n      }\n    }\n  }\n\n  function Gg(d) {\n    \"object\" == typeof d && d.RTCTrackEvent && \"receiver\" in d.RTCTrackEvent.prototype && !(\"transceiver\" in d.RTCTrackEvent.prototype) && Y(d.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n\n    });\n  }\n\n  function ve(d) {\n    let f = Eb(d);\n\n    if (\"object\" == typeof d && (d.RTCPeerConnection || d.mozRTCPeerConnection)) {\n      var a;\n      (!d.RTCPeerConnection && d.mozRTCPeerConnection && (d.RTCPeerConnection = d.mozRTCPeerConnection), 53 > f.version) && q(a = [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"]).call(a, function (a) {\n        let b = d.RTCPeerConnection.prototype[a];\n        d.RTCPeerConnection.prototype[a] = {\n          [a]() {\n            return arguments[0] = new (\"addIceCandidate\" === a ? d.RTCIceCandidate : d.RTCSessionDescription)(arguments[0]), b.apply(this, arguments);\n          }\n\n        }[a];\n      });\n      var b = d.RTCPeerConnection.prototype.addIceCandidate;\n\n      d.RTCPeerConnection.prototype.addIceCandidate = function () {\n        return arguments[0] ? 68 > f.version && arguments[0] && \"\" === arguments[0].candidate ? A.resolve() : b.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), A.resolve());\n      };\n\n      var c = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n      },\n          e = d.RTCPeerConnection.prototype.getStats;\n\n      d.RTCPeerConnection.prototype.getStats = function () {\n        let [a, b, d] = arguments;\n        return e.apply(this, [a || null]).then(a => {\n          if (53 > f.version && !b) try {\n            q(a).call(a, a => {\n              a.type = c[a.type] || a.type;\n            });\n          } catch (t) {\n            if (\"TypeError\" !== t.name) throw t;\n            q(a).call(a, (b, d) => {\n              a.set(d, Ga({}, b, {\n                type: c[b.type] || b.type\n              }));\n            });\n          }\n          return a;\n        }).then(b, d);\n      };\n    }\n  }\n\n  function Hg(d) {\n    if (\"object\" == typeof d && d.RTCPeerConnection && d.RTCRtpSender && !(d.RTCRtpSender && \"getStats\" in d.RTCRtpSender.prototype)) {\n      var f = d.RTCPeerConnection.prototype.getSenders;\n      f && (d.RTCPeerConnection.prototype.getSenders = function () {\n        let a = f.apply(this, []);\n        return q(a).call(a, a => a._pc = this), a;\n      });\n      var a = d.RTCPeerConnection.prototype.addTrack;\n      a && (d.RTCPeerConnection.prototype.addTrack = function () {\n        let b = a.apply(this, arguments);\n        return b._pc = this, b;\n      });\n\n      d.RTCRtpSender.prototype.getStats = function () {\n        return this.track ? this._pc.getStats(this.track) : A.resolve(new aa());\n      };\n    }\n  }\n\n  function Ig(d) {\n    if (\"object\" == typeof d && d.RTCPeerConnection && d.RTCRtpSender && !(d.RTCRtpSender && \"getStats\" in d.RTCRtpReceiver.prototype)) {\n      var f = d.RTCPeerConnection.prototype.getReceivers;\n      f && (d.RTCPeerConnection.prototype.getReceivers = function () {\n        let a = f.apply(this, []);\n        return q(a).call(a, a => a._pc = this), a;\n      });\n      jc(d, \"track\", a => (a.receiver._pc = a.srcElement, a));\n\n      d.RTCRtpReceiver.prototype.getStats = function () {\n        return this._pc.getStats(this.track);\n      };\n    }\n  }\n\n  function Jg(d) {\n    !d.RTCPeerConnection || \"removeStream\" in d.RTCPeerConnection.prototype || (d.RTCPeerConnection.prototype.removeStream = function (d) {\n      var a;\n      pd(\"removeStream\", \"removeTrack\");\n      q(a = this.getSenders()).call(a, a => {\n        var b;\n        a.track && ba(b = d.getTracks()).call(b, a.track) && this.removeTrack(a);\n      });\n    });\n  }\n\n  function Kg(d) {\n    d.DataChannel && !d.RTCDataChannel && (d.RTCDataChannel = d.DataChannel);\n  }\n\n  function Lg(d) {\n    if (\"object\" == typeof d && d.RTCPeerConnection) {\n      if (\"getLocalStreams\" in d.RTCPeerConnection.prototype || (d.RTCPeerConnection.prototype.getLocalStreams = function () {\n        return this._localStreams || (this._localStreams = []), this._localStreams;\n      }), !(\"addStream\" in d.RTCPeerConnection.prototype)) {\n        let f = d.RTCPeerConnection.prototype.addTrack;\n\n        d.RTCPeerConnection.prototype.addStream = function (a) {\n          var b, c, d;\n          this._localStreams || (this._localStreams = []);\n          ba(b = this._localStreams).call(b, a) || this._localStreams.push(a);\n          q(c = a.getAudioTracks()).call(c, b => f.call(this, b, a));\n          q(d = a.getVideoTracks()).call(d, b => f.call(this, b, a));\n        };\n\n        d.RTCPeerConnection.prototype.addTrack = function (a, b) {\n          var c;\n          b && (this._localStreams ? ba(c = this._localStreams).call(c, b) || this._localStreams.push(b) : this._localStreams = [b]);\n          return f.call(this, a, b);\n        };\n      }\n\n      \"removeStream\" in d.RTCPeerConnection.prototype || (d.RTCPeerConnection.prototype.removeStream = function (d) {\n        var a, b, c;\n        this._localStreams || (this._localStreams = []);\n        let e = J(a = this._localStreams).call(a, d);\n\n        if (-1 !== e) {\n          Ia(b = this._localStreams).call(b, e, 1);\n          var g = d.getTracks();\n          q(c = this.getSenders()).call(c, a => {\n            ba(g).call(g, a.track) && this.removeTrack(a);\n          });\n        }\n      });\n    }\n  }\n\n  function Mg(d) {\n    if (\"object\" == typeof d && d.RTCPeerConnection && (\"getRemoteStreams\" in d.RTCPeerConnection.prototype || (d.RTCPeerConnection.prototype.getRemoteStreams = function () {\n      return this._remoteStreams ? this._remoteStreams : [];\n    }), !(\"onaddstream\" in d.RTCPeerConnection.prototype))) {\n      Y(d.RTCPeerConnection.prototype, \"onaddstream\", {\n        get() {\n          return this._onaddstream;\n        },\n\n        set(a) {\n          this._onaddstream && (this.removeEventListener(\"addstream\", this._onaddstream), this.removeEventListener(\"track\", this._onaddstreampoly));\n          this.addEventListener(\"addstream\", this._onaddstream = a);\n          this.addEventListener(\"track\", this._onaddstreampoly = a => {\n            var b;\n            q(b = a.streams).call(b, a => {\n              var b;\n              (this._remoteStreams || (this._remoteStreams = []), ba(b = this._remoteStreams).call(b, a)) || (this._remoteStreams.push(a), b = new Event(\"addstream\"), b.stream = a, this.dispatchEvent(b));\n            });\n          });\n        }\n\n      });\n      let f = d.RTCPeerConnection.prototype.setRemoteDescription;\n\n      d.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        let a = this;\n        return this._onaddstreampoly || this.addEventListener(\"track\", this._onaddstreampoly = function (b) {\n          var c;\n          q(c = b.streams).call(c, b => {\n            var c;\n            (a._remoteStreams || (a._remoteStreams = []), 0 <= J(c = a._remoteStreams).call(c, b)) || (a._remoteStreams.push(b), c = new Event(\"addstream\"), c.stream = b, a.dispatchEvent(c));\n          });\n        }), f.apply(a, arguments);\n      };\n    }\n  }\n\n  function Ng(d) {\n    if (\"object\" == typeof d && d.RTCPeerConnection) {\n      d = d.RTCPeerConnection.prototype;\n      var f = d.createOffer,\n          a = d.createAnswer,\n          b = d.setLocalDescription,\n          c = d.setRemoteDescription,\n          e = d.addIceCandidate;\n\n      d.createOffer = function (a, b) {\n        let c = f.apply(this, [2 <= arguments.length ? arguments[2] : arguments[0]]);\n        return b ? (c.then(a, b), A.resolve()) : c;\n      };\n\n      d.createAnswer = function (b, c) {\n        let d = a.apply(this, [2 <= arguments.length ? arguments[2] : arguments[0]]);\n        return c ? (d.then(b, c), A.resolve()) : d;\n      };\n\n      var g = function (a, c, d) {\n        a = b.apply(this, [a]);\n        return d ? (a.then(c, d), A.resolve()) : a;\n      };\n\n      d.setLocalDescription = g;\n\n      g = function (a, b, d) {\n        a = c.apply(this, [a]);\n        return d ? (a.then(b, d), A.resolve()) : a;\n      };\n\n      d.setRemoteDescription = g;\n\n      g = function (a, b, c) {\n        a = e.apply(this, [a]);\n        return c ? (a.then(b, c), A.resolve()) : a;\n      };\n\n      d.addIceCandidate = g;\n    }\n  }\n\n  function Og(d) {\n    let f = d && d.navigator;\n\n    if (f.mediaDevices && f.mediaDevices.getUserMedia) {\n      var a;\n      d = f.mediaDevices;\n      let b = ra(a = d.getUserMedia).call(a, d);\n\n      f.mediaDevices.getUserMedia = a => b(Pg(a));\n    }\n\n    var b;\n    !f.getUserMedia && f.mediaDevices && f.mediaDevices.getUserMedia && (f.getUserMedia = ra(b = function (a, b, d) {\n      f.mediaDevices.getUserMedia(a).then(b, d);\n    }).call(b, f));\n  }\n\n  function Pg(d) {\n    return d && void 0 !== d.video ? Ga({}, d, {\n      video: mg(d.video)\n    }) : d;\n  }\n\n  function Qg(d) {\n    let f = d.RTCPeerConnection;\n\n    d.RTCPeerConnection = function (a, b) {\n      if (a && a.iceServers) {\n        let b = [];\n\n        for (let c = 0; c < a.iceServers.length; c++) {\n          let d = a.iceServers[c];\n          !d.hasOwnProperty(\"urls\") && d.hasOwnProperty(\"url\") ? (pd(\"RTCIceServer.url\", \"RTCIceServer.urls\"), d = JSON.parse(w(d)), d.urls = d.url, delete d.url, b.push(d)) : b.push(a.iceServers[c]);\n        }\n\n        a.iceServers = b;\n      }\n\n      return new f(a, b);\n    };\n\n    d.RTCPeerConnection.prototype = f.prototype;\n    \"generateCertificate\" in d.RTCPeerConnection && Y(d.RTCPeerConnection, \"generateCertificate\", {\n      get: () => f.generateCertificate\n    });\n  }\n\n  function Rg(d) {\n    \"object\" == typeof d && d.RTCPeerConnection && \"receiver\" in d.RTCTrackEvent.prototype && !d.RTCTransceiver && Y(d.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n\n    });\n  }\n\n  function Sg(d) {\n    let f = d.RTCPeerConnection.prototype.createOffer;\n\n    d.RTCPeerConnection.prototype.createOffer = function (a) {\n      if (a) {\n        var b, c;\n        void 0 !== a.offerToReceiveAudio && (a.offerToReceiveAudio = !!a.offerToReceiveAudio);\n        let d = R(b = this.getTransceivers()).call(b, a => \"audio\" === a.receiver.track.kind);\n        !1 === a.offerToReceiveAudio && d ? \"sendrecv\" === d.direction ? d.setDirection ? d.setDirection(\"sendonly\") : d.direction = \"sendonly\" : \"recvonly\" === d.direction && (d.setDirection ? d.setDirection(\"inactive\") : d.direction = \"inactive\") : !0 !== a.offerToReceiveAudio || d || this.addTransceiver(\"audio\");\n        void 0 !== a.offerToReceiveVideo && (a.offerToReceiveVideo = !!a.offerToReceiveVideo);\n        b = R(c = this.getTransceivers()).call(c, a => \"video\" === a.receiver.track.kind);\n        !1 === a.offerToReceiveVideo && b ? \"sendrecv\" === b.direction ? b.setDirection ? b.setDirection(\"sendonly\") : b.direction = \"sendonly\" : \"recvonly\" === b.direction && (b.setDirection ? b.setDirection(\"inactive\") : b.direction = \"inactive\") : !0 !== a.offerToReceiveVideo || b || this.addTransceiver(\"video\");\n      }\n\n      return f.apply(this, arguments);\n    };\n  }\n\n  function td(d) {\n    if (d.RTCIceCandidate && !(d.RTCIceCandidate && \"foundation\" in d.RTCIceCandidate.prototype)) {\n      var f = d.RTCIceCandidate;\n\n      d.RTCIceCandidate = function (a) {\n        var b;\n\n        if (\"object\" == typeof a && a.candidate && 0 === J(b = a.candidate).call(b, \"a=\") && ((a = JSON.parse(w(a))).candidate = a.candidate.substr(2)), a.candidate && a.candidate.length) {\n          b = new f(a);\n          a = G.parseCandidate(a.candidate);\n          let c = Ga(b, a);\n          return c.toJSON = function () {\n            return {\n              candidate: c.candidate,\n              sdpMid: c.sdpMid,\n              sdpMLineIndex: c.sdpMLineIndex,\n              usernameFragment: c.usernameFragment\n            };\n          }, c;\n        }\n\n        return new f(a);\n      };\n\n      d.RTCIceCandidate.prototype = f.prototype;\n      jc(d, \"icecandidate\", a => (a.candidate && Y(a, \"candidate\", {\n        value: new d.RTCIceCandidate(a.candidate),\n        writable: \"false\"\n      }), a));\n    }\n  }\n\n  function Hc(d) {\n    if (d.RTCPeerConnection) {\n      var f = Eb(d);\n      \"sctp\" in d.RTCPeerConnection.prototype || Y(d.RTCPeerConnection.prototype, \"sctp\", {\n        get() {\n          return void 0 === this._sctp ? null : this._sctp;\n        }\n\n      });\n\n      var a = function (a) {\n        if (!a || !a.sdp) return !1;\n        a = G.splitSections(a.sdp);\n        return a.shift(), qg(a).call(a, a => {\n          var b;\n          return (a = G.parseMLine(a)) && \"application\" === a.kind && -1 !== J(b = a.protocol).call(b, \"SCTP\");\n        });\n      },\n          b = function (a) {\n        a = a.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (null === a || 2 > a.length) return -1;\n        a = pa(a[1], 10);\n        return a != a ? -1 : a;\n      },\n          c = function (a) {\n        let b = 65536;\n        return \"firefox\" === f.browser && (b = 57 > f.version ? -1 === a ? 16384 : 2147483637 : 60 > f.version ? 57 === f.version ? 65535 : 65536 : 2147483637), b;\n      },\n          e = function (a, b) {\n        let c = 65536;\n        \"firefox\" === f.browser && 57 === f.version && (c = 65535);\n        a = G.matchPrefix(a.sdp, \"a=max-message-size:\");\n        return 0 < a.length ? c = pa(a[0].substr(19), 10) : \"firefox\" === f.browser && -1 !== b && (c = 2147483637), c;\n      },\n          g = d.RTCPeerConnection.prototype.setRemoteDescription;\n\n      d.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        if (this._sctp = null, \"chrome\" === f.browser && 76 <= f.version) {\n          var {\n            sdpSemantics: d\n          } = this.getConfiguration();\n          \"plan-b\" === d && Y(this, \"sctp\", {\n            get() {\n              return void 0 === this._sctp ? null : this._sctp;\n            },\n\n            enumerable: !0,\n            configurable: !0\n          });\n        }\n\n        if (a(arguments[0])) {\n          var p = b(arguments[0]);\n          d = c(p);\n          p = e(arguments[0], p);\n          let a;\n          a = 0 === d && 0 === p ? Number.POSITIVE_INFINITY : 0 === d || 0 === p ? Math.max(d, p) : Math.min(d, p);\n          d = {};\n          Y(d, \"maxMessageSize\", {\n            get: () => a\n          });\n          this._sctp = d;\n        }\n\n        return g.apply(this, arguments);\n      };\n    }\n  }\n\n  function Ic(d) {\n    function f(a, c) {\n      let b = a.send;\n\n      a.send = function () {\n        var d = arguments[0];\n        d = d.length || d.size || d.byteLength;\n        if (\"open\" === a.readyState && c.sctp && d > c.sctp.maxMessageSize) throw new TypeError(\"Message too large (can send a maximum of \" + c.sctp.maxMessageSize + \" bytes)\");\n        return b.apply(a, arguments);\n      };\n    }\n\n    if (d.RTCPeerConnection && \"createDataChannel\" in d.RTCPeerConnection.prototype) {\n      var a = d.RTCPeerConnection.prototype.createDataChannel;\n\n      d.RTCPeerConnection.prototype.createDataChannel = function () {\n        let b = a.apply(this, arguments);\n        return f(b, this), b;\n      };\n\n      jc(d, \"datachannel\", a => (f(a.channel, a.target), a));\n    }\n  }\n\n  function we(d) {\n    var f;\n\n    if (d.RTCPeerConnection && !(\"connectionState\" in d.RTCPeerConnection.prototype)) {\n      var a = d.RTCPeerConnection.prototype;\n      Y(a, \"connectionState\", {\n        get() {\n          return {\n            completed: \"connected\",\n            checking: \"connecting\"\n          }[this.iceConnectionState] || this.iceConnectionState;\n        },\n\n        enumerable: !0,\n        configurable: !0\n      });\n      Y(a, \"onconnectionstatechange\", {\n        get() {\n          return this._onconnectionstatechange || null;\n        },\n\n        set(a) {\n          this._onconnectionstatechange && (this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange), delete this._onconnectionstatechange);\n          a && this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = a);\n        },\n\n        enumerable: !0,\n        configurable: !0\n      });\n      q(f = [\"setLocalDescription\", \"setRemoteDescription\"]).call(f, b => {\n        let c = a[b];\n\n        a[b] = function () {\n          return this._connectionstatechangepoly || (this._connectionstatechangepoly = a => {\n            let b = a.target;\n\n            if (b._lastConnectionState !== b.connectionState) {\n              b._lastConnectionState = b.connectionState;\n              let c = new Event(\"connectionstatechange\", a);\n              b.dispatchEvent(c);\n            }\n\n            return a;\n          }, this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly)), c.apply(this, arguments);\n        };\n      });\n    }\n  }\n\n  function xe(d) {\n    if (d.RTCPeerConnection) {\n      var f = Eb(d);\n\n      if (!(\"chrome\" === f.browser && 71 <= f.version)) {\n        var a = d.RTCPeerConnection.prototype.setRemoteDescription;\n\n        d.RTCPeerConnection.prototype.setRemoteDescription = function (b) {\n          var c, d;\n          b && b.sdp && -1 !== J(c = b.sdp).call(c, \"\\na=extmap-allow-mixed\") && (b.sdp = I(d = b.sdp.split(\"\\n\")).call(d, a => \"a=extmap-allow-mixed\" !== Xb(a).call(a)).join(\"\\n\"));\n          return a.apply(this, arguments);\n        };\n      }\n    }\n  }\n\n  function kc(d) {\n    return \"string\" == typeof d ? Ga({}, gl[d]) : d;\n  }\n\n  function ye(d) {\n    return \"string\" == typeof d ? Ga({}, hl[d]) : d;\n  }\n\n  function ud(d) {\n    return \"string\" == typeof d ? Ga({}, il[d]) : d;\n  }\n\n  function vd(d) {\n    return \"string\" == typeof d ? Ga({}, jl[d]) : d;\n  }\n\n  function Yb(d, f) {\n    var a;\n    ba(a = V(v)).call(a, d) && (v[d] = f);\n  }\n\n  function lc(d, f, a) {\n    return {\n      sampleRate: d,\n      stereo: f,\n      bitrate: a\n    };\n  }\n\n  function K(d, f, a, b, c) {\n    return {\n      width: d,\n      height: f,\n      frameRate: a,\n      bitrateMin: b,\n      bitrateMax: c\n    };\n  }\n\n  function eb(d, f, a, b, c) {\n    return {\n      width: {\n        max: d\n      },\n      height: {\n        max: f\n      },\n      frameRate: a,\n      bitrateMin: b,\n      bitrateMax: c\n    };\n  }\n\n  function ze(d, f) {\n    return {\n      numSpatialLayers: d,\n      numTemporalLayers: f\n    };\n  }\n\n  function Tg(d) {\n    return \"[object Array]\" === mc.call(d);\n  }\n\n  function Ug(d) {\n    return null !== d && \"object\" == typeof d;\n  }\n\n  function Vg(d) {\n    return \"[object Function]\" === mc.call(d);\n  }\n\n  function wd(d, f) {\n    if (null != d) if (\"object\" != typeof d && (d = [d]), Tg(d)) for (var a = 0, b = d.length; a < b; a++) f.call(null, d[a], a, d);else for (a in d) Object.prototype.hasOwnProperty.call(d, a) && f.call(null, d[a], a, d);\n  }\n\n  function Wg(d) {\n    return encodeURIComponent(d).replace(/%40/gi, \"@\").replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n  }\n\n  function xd() {\n    this.handlers = [];\n  }\n\n  function Xg(d, f) {\n    !L.isUndefined(d) && L.isUndefined(d[\"Content-Type\"]) && (d[\"Content-Type\"] = f);\n  }\n\n  function Jc(d) {\n    this.defaults = d;\n    this.interceptors = {\n      request: new Yg(),\n      response: new Yg()\n    };\n  }\n\n  function Ae(d) {\n    this.message = d;\n  }\n\n  function yd(d) {\n    if (\"function\" != typeof d) throw new TypeError(\"executor must be a function.\");\n    var f;\n    this.promise = new Promise(function (a) {\n      f = a;\n    });\n    var a = this;\n    d(function (b) {\n      a.reason || (a.reason = new Zg(b), f(a.reason));\n    });\n  }\n\n  function $g(d) {\n    d = new zd(d);\n    var f = ah(zd.prototype.request, d);\n    return L.extend(f, zd.prototype, d), L.extend(f, d), f;\n  }\n\n  function bh() {\n    let d = new Date();\n    return d.toTimeString().split(\" \")[0] + \":\" + d.getMilliseconds();\n  }\n\n  function Be(d, f) {\n    if (\"boolean\" != typeof d) throw new n(l.INVALID_PARAMS, \"Invalid \".concat(f, \": The value is of the boolean type.\"));\n  }\n\n  function Ka(d, f, a) {\n    var b;\n    if (!ba(a).call(a, d)) throw new n(l.INVALID_PARAMS, m(b = \"\".concat(f, \" can only be set as \")).call(b, w(a)));\n  }\n\n  function W(d, f, a = 1, b = 1E4, c = !0) {\n    if (d < a || d > b || c && (\"number\" != typeof d || 0 != d % 1)) {\n      var e, g;\n      throw new n(l.INVALID_PARAMS, m(e = m(g = \"invalid \".concat(f, \": the value range is [\")).call(g, a, \", \")).call(e, b, \"]. integer only\"));\n    }\n  }\n\n  function Fa(d, f, a = 1, b = 255, c = !0) {\n    if (null == d) throw new n(l.INVALID_PARAMS, \"\".concat(f || \"param\", \" cannot be empty\"));\n    var e, g, h;\n    if (!ch(d, a, b, c)) throw new n(l.INVALID_PARAMS, m(e = m(g = m(h = \"Invalid \".concat(f || \"string param\", \": Length of the string: [\")).call(h, a, \",\")).call(g, b, \"].\")).call(e, c ? \" ASCII characters only.\" : \"\"));\n  }\n\n  function dh(d, f) {\n    if (!Pb(d)) throw new n(l.INVALID_PARAMS, \"\".concat(f, \" should be an array\"));\n  }\n\n  function Ce(d) {\n    if (\"string\" != typeof d || !/^[a-zA-Z0-9 !#\\$%&\\(\\)\\+\\-:;<=\\.>\\?@\\[\\]\\^_\\{\\}\\|~,]{1,64}$/.test(d)) throw k.error(\"Invalid Channel Name \".concat(d)), new n(l.INVALID_PARAMS, \"The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,\");\n  }\n\n  function De(d) {\n    var f;\n    if (!(\"number\" == typeof d && Math.floor(d) === d && 0 <= d && 4294967295 >= d || ch(d, 1, 255))) throw k.error(m(f = \"Invalid UID \".concat(d, \" \")).call(f, typeof d)), new n(l.INVALID_PARAMS, \"[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]\");\n  }\n\n  function ch(d, f = 1, a = 255, b = !0) {\n    if (f = \"string\" == typeof d && d.length <= a && d.length >= f) {\n      if (!(b = !b)) a: if (\"string\" != typeof d) b = !1;else {\n        for (b = 0; b < d.length; b += 1) if (f = d.charCodeAt(b), 0 > f || 255 < f) {\n          b = !1;\n          break a;\n        }\n\n        b = !0;\n      }\n      f = b;\n    }\n\n    return f;\n  }\n\n  function kl(d) {\n    return Fa(d.reportId, \"params.reportId\", 0, 100, !1), Fa(d.category, \"params.category\", 0, 100, !1), Fa(d.event, \"params.event\", 0, 100, !1), Fa(d.label, \"params.label\", 0, 100, !1), W(d.value, \"params.value\", -9007199254740991, 9007199254740991, !1), !0;\n  }\n\n  function eh(d) {\n    return W(d.timeout, \"config.timeout\", 0, 1E5), W(d.timeoutFactor, \"config.timeoutFactor\", 0, 100, !1), W(d.maxRetryCount, \"config.maxRetryConfig\", 0, 1 / 0), W(d.maxRetryTimeout, \"config.maxRetryTimeout\", 0, 1 / 0), !0;\n  }\n\n  function fh(d) {\n    if (!Pb(d) || 1 > d.length) return !1;\n\n    try {\n      q(d).call(d, d => {\n        if (!d.urls) throw Error();\n      });\n    } catch (f) {\n      return !1;\n    }\n\n    return !0;\n  }\n\n  function gh(d) {\n    return Fa(d.turnServerURL, \"turnServerURL\"), Fa(d.username, \"username\"), Fa(d.password, \"password\"), d.udpport && W(d.udpport, \"udpport\", 1, 99999, !0), d.forceturn && Be(d.forceturn, \"forceturn\"), d.security && Be(d.security, \"security\"), d.tcpport && W(d.tcpport, \"tcpport\", 1, 99999, !0), !0;\n  }\n\n  function hh(d) {\n    return void 0 !== d.level && Ka(d.level, \"level\", [1, 2]), !0;\n  }\n\n  function Ee(d, f) {\n    Fa(d.url, \"\".concat(f, \".url\"), 1, 1E3, !1);\n    null == d.x || W(d.x, \"\".concat(f, \".x\"), 0, 1E4);\n    null == d.y || W(d.y, \"\".concat(f, \".y\"), 0, 1E4);\n    null == d.width || W(d.width, \"\".concat(f, \".width\"), 0, 1E4);\n    null == d.height || W(d.height, \"\".concat(f, \".height\"), 0, 1E4);\n    null == d.zOrder || W(d.zOrder, \"\".concat(f, \".zOrder\"), 0, 255);\n    null == d.alpha || W(d.alpha, \"\".concat(f, \".alpha\"), 0, 1, !1);\n  }\n\n  function ih(d) {\n    if (!d.channelName) throw new n(l.INVALID_PARAMS, \"invalid channelName in info\");\n    if (!d.uid || \"number\" != typeof d.uid) throw new n(l.INVALID_PARAMS, \"invalid uid in info, uid must be a number\");\n    return d.token && Fa(d.token, \"info.token\", 1, 2047), De(d.uid), Ce(d.channelName), !0;\n  }\n\n  function jh(d) {\n    return Ka(d, \"mediaSource\", [\"screen\", \"window\", \"application\"]), !0;\n  }\n\n  function na(d) {\n    var f, a, b, c;\n    d = d || navigator.userAgent;\n    let e = d.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || [];\n\n    if (\"Chrome\" === e[1]) {\n      var g = d.match(/(OPR(?=\\/))\\/?(\\d+)/i);\n      null !== g && (e = g);\n    }\n\n    \"Safari\" === e[1] && (g = d.match(/version\\/(\\d+)/i), null !== g && (e[2] = g[1]));\n    -1 !== J(f = d.toLowerCase()).call(f, \"qqbrowser\") && (f = d.match(/(qqbrowser(?=\\/))\\/?(\\d+)/i), null !== f && (e = f));\n    -1 !== J(a = d.toLowerCase()).call(a, \"micromessenger\") && (a = d.match(/(micromessenger(?=\\/))\\/?(\\d+)/i), null !== a && (e = a));\n    -1 !== J(b = d.toLowerCase()).call(b, \"edge\") && (b = d.match(/(edge(?=\\/))\\/?(\\d+)/i), null !== b && (e = b));\n    -1 !== J(c = d.toLowerCase()).call(c, \"trident\") && (c = /\\brv[ :]+(\\d+)/g.exec(d) || [], null !== c && (e = [\"\", \"IE\", c[1]]));\n    c = null;\n    b = [{\n      s: X.WIN_10,\n      r: /(Windows 10.0|Windows NT 10.0)/\n    }, {\n      s: X.WIN_81,\n      r: /(Windows 8.1|Windows NT 6.3)/\n    }, {\n      s: X.WIN_8,\n      r: /(Windows 8|Windows NT 6.2)/\n    }, {\n      s: X.WIN_7,\n      r: /(Windows 7|Windows NT 6.1)/\n    }, {\n      s: X.WIN_VISTA,\n      r: /Windows NT 6.0/\n    }, {\n      s: X.WIN_SERVER_2003,\n      r: /Windows NT 5.2/\n    }, {\n      s: X.WIN_XP,\n      r: /(Windows NT 5.1|Windows XP)/\n    }, {\n      s: X.WIN_2000,\n      r: /(Windows NT 5.0|Windows 2000)/\n    }, {\n      s: X.ANDROID,\n      r: /Android/\n    }, {\n      s: X.OPEN_BSD,\n      r: /OpenBSD/\n    }, {\n      s: X.SUN_OS,\n      r: /SunOS/\n    }, {\n      s: X.LINUX,\n      r: /(Linux|X11)/\n    }, {\n      s: X.IOS,\n      r: /(iPhone|iPad|iPod)/\n    }, {\n      s: X.MAC_OS_X,\n      r: /Mac OS X/\n    }, {\n      s: X.MAC_OS,\n      r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/\n    }, {\n      s: X.QNX,\n      r: /QNX/\n    }, {\n      s: X.UNIX,\n      r: /UNIX/\n    }, {\n      s: X.BEOS,\n      r: /BeOS/\n    }, {\n      s: X.OS_2,\n      r: /OS\\/2/\n    }, {\n      s: X.SEARCH_BOT,\n      r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\\/Teoma|ia_archiver)/\n    }];\n\n    for (let e in b) if (a = b[e], a.r.test(d)) {\n      c = a.s;\n      break;\n    }\n\n    return {\n      name: e[1],\n      version: e[2],\n      os: c\n    };\n  }\n\n  function Kc() {\n    return na().name === ca.CHROME;\n  }\n\n  function Ad() {\n    return na().name === ca.FIREFOX;\n  }\n\n  function kh() {\n    return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./) && 35 >= window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./)[1];\n  }\n\n  function Bd() {\n    let d = na();\n    return d.name === ca.EDGE || d.name === ca.SAFARI ? !1 : !!navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]./i);\n  }\n\n  function lh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function vb(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = lh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = lh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function ll(d) {\n    if (!d.address || !d.tcp) throw new n(l.UNEXPECTED_RESPONSE, \"Invalid address format \".concat(d));\n    return d.address.match(/^[\\.:\\d]+$/) ? \"\".concat(d.address.replace(/[^\\d]/g, \"-\"), \".edge.agora.io\") : (k.info(\"Cannot recognized as IP address \".concat(d.address, \". Used As Host instead\")), m(f = \"\".concat(d.address, \":\")).call(f, d.tcp));\n    var f;\n  }\n\n  function Qb(d) {\n    return \"number\" == typeof d ? d : d.exact || d.ideal || d.max || d.min || 0;\n  }\n\n  function mh(d, f) {\n    let a = d.videoSend[0];\n    if (!a) return null;\n    f = f && f.videoSend[0] ? f.videoSend[0].inputFrame : void 0;\n    d = {\n      id: qa(10, \"\"),\n      timestamp: new Date(d.timestamp).toISOString(),\n      mediaType: \"video\",\n      type: \"ssrc\",\n      ssrc: a.ssrc.toString()\n    };\n    return a.inputFrame && (f && a.inputFrame.height === f.height || (d.A_fhi = a.inputFrame.height ? a.inputFrame.height.toString() : \"0\"), f && a.inputFrame.width === f.width || (d.A_fwi = a.inputFrame.width ? a.inputFrame.width.toString() : \"0\"), f && a.inputFrame.frameRate === f.frameRate || (d.A_fri = a.inputFrame.frameRate ? a.inputFrame.frameRate.toString() : \"0\")), d;\n  }\n\n  function nh(d) {\n    return 0 <= d && .17 > d ? 1 : .17 <= d && .36 > d ? 2 : .36 <= d && .59 > d ? 3 : .59 <= d && 1 >= d ? 4 : 1 < d ? 5 : 0;\n  }\n\n  function ml(d, f) {\n    let a = {};\n    d.height && d.width && (f = f._videoHeight || f.getMediaStreamTrack(!0).getSettings().height, a.scaleResolutionDownBy = f ? f / Qb(d.height) : 4);\n    return a.maxFramerate = d.framerate ? Qb(d.framerate) : void 0, a.maxBitrate = d.bitrate ? 1E3 * d.bitrate : void 0, a;\n  }\n\n  function oh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Fe(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = oh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = oh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Cd(d) {\n    return window.TextEncoder ? new TextEncoder().encode(d).length : d.length;\n  }\n\n  function wb(d) {\n    return new A(f => {\n      window.setTimeout(f, d);\n    });\n  }\n\n  function nl(d) {\n    let f = new n(l.TIMEOUT, \"timeout\");\n    return new A((a, b) => {\n      window.setTimeout(() => b(f), d);\n    });\n  }\n\n  function qa(d = 7, f) {\n    var a, b;\n    let c = Math.random().toString(16).substr(2, d).toLowerCase();\n    return c.length === d ? m(a = \"\".concat(f)).call(a, c) : m(b = \"\".concat(f)).call(b, c) + qa(d - c.length, \"\");\n  }\n\n  function ph(d) {\n    return new A((f, a) => {\n      let b = document.createElement(\"video\");\n      b.setAttribute(\"autoplay\", \"\");\n      b.setAttribute(\"muted\", \"\");\n      b.muted = !0;\n      b.autoplay = !0;\n      b.setAttribute(\"playsinline\", \"\");\n      b.setAttribute(\"style\", \"position: absolute; top: 0; left: 0; width: 1px; height: 1px\");\n      document.body.appendChild(b);\n      b.addEventListener(\"playing\", () => {\n        !b.videoWidth && Ad() || (document.body.removeChild(b), f([b.videoWidth, b.videoHeight]));\n      });\n      b.srcObject = new MediaStream([d]);\n    });\n  }\n\n  function Lc(d) {\n    return A.all(E(d).call(d, d => d.then(a => {\n      throw a;\n    }, a => a))).then(d => {\n      throw d;\n    }, d => d);\n  }\n\n  function La(d, f, ...a) {\n    return 0 === d.getListeners(f).length ? A.reject(new n(l.UNEXPECTED_ERROR, \"can not emit promise\")) : new A((b, c) => {\n      d.emit(f, ...a, b, c);\n    });\n  }\n\n  function Pa(d, f, ...a) {\n    return 0 === d.getListeners(f).length ? A.resolve() : La(d, f, ...a);\n  }\n\n  function Zb(d, f, ...a) {\n    return 0 === d.getListeners(f).length ? null : Mc(d, f, ...a);\n  }\n\n  function Mc(d, f, ...a) {\n    let b = null,\n        c = null;\n    if (d.emit(f, ...a, a => {\n      b = a;\n    }, a => {\n      c = a;\n    }), null !== c) throw c;\n    if (null === b) throw new n(l.UNEXPECTED_ERROR, \"handler is not sync\");\n    return b;\n  }\n\n  function Nc(d, f) {\n    f = J(d).call(d, f);\n    -1 !== f && Ia(d).call(d, f, 1);\n  }\n\n  function qh(d) {\n    let f = [];\n    return q(d).call(d, a => {\n      -1 === J(f).call(f, a) && f.push(a);\n    }), f;\n  }\n\n  function Za(d) {\n    A.resolve().then(d);\n  }\n\n  function Oc(d, f) {\n    rh[f] || (rh[f] = !0, d());\n  }\n\n  function Ge(d) {\n    d = window.atob(d);\n    let f = new Uint8Array(new ArrayBuffer(d.length));\n\n    for (let a = 0; a < d.length; a += 1) f[a] = d.charCodeAt(a);\n\n    return f;\n  }\n\n  function Dd(d) {\n    let f = \"\";\n\n    for (let a = 0; a < d.length; a += 1) f += String.fromCharCode(d[a]);\n\n    return window.btoa(f);\n  }\n\n  function sh(_x, _x2) {\n    return _sh.apply(this, arguments);\n  }\n\n  function _sh() {\n    _sh = _asyncToGenerator(function* (d, f) {\n      let a = (a, c) => a ? \"number\" != typeof a ? a.max || a.exact || a.ideal || a.min || c : a : c;\n\n      d = {\n        audio: !1,\n        video: {\n          mandatory: {\n            chromeMediaSource: \"desktop\",\n            chromeMediaSourceId: d,\n            maxHeight: a(f.height, 1080),\n            maxWidth: a(f.width, 1920)\n          }\n        }\n      };\n      return f.frameRate && \"number\" != typeof f.frameRate ? (d.video.mandatory.maxFrameRate = f.frameRate.max, d.video.mandatory.minFrameRate = f.frameRate.min) : \"number\" == typeof f.frameRate && (d.video.mandatory.maxFrameRate = f.frameRate), yield navigator.mediaDevices.getUserMedia(d);\n    });\n    return _sh.apply(this, arguments);\n  }\n\n  function ol(_x3) {\n    return _ol.apply(this, arguments);\n  }\n\n  function _ol() {\n    _ol = _asyncToGenerator(function* (d) {\n      let f = yield function (a) {\n        return new A((b, c) => {\n          const d = document.createElement(\"div\");\n          d.innerText = \"share screen\";\n          d.setAttribute(\"style\", \"text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;\");\n          const g = document.createElement(\"div\");\n          g.setAttribute(\"style\", \"width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;\");\n          const h = document.createElement(\"div\");\n          h.innerText = \"Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.\";\n          h.setAttribute(\"style\", \"height: 12%;\");\n          const f = document.createElement(\"div\");\n          f.setAttribute(\"style\", \"width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;\");\n          const r = document.createElement(\"div\");\n          r.setAttribute(\"style\", \"text-align: right; padding: 16px 0;\");\n          const t = document.createElement(\"button\");\n          t.innerHTML = \"cancel\";\n          t.setAttribute(\"style\", \"width: 85px;\");\n\n          t.onclick = () => {\n            document.body.removeChild(y);\n            const a = Error(\"NotAllowedError\");\n            a.name = \"NotAllowedError\";\n            c(a);\n          };\n\n          r.appendChild(t);\n          g.appendChild(h);\n          g.appendChild(f);\n          g.appendChild(r);\n          const y = document.createElement(\"div\");\n          y.setAttribute(\"style\", \"position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);\");\n          y.appendChild(d);\n          y.appendChild(g);\n          document.body.appendChild(y);\n          E(a).call(a, a => {\n            if (a.id) {\n              const c = document.createElement(\"div\");\n              c.setAttribute(\"style\", \"width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;\");\n              let d = a.thumbnail;\n              const {\n                width: e\n              } = d.getSize();\n              1920 < e && (d = d.resize({\n                width: 1920\n              }));\n              c.innerHTML = '<div style=\"height: 120px; display: table-cell; vertical-align: middle;\"><img style=\"width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);\" src=' + d.toDataURL() + ' /></div><span style=\"\\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;\">' + (a.name.replace(/[\\u00A0-\\u9999<>&]/g, function (a) {\n                return \"&#\" + a.charCodeAt(0) + \";\";\n              }) + \"</span>\");\n\n              c.onclick = () => {\n                document.body.removeChild(y);\n                b(a.id);\n              };\n\n              f.appendChild(c);\n            }\n          });\n        });\n      }(yield th(d.mediaSource));\n      return yield sh(f, d);\n    });\n    return _ol.apply(this, arguments);\n  }\n\n  function th(_x4) {\n    return _th.apply(this, arguments);\n  }\n\n  function _th() {\n    _th = _asyncToGenerator(function* (d) {\n      let f = [\"window\", \"screen\"];\n      \"application\" !== d && \"window\" !== d || (f = [\"window\"]);\n      \"screen\" === d && (f = [\"screen\"]);\n      let a = uh();\n      if (!a) throw new n(l.ELECTRON_IS_NULL);\n      d = null;\n\n      try {\n        d = a.desktopCapturer.getSources({\n          types: f\n        });\n      } catch (b) {\n        d = null;\n      }\n\n      d && d.then || (d = new A((b, c) => {\n        a.desktopCapturer.getSources({\n          types: f\n        }, (a, d) => {\n          a ? c(a) : b(d);\n        });\n      }));\n\n      try {\n        return yield d;\n      } catch (b) {\n        throw new n(l.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, b.toString());\n      }\n    });\n    return _th.apply(this, arguments);\n  }\n\n  function uh() {\n    if (Ed) return Ed;\n\n    try {\n      return Ed = window.require(\"electron\"), Ed;\n    } catch (d) {\n      return null;\n    }\n  }\n\n  function xb(_x5, _x6) {\n    return _xb.apply(this, arguments);\n  }\n\n  function _xb() {\n    _xb = _asyncToGenerator(function* (d, f) {\n      let a = 0,\n          b = null;\n\n      for (; 2 > a;) try {\n        b = yield pl(d, f, 0 < a);\n        break;\n      } catch (g) {\n        var c, e;\n        if (g instanceof n) throw k.error(m(e = \"[\".concat(f, \"] \")).call(e, g.toString())), g;\n        let b = Fd(g.name || g.code || g, g.message);\n        if (b.code === l.MEDIA_OPTION_INVALID) k.debug(\"[\".concat(f, \"] detect media option invalid, retry\")), a += 1, yield wb(500);else throw k.error(m(c = \"[\".concat(f, \"] \")).call(c, b.toString())), b;\n      }\n\n      if (!b) throw new n(l.UNEXPECTED_ERROR, \"can not find stream after getUserMedia\");\n      return b;\n    });\n    return _xb.apply(this, arguments);\n  }\n\n  function pl(_x7, _x8, _x9) {\n    return _pl.apply(this, arguments);\n  }\n\n  function _pl() {\n    _pl = _asyncToGenerator(function* (d, f, a) {\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new n(l.NOT_SUPPORTED, \"can not find getUserMedia\");\n      a && (d.video && (delete d.video.width, delete d.video.height), d.screen && (delete d.screen.width, delete d.screen.height));\n      var b = ha;\n      a = new MediaStream();\n      if (d.audioSource && a.addTrack(d.audioSource), d.videoSource && a.addTrack(d.videoSource), !d.audio && !d.video && !d.screen) return k.debug(\"Using Video Source/ Audio Source\"), a;\n      if (d.screen) if (uh()) d.screen.sourceId ? nc(a, yield sh(d.screen.sourceId, d.screen)) : nc(a, yield ol(d.screen));else if (Kc() && d.screen.extensionId && d.screen.mandatory) {\n        if (!b.getStreamFromExtension) throw new n(l.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n        k.debug(\"[\".concat(f, '] Screen access on chrome stable, looking for extension\"'));\n        var c = yield (e = d.screen.extensionId, g = f, new A((a, b) => {\n          try {\n            chrome.runtime.sendMessage(e, {\n              getStream: !0\n            }, c => {\n              if (!c || !c.streamId) return k.error(\"[\".concat(g, \"] No response from Chrome Plugin. Plugin not installed properly\"), c), void b(new n(l.CHROME_PLUGIN_NO_RESPONSE, \"No response from Chrome Plugin. Plugin not installed properly\"));\n              a(c.streamId);\n            });\n          } catch (y) {\n            var c;\n            k.error(m(c = \"[\".concat(g, \"] AgoraRTC screensharing plugin is not accessible(\")).call(c, e, \")\"), y.toString());\n            b(new n(l.CHROME_PLUGIN_NOT_INSTALL));\n          }\n        }));\n        d.screen.mandatory.chromeMediaSourceId = c;\n        nc(a, yield navigator.mediaDevices.getUserMedia({\n          video: {\n            mandatory: d.screen.mandatory\n          }\n        }));\n      } else if (b.getDisplayMedia) d.screen.mediaSource && jh(d.screen.mediaSource), c = {\n        width: d.screen.width,\n        height: d.screen.height,\n        frameRate: d.screen.frameRate,\n        displaySurface: \"screen\" === d.screen.mediaSource ? \"monitor\" : d.screen.mediaSource\n      }, k.debug(\"[\".concat(f, \"] getDisplayMedia:\"), w({\n        video: c,\n        audio: !!d.screenAudio\n      })), nc(a, yield navigator.mediaDevices.getDisplayMedia({\n        video: c,\n        audio: !!d.screenAudio\n      }));else {\n        if (!Ad()) throw k.error(\"[\".concat(f, \"] This browser does not support screenSharing\")), new n(l.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n        d.screen.mediaSource && jh(d.screen.mediaSource);\n        b = {\n          video: {\n            mediaSource: d.screen.mediaSource,\n            width: d.screen.width,\n            height: d.screen.height,\n            frameRate: d.screen.frameRate\n          }\n        };\n        k.debug(m(c = \"[\".concat(f, \"] getUserMedia: \")).call(c, w(b)));\n        nc(a, yield navigator.mediaDevices.getUserMedia(b));\n      }\n      var e, g;\n      if (!d.video && !d.audio) return a;\n      d = {\n        video: d.video,\n        audio: d.audio\n      };\n      k.debug(\"[\".concat(f, \"] GetUserMedia\"), w(d));\n      f = na();\n      let h;\n      c = null;\n      f.name !== ca.SAFARI && f.os !== X.IOS || (c = yield He.lock());\n\n      try {\n        h = yield navigator.mediaDevices.getUserMedia(d);\n      } catch (p) {\n        throw c && c(), p;\n      }\n\n      return d.audio && (vh = !0), d.video && (wh = !0), nc(a, h), c && c(), a;\n    });\n    return _pl.apply(this, arguments);\n  }\n\n  function Fd(d, f) {\n    switch (d) {\n      case \"Starting video failed\":\n      case \"OverconstrainedError\":\n      case \"TrackStartError\":\n        var a;\n        return new n(l.MEDIA_OPTION_INVALID, m(a = \"\".concat(d, \": \")).call(a, f));\n\n      case \"NotFoundError\":\n      case \"DevicesNotFoundError\":\n        var b;\n        return new n(l.DEVICE_NOT_FOUND, m(b = \"\".concat(d, \": \")).call(b, f));\n\n      case \"NotSupportedError\":\n        var c;\n        return new n(l.NOT_SUPPORTED, m(c = \"\".concat(d, \": \")).call(c, f));\n\n      case \"NotReadableError\":\n        var e;\n        return new n(l.NOT_READABLE, m(e = \"\".concat(d, \": \")).call(e, f));\n\n      case \"InvalidStateError\":\n      case \"NotAllowedError\":\n      case \"PERMISSION_DENIED\":\n      case \"PermissionDeniedError\":\n        var g;\n        return new n(l.PERMISSION_DENIED, m(g = \"\".concat(d, \": \")).call(g, f));\n\n      case \"ConstraintNotSatisfiedError\":\n        var h;\n        return new n(l.CONSTRAINT_NOT_SATISFIED, m(h = \"\".concat(d, \": \")).call(h, f));\n\n      default:\n        var p;\n        return k.error(\"getUserMedia unexpected error\", d), new n(l.UNEXPECTED_ERROR, m(p = \"\".concat(d, \": \")).call(p, f));\n    }\n  }\n\n  function nc(d, f) {\n    let a = d.getVideoTracks()[0],\n        b = d.getAudioTracks()[0],\n        c = f.getVideoTracks()[0];\n    (f = f.getAudioTracks()[0]) && (b && d.removeTrack(b), d.addTrack(f));\n    c && (a && d.removeTrack(a), d.addTrack(c));\n  }\n\n  function xh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function yb(d, f, a) {\n    return new A((b, c) => {\n      f.timeout = f.timeout || v.HTTP_CONNECT_TIMEOUT;\n      f.responseType = f.responseType || \"json\";\n      f.data && !a ? (f.data = w(f.data), yh += Cd(f.data)) : a && (yh += f.data.size);\n      f.headers = f.headers || {};\n      f.headers[\"Content-Type\"] = f.headers[\"Content-Type\"] || \"application/json\";\n      f.method = \"POST\";\n      f.url = d;\n      zb.request(f).then(a => {\n        \"string\" == typeof a.data ? Ie += Cd(a.data) : a.data instanceof ArrayBuffer || a.data instanceof Uint8Array ? Ie += a.data.byteLength : Ie += Cd(w(a.data));\n        b(a.data);\n      }).catch(a => {\n        zb.isCancel(a) ? c(new n(l.OPERATION_ABORTED, \"cancel token canceled\")) : \"ECONNABORTED\" === a.code ? c(new n(l.NETWORK_TIMEOUT, a.message)) : a.response ? c(new n(l.NETWORK_RESPONSE_ERROR, a.response.status)) : c(new n(l.NETWORK_ERROR, a.message));\n      });\n    });\n  }\n\n  function ql(_x10, _x11) {\n    return _ql.apply(this, arguments);\n  }\n\n  function _ql() {\n    _ql = _asyncToGenerator(function* (d, f) {\n      let a = new Blob([f.data], {\n        type: \"buffer\"\n      });\n      return yield yb(d, function (a) {\n        for (var b = 1; b < arguments.length; b++) {\n          var d,\n              g = null != arguments[b] ? arguments[b] : {};\n          if (b % 2) q(d = xh(Object(g), !0)).call(d, function (b) {\n            Na(a, b, g[b]);\n          });else if (fa) Oa(a, fa(g));else {\n            var h;\n            q(h = xh(Object(g))).call(h, function (b) {\n              Y(a, b, Z(g, b));\n            });\n          }\n        }\n\n        return a;\n      }({}, f, {\n        data: a,\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        }\n      }), !0);\n    });\n    return _ql.apply(this, arguments);\n  }\n\n  function zh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function va(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = zh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = zh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Je(d = {\n    report: u\n  }) {\n    return function (f, a, b) {\n      let c = f[a];\n\n      if (\"function\" == typeof c) {\n        let e = \"AgoraRTCClient\" === f.constructor.name ? \"Client\" : f.constructor.name;\n\n        b.value = function (...b) {\n          var g;\n          let f = d.report.reportApiInvoke(this._sessionId || null, {\n            name: m(g = \"\".concat(e, \".\")).call(g, a),\n            options: b,\n            tag: B.TRACER\n          });\n\n          try {\n            let a = c.apply(this, b);\n            return f.onSuccess(), a;\n          } catch (r) {\n            throw f.onError(r), r;\n          }\n        };\n      }\n\n      return b;\n    };\n  }\n\n  function Gd(d) {\n    var f = rl[Math.floor(d / 1E4)];\n    if (!f) return {\n      desc: \"unkonw error\",\n      retry: !1\n    };\n    f = f[d % 1E4];\n\n    if (!f) {\n      if (Math.floor(d / 1E4) === oc.ACCESS_POINT) {\n        d %= 1E4;\n        if (\"1\" === d.toString()[0]) return {\n          desc: d.toString(),\n          retry: !1\n        };\n        if (\"2\" === d.toString()[0]) return {\n          desc: d.toString(),\n          retry: !0\n        };\n      }\n\n      return {\n        desc: \"unkonw error\",\n        retry: !1\n      };\n    }\n\n    return f;\n  }\n\n  function Ah(d) {\n    return sl[d] || {\n      desc: \"UNKNOW_ERROR_\".concat(d),\n      action: \"failed\"\n    };\n  }\n\n  function Fb(d, f, a, b) {\n    let c = Ga({}, Qa, b),\n        e = c.timeout,\n        g = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        yield wb(e);\n        e *= c.timeoutFactor;\n        e = Math.min(c.maxRetryTimeout, e);\n      });\n\n      return function g() {\n        return _ref.apply(this, arguments);\n      };\n    }(),\n        h = !1;\n\n    b = new A( /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (b, e) {\n        f = f || (() => !1);\n\n        a = a || (() => !0);\n\n        for (let p = 0; p < c.maxRetryCount; p += 1) {\n          if (h) return e(new n(l.OPERATION_ABORTED));\n\n          try {\n            const a = yield d();\n            if (!f(a, p) || p + 1 === c.maxRetryCount) return b(a);\n            yield g();\n          } catch (y) {\n            if (!a(y, p) || p + 1 === c.maxRetryCount) return e(y);\n            yield g();\n          }\n        }\n      });\n\n      return function (_x12, _x13) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    return b.cancel = () => h = !0, b;\n  }\n\n  function tl() {\n    Bh ? (k.info(\"create audio context\"), pc = new Bh(), pc.onstatechange = () => {\n      Pc.emit(\"state-change\");\n    }, function (d) {\n      function f(c) {\n        \"running\" === d.state ? a(!1) : \"closed\" !== d.state && (a(!0), c ? d.resume().then(b, b) : a(!1));\n      }\n\n      function a(a) {\n        if (g !== a) {\n          g = a;\n\n          for (let b = 0, d = e; b < d.length; b += 1) {\n            let e = d[b];\n            a ? window.addEventListener(e, c, {\n              capture: !0,\n              passive: !0\n            }) : window.removeEventListener(e, c, {\n              capture: !0,\n              passive: !0\n            });\n          }\n        }\n      }\n\n      function b() {\n        f(!1);\n      }\n\n      function c() {\n        f(!0);\n      }\n\n      let e = \"click contextmenu auxclick dblclick mousedown mouseup touchend keydown keyup\".split(\" \"),\n          g = !1;\n\n      d.onstatechange = function () {\n        f(!0);\n      };\n\n      f(!1);\n    }(pc)) : k.error(\"your browser is not support web audio\");\n  }\n\n  function Qc() {\n    if (!pc && (tl(), !pc)) throw new n(l.NOT_SUPPORTED, \"can not create audio context\");\n    return pc;\n  }\n\n  function Rc(d) {\n    if (!function () {\n      if (null !== Ke) return Ke;\n      var a = Qc();\n      let c = a.createBufferSource(),\n          d = a.createGain();\n      a = a.createGain();\n      c.connect(d);\n      c.connect(a);\n      c.disconnect(d);\n      a = !1;\n\n      try {\n        c.disconnect(d);\n      } catch (g) {\n        a = !0;\n      }\n\n      return c.disconnect(), Ke = a, a;\n    }()) {\n      k.debug(\"polyfill audio node\");\n      var f = d.connect,\n          a = d.disconnect;\n\n      d.connect = (a, c, e) => {\n        var b;\n        return d._inputNodes || (d._inputNodes = []), ba(b = d._inputNodes).call(b, a) || (a instanceof AudioNode ? (d._inputNodes.push(a), f.call(d, a, c, e)) : f.call(d, a, c)), d;\n      };\n\n      d.disconnect = (b, c, e) => {\n        a.call(d);\n        b ? Nc(d._inputNodes, b) : d._inputNodes = [];\n\n        for (let a of d._inputNodes) f.call(d, a);\n      };\n    }\n  }\n\n  function Le(d, f) {\n    let a = 1 / f,\n        b = Qc(),\n        c = b.createGain();\n    c.gain.value = 0;\n    c.connect(b.destination);\n\n    let e = !1,\n        g = () => {\n      if (e) return void (c = null);\n      const h = b.createOscillator();\n      h.onended = g;\n      h.connect(c);\n      h.start(0);\n      h.stop(b.currentTime + a);\n      d(b.currentTime);\n    };\n\n    return g(), () => {\n      e = !0;\n    };\n  }\n\n  function Ch(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Me(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = Ch(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = Ch(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Dh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Ne(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = Dh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = Dh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Eh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function ul(d, f, a, b, c) {\n    Oe += 1;\n    let e = {\n      sid: a.sid,\n      command: \"convergeAllocateEdge\",\n      uid: \"666\",\n      appId: a.appId,\n      ts: Math.floor(x() / 1E3),\n      seq: Oe,\n      requestId: Oe,\n      version: Ta,\n      cname: a.cname\n    },\n        g = {\n      service_name: f,\n      json_body: w(e)\n    },\n        h,\n        p,\n        r = d[0];\n    return Fb( /*#__PURE__*/_asyncToGenerator(function* () {\n      h = x();\n      var a = yield yb(r, {\n        data: g,\n        cancelToken: b,\n        headers: {\n          \"X-Packet-Service-Type\": \"0\",\n          \"X-Packet-URI\": \"61\"\n        }\n      });\n\n      if (p = x() - h, 0 !== a.code) {\n        var c = new n(l.UNEXPECTED_RESPONSE, \"live streaming ap error, code\" + a.code, {\n          retry: !0,\n          responseTime: p\n        });\n        throw k.error(c.toString()), c;\n      }\n\n      a = JSON.parse(a.json_body);\n      if (200 !== a.code) throw a = new n(l.UNEXPECTED_RESPONSE, m(c = \"live streaming app center error, code: \".concat(a.code, \", reason: \")).call(c, a.reason), {\n        code: a.code,\n        responseTime: p\n      }), k.error(a.toString()), a;\n      if (!a.servers || 0 === a.servers.length) throw c = new n(l.UNEXPECTED_RESPONSE, \"live streaming app center empty server\", {\n        code: a.code,\n        responseTime: p\n      }), k.error(c.toString()), c;\n\n      c = function (a, b) {\n        var c;\n        return {\n          addressList: E(c = a.servers).call(c, a => {\n            var c, d;\n            return m(c = m(d = \"wss://\".concat(a.address.replace(/\\./g, \"-\"), \".edge.agora.io:\")).call(d, a.wss, \"?serviceName=\")).call(c, encodeURIComponent(b));\n          }),\n          workerToken: a.workerToken,\n          vid: a.vid\n        };\n      }(a, f);\n\n      return v.LIVE_STREAMING_ADDRESS && (c.addressList = v.LIVE_STREAMING_ADDRESS instanceof Array ? v.LIVE_STREAMING_ADDRESS : [v.LIVE_STREAMING_ADDRESS]), function (a) {\n        for (var b = 1; b < arguments.length; b++) {\n          var c,\n              d = null != arguments[b] ? arguments[b] : {};\n          if (b % 2) q(c = Eh(Object(d), !0)).call(c, function (b) {\n            Na(a, b, d[b]);\n          });else if (fa) Oa(a, fa(d));else {\n            var e;\n            q(e = Eh(Object(d))).call(e, function (b) {\n              Y(a, b, Z(d, b));\n            });\n          }\n        }\n\n        return a;\n      }({}, c, {\n        responseTime: p\n      });\n    }), (b, c) => (u.apworkerEvent(a.sid, {\n      success: !0,\n      sc: 200,\n      serviceName: f,\n      responseDetail: w(b.addressList),\n      firstSuccess: 0 === c,\n      responseTime: p,\n      serverIp: d[c % d.length]\n    }), !1), (b, c) => (u.apworkerEvent(a.sid, {\n      success: !1,\n      sc: b.data && b.data.code || 200,\n      serviceName: f,\n      responseTime: p,\n      serverIp: d[c % d.length]\n    }), !!(b.code !== l.OPERATION_ABORTED && b.code !== l.UNEXPECTED_RESPONSE || b.data && b.data.retry) && (r = d[(c + 1) % d.length], !0)), c);\n  }\n\n  function Fh({\n    url: d,\n    areaCode: f\n  }, a, b, c) {\n    let e = x(),\n        g = {\n      opid: 133,\n      flag: 4096,\n      ts: x(),\n      key: a.token,\n      cname: a.cname,\n      sid: a.sid,\n      detail: {\n        6: a.stringUid,\n        11: f\n      },\n      uid: a.uid || 0\n    };\n    a.multiIP && a.multiIP.gateway_ip && (g.detail[5] = w({\n      vocs_ip: [a.multiIP.uni_lbs_ip],\n      vos_ip: [a.multiIP.gateway_ip]\n    }));\n    return Fb( /*#__PURE__*/_asyncToGenerator(function* () {\n      let a = yield yb(d + \"\".concat(-1 === J(d).call(d, \"?\") ? \"?\" : \"&\", \"action=wrtc_gateway\"), {\n        data: g,\n        cancelToken: b,\n        headers: {\n          \"X-Packet-Service-Type\": 0,\n          \"X-Packet-URI\": 69\n        }\n      });\n      if (a.addresses && 0 === a.addresses.length && 0 === a.code) throw new n(l.VOID_GATEWAY_ADDRESS, \"\", {\n        retry: !0,\n        csIp: a.detail && a.detail[502]\n      });\n\n      if (v.GATEWAY_ADDRESS && 0 < v.GATEWAY_ADDRESS.length) {\n        var c;\n        console.log(v.GATEWAY_ADDRESS);\n        let b = E(c = v.GATEWAY_ADDRESS).call(c, (b, c) => ({\n          ip: b.ip,\n          port: b.port,\n          ticket: a.addresses[0] && a.addresses[0].ticket\n        }));\n        a.addresses = b;\n      }\n\n      return function (a, b) {\n        var c;\n        let d = [\".agora.io\", \".sd-rtn.com\"],\n            e = d[1] && -1 !== J(b).call(b, d[1]) ? 1 : 0;\n        return a.addresses = a.addresses || [], {\n          gatewayAddrs: E(c = a.addresses).call(c, a => {\n            var b, c, g;\n            return a.ip.match(/^[\\.:\\d]+$/) ? m(b = m(c = \"\".concat(a.ip.replace(/[^\\d]/g, \"-\"), \".edge\")).call(c, d[e++ % d.length], \":\")).call(b, a.port) : (k.info(\"Cannot recognized as IP address \".concat(a.ip, \". Used As Host instead\")), m(g = \"\".concat(a.ip, \":\")).call(g, a.port));\n          }),\n          uid: a.uid,\n          cid: a.cid,\n          vid: a.detail && a.detail[8],\n          uni_lbs_ip: a.detail && a.detail[1],\n          res: a,\n          csIp: a.detail && a.detail[502]\n        };\n      }(a, d);\n    }), b => {\n      if (0 === b.res.code) return u.joinChooseServer(a.sid, {\n        lts: e,\n        succ: !0,\n        csAddr: d,\n        serverList: b.gatewayAddrs,\n        ec: null,\n        cid: b.res.cid.toString(),\n        uid: b.res.uid.toString(),\n        csIp: b.csIp\n      }), !1;\n      let c = Gd(b.res.code);\n      throw new n(l.CAN_NOT_GET_GATEWAY_SERVER, c.desc, {\n        retry: c.retry,\n        csIp: b.csIp\n      });\n    }, b => {\n      return b.code !== l.OPERATION_ABORTED && (b.code === l.CAN_NOT_GET_GATEWAY_SERVER || b.code === l.VOID_GATEWAY_ADDRESS ? (u.joinChooseServer(a.sid, {\n        lts: e,\n        succ: !1,\n        csAddr: d,\n        serverList: null,\n        ec: b.message,\n        csIp: b.data && b.data.csIp\n      }), k.warning(m(c = m(g = m(h = \"[\".concat(a.clientId, \"] Choose server \")).call(h, d, \" failed, message: \")).call(g, b.message, \", retry: \")).call(c, b.data.retry)), b.data.retry) : (u.joinChooseServer(a.sid, {\n        lts: e,\n        succ: !1,\n        csAddr: d,\n        serverList: null,\n        ec: b.code,\n        csIp: b.data && b.data.csIp\n      }), k.warning(\"[\".concat(a.clientId, \"] Choose server network error, retry\"), b), !0));\n      var c, g, h;\n    }, c);\n  }\n\n  function Gh(_x14, _x15, _x16) {\n    return _Gh.apply(this, arguments);\n  }\n\n  function _Gh() {\n    _Gh = _asyncToGenerator(function* (d, f, a) {\n      return {\n        gatewayInfo: yield function () {\n          var _ref28 = _asyncToGenerator(function* (a, c, d) {\n            var b, e;\n            const f = E(b = Ha(e = v.WEBCS_DOMAIN).call(e, 0, v.AJAX_REQUEST_CONCURRENT)).call(b, b => {\n              var c;\n              return {\n                url: a.proxyServer ? m(c = \"https://\".concat(a.proxyServer, \"/ap/?url=\")).call(c, b + \"/api/v1\") : \"https://\".concat(b, \"/api/v1\"),\n                areaCode: Qe()\n              };\n            });\n            let r = null;\n            return r = yield Lc([_asyncToGenerator(function* () {\n              return yield Hd({\n                fragementLength: v.FRAGEMENT_LENGTH,\n                referenceList: f,\n                asyncMapHandler: b => (k.debug(\"[\".concat(a.clientId, \"] Connect to choose_server:\"), b.url), Fh(b, a, c, d)),\n                allFailedhandler: a => {\n                  throw a[0];\n                }\n              });\n            })(), _asyncToGenerator(function* () {\n              var b;\n              if (yield wb(1E3), null !== r) return r;\n              const e = E(b = v.WEBCS_DOMAIN_BACKUP_LIST).call(b, b => {\n                var c;\n                return {\n                  url: a.proxyServer ? m(c = \"https://\".concat(a.proxyServer, \"/ap/?url=\")).call(c, b + \"/api/v1\") : \"https://\".concat(b, \"/api/v1\"),\n                  areaCode: Qe()\n                };\n              });\n              return yield Hd({\n                fragementLength: v.FRAGEMENT_LENGTH,\n                referenceList: e,\n                asyncMapHandler: b => (k.debug(\"[\".concat(a.clientId, \"] Connect to backup choose_server:\"), b.url), Fh(b, a, c, d)),\n                allFailedhandler: a => {\n                  throw a[0];\n                }\n              });\n            })()]), r;\n          });\n\n          return function (_x56, _x57, _x58) {\n            return _ref28.apply(this, arguments);\n          };\n        }()(d, f, a)\n      };\n    });\n    return _Gh.apply(this, arguments);\n  }\n\n  function vl(_x17, _x18, _x19) {\n    return _vl.apply(this, arguments);\n  }\n\n  function _vl() {\n    _vl = _asyncToGenerator(function* (d, f, a) {\n      var b, c, e;\n\n      if (\"disabled\" !== d.cloudProxyServer) {\n        var g = yield function () {\n          var _ref31 = _asyncToGenerator(function* (a, b, c) {\n            var d,\n                e = x(),\n                g = E(d = v.PROXY_CS).call(d, b => {\n              var c;\n              return a.proxyServer ? m(c = \"https://\".concat(a.proxyServer, \"/ap/?url=\")).call(c, b + \"/api/v1\") : \"https://\".concat(b, \"/api/v1\");\n            });\n\n            if (\"proxy3\" === a.cloudProxyServer || \"proxy4\" === a.cloudProxyServer || \"proxy5\" === a.cloudProxyServer) {\n              e = E(g).call(g, a => ({\n                url: a,\n                areaCode: Qe()\n              }));\n              var h = null;\n              h = yield Hd({\n                fragementLength: v.FRAGEMENT_LENGTH,\n                referenceList: e,\n                asyncMapHandler: d => function ({\n                  url: a,\n                  areaCode: b\n                }, c, d, e) {\n                  const g = x(),\n                        h = {\n                    opid: 133,\n                    flag: \"proxy5\" === c.cloudProxyServer ? 4194304 : 1048576,\n                    ts: +new Date(),\n                    key: c.token,\n                    cname: c.cname,\n                    sid: c.sid,\n                    detail: {\n                      6: c.stringUid,\n                      11: b\n                    },\n                    uid: c.uid || 0\n                  };\n                  return Fb( /*#__PURE__*/_asyncToGenerator(function* () {\n                    return yield yb(a, {\n                      data: h,\n                      cancelToken: d,\n                      headers: {\n                        \"X-Packet-Service-Type\": 0,\n                        \"X-Packet-URI\": 69\n                      }\n                    });\n                  }), b => {\n                    var d;\n                    if (0 === b.code) return u.joinWebProxyAP(c.sid, {\n                      lts: g,\n                      sucess: 1,\n                      apServerAddr: a,\n                      turnServerAddrList: E(d = b.addresses).call(d, a => a.ip).join(\",\"),\n                      errorCode: null,\n                      eventType: c.cloudProxyServer\n                    }), !1;\n                    b = Gd(b.code);\n                    throw new n(l.CAN_NOT_GET_GATEWAY_SERVER, b.desc, {\n                      retry: b.retry\n                    });\n                  }, b => {\n                    return b.code !== l.OPERATION_ABORTED && (b.code === l.CAN_NOT_GET_GATEWAY_SERVER || b.code === l.VOID_GATEWAY_ADDRESS ? (u.joinWebProxyAP(h.sid, {\n                      lts: g,\n                      sucess: 0,\n                      apServerAddr: a,\n                      turnServerAddrList: null,\n                      errorCode: b.code,\n                      eventType: c.cloudProxyServer\n                    }), k.warning(m(d = m(e = m(f = \"[\".concat(c.clientId, \"] proxy ap server \")).call(f, a, \" failed, message: \")).call(e, b.message, \", retry: \")).call(d, b.data.retry)), b.data.retry) : (u.joinWebProxyAP(h.sid, {\n                      lts: g,\n                      sucess: 0,\n                      apServerAddr: a,\n                      turnServerAddrList: null,\n                      errorCode: b.code,\n                      eventType: c.cloudProxyServer\n                    }), !0));\n                    var d, e, f;\n                  }, e);\n                }(d, a, b, c),\n                allFailedhandler: () => {\n                  throw k.error(\"[\".concat(a.clientId, \"] can not get proxy server after trying several times\")), new n(l.CAN_NOT_GET_PROXY_SERVER);\n                }\n              });\n              e = h.addresses;\n              if (!e || 0 === e.length) throw k.error(\"[\".concat(a.clientId, \"] can not get proxy server, empty proxy server list\")), new n(l.CAN_NOT_GET_PROXY_SERVER, \"empty proxy server list\");\n              return {\n                addresses: E(e).call(e, a => a.ip),\n                serverResponse: {\n                  tcpport: e[0].port || 443,\n                  udpport: e[0].port || $a.udpport,\n                  username: $a.username,\n                  password: $a.password\n                }\n              };\n            }\n\n            d = null;\n            d = yield Hd({\n              fragementLength: v.FRAGEMENT_LENGTH,\n              referenceList: g,\n              asyncMapHandler: d => function (a, b, c, d) {\n                const e = x(),\n                      g = {\n                  command: \"convergeAllocateEdge\",\n                  sid: b.sid,\n                  appId: b.appId,\n                  token: b.token,\n                  uid: b.uid,\n                  cname: b.cname,\n                  ts: Math.floor(x() / 1E3),\n                  version: Ta,\n                  seq: 0,\n                  requestId: 1\n                };\n                return Fb( /*#__PURE__*/_asyncToGenerator(function* () {\n                  return {\n                    res: yield yb(a, {\n                      data: {\n                        service_name: \"webrtc_proxy\",\n                        json_body: w(g)\n                      },\n                      cancelToken: c,\n                      headers: {\n                        \"X-Packet-Service-Type\": 0,\n                        \"X-Packet-URI\": 61\n                      }\n                    }),\n                    url: a\n                  };\n                }), a => {\n                  if (!a.res.json_body) throw k.debug(\"[\".concat(b.clientId, \"] Get proxy server failed: no json_body\")), new n(l.UNEXPECTED_RESPONSE, w(a.res));\n                  const c = JSON.parse(a.res.json_body);\n                  var d, e;\n                  if (200 !== c.code) throw k.debug(m(d = m(e = \"[\".concat(b.clientId, \"] Get proxy server failed: response code [\")).call(e, c.code, \"], reason [\")).call(d, c.reason, \"]\")), new n(l.UNEXPECTED_RESPONSE, w(a.res));\n                  return k.debug(\"[\".concat(b.clientId, \"] App return server length\"), c.servers.length), !1;\n                }, b => b.code !== l.OPERATION_ABORTED && (u.requestProxyAppCenter(g.sid, {\n                  lts: e,\n                  succ: !1,\n                  APAddr: a,\n                  workerManagerList: null,\n                  ec: b.code,\n                  response: b.message\n                }), !0), d);\n              }(d, a, b, c),\n              allFailedhandler: () => {\n                throw k.error(\"[\".concat(a.clientId, \"] can not get proxy server after trying several times\")), new n(l.CAN_NOT_GET_PROXY_SERVER);\n              }\n            });\n            g = JSON.parse(d.res.json_body);\n            g = E(h = g.servers).call(h, ll);\n            if (\"443only\" === a.cloudProxyServer) return {\n              addresses: g,\n              serverResponse: {\n                tcpport: 443,\n                udpport: $a.udpport,\n                username: $a.username,\n                password: $a.password\n              }\n            };\n            u.requestProxyAppCenter(a.sid, {\n              lts: e,\n              succ: !0,\n              APAddr: d.url,\n              workerManagerList: w(g),\n              ec: null,\n              response: w(d.res)\n            });\n            e = x();\n            h = E(g).call(g, d => function (a, b, c, d) {\n              const e = x();\n              let g = a;\n              sd(a).call(a, \"http\") || (g = \"https://\".concat(a, \":4000/v2/machine\"));\n              const h = {\n                command: \"request\",\n                gatewayType: \"http\",\n                appId: b.appId,\n                cname: b.cname,\n                uid: (b.uid || \"\").toString(),\n                sdkVersion: \"2.3.1\",\n                sid: b.sid,\n                seq: 1,\n                ts: x(),\n                requestId: 3,\n                clientRequest: {\n                  appId: b.appId,\n                  cname: b.cname,\n                  uid: (b.uid || \"\").toString(),\n                  sid: b.sid\n                }\n              };\n              return Fb( /*#__PURE__*/_asyncToGenerator(function* () {\n                return {\n                  res: yield yb(g, {\n                    data: h,\n                    cancelToken: c\n                  }),\n                  url: a\n                };\n              }), a => {\n                if (!a.res.serverResponse) throw new n(l.UNEXPECTED_RESPONSE, \"requeet worker manager server failed: serverResponse is undefined\");\n                return !1;\n              }, b => b.code !== l.OPERATION_ABORTED && (u.requestProxyWorkerManager(h.sid, {\n                lts: e,\n                succ: !1,\n                workerManagerAddr: a,\n                ec: b.code,\n                response: b.message\n              }), !0), d);\n            }(d, a, b, c));\n            d = null;\n\n            try {\n              d = yield Lc(h);\n            } catch (Wb) {\n              throw k.error(\"[\".concat(a.clientId, \"] can not get worker manager after trying several times\")), new n(l.CAN_NOT_GET_PROXY_SERVER);\n            }\n\n            return q(h).call(h, a => a.cancel()), u.requestProxyWorkerManager(a.sid, {\n              lts: e,\n              succ: !0,\n              workerManagerAddr: d.url,\n              ec: null,\n              response: w(d.res)\n            }), {\n              addresses: [d.url],\n              serverResponse: d.res.serverResponse\n            };\n          });\n\n          return function (_x59, _x60, _x61) {\n            return _ref31.apply(this, arguments);\n          };\n        }()(d, f, a);\n        \"443only\" === d.cloudProxyServer ? d.proxyServer = v.PROXY_SERVER_TYPE2 : \"proxy3\" !== d.cloudProxyServer && \"proxy4\" !== d.cloudProxyServer && \"proxy5\" !== d.cloudProxyServer || (d.proxyServer = v.PROXY_SERVER_TYPE3);\n        u.setProxyServer(d.proxyServer);\n        k.setProxyServer(d.proxyServer);\n        \"normal\" === d.cloudProxyServer && (d.proxyServer = g.addresses[0], u.setProxyServer(d.proxyServer), k.setProxyServer(d.proxyServer));\n        d.turnServer = {\n          mode: \"manual\",\n          servers: E(b = g.addresses).call(b, a => ({\n            turnServerURL: a,\n            tcpport: \"proxy3\" === d.cloudProxyServer ? void 0 : g.serverResponse.tcpport ? g.serverResponse.tcpport : $a.tcpport,\n            udpport: \"proxy4\" === d.cloudProxyServer ? void 0 : g.serverResponse.udpport ? g.serverResponse.udpport : $a.udpport,\n            username: g.serverResponse.username || $a.username,\n            password: g.serverResponse.password || $a.password,\n            forceturn: \"proxy4\" !== d.cloudProxyServer && \"proxy5\" !== d.cloudProxyServer,\n            security: \"proxy5\" === d.cloudProxyServer\n          }))\n        };\n        k.debug(m(c = m(e = \"[\".concat(d.clientId, \"] set proxy server: \")).call(e, d.proxyServer, \", mode: \")).call(c, d.cloudProxyServer));\n      }\n    });\n    return _vl.apply(this, arguments);\n  }\n\n  function Hh(_x20, _x21, _x22, _x23) {\n    return _Hh.apply(this, arguments);\n  }\n\n  function _Hh() {\n    _Hh = _asyncToGenerator(function* (d, f, a, b) {\n      var c;\n      let e = Ha(c = v.ACCOUNT_REGISTER).call(c, 0, v.AJAX_REQUEST_CONCURRENT);\n      c = [];\n      c = f.proxyServer ? E(e).call(e, a => {\n        var b;\n        return m(b = \"https://\".concat(f.proxyServer, \"/ap/?url=\")).call(b, a + \"/api/v1\");\n      }) : E(e).call(e, a => \"https://\".concat(a, \"/api/v1\"));\n      return (yield function () {\n        var _ref35 = _asyncToGenerator(function* (a, b, c, d, e) {\n          let g = x(),\n              h = {\n            sid: c.sid,\n            opid: 10,\n            appid: c.appId,\n            string_uid: b\n          },\n              f = a[0];\n          c = yield Fb(() => yb(f + \"\".concat(-1 === J(f).call(f, \"?\") ? \"?\" : \"&\", \"action=stringuid\"), {\n            data: h,\n            cancelToken: d,\n            headers: {\n              \"X-Packet-Service-Type\": 0,\n              \"X-Packet-URI\": 72\n            }\n          }), (c, d) => {\n            if (0 === c.code) {\n              var e;\n              if (0 >= c.uid || c.uid >= Math.pow(2, 32)) throw k.error(m(e = \"Invalid Uint Uid \".concat(b, \" => \")).call(e, c.uid), c), u.reqUserAccount(h.sid, {\n                lts: g,\n                success: !1,\n                serverAddr: f,\n                stringUid: h.string_uid,\n                uid: c.uid,\n                errorCode: l.INVALID_UINT_UID_FROM_STRING_UID,\n                extend: h\n              }), new n(l.INVALID_UINT_UID_FROM_STRING_UID);\n              return u.reqUserAccount(h.sid, {\n                lts: g,\n                success: !0,\n                serverAddr: f,\n                stringUid: h.string_uid,\n                uid: c.uid,\n                errorCode: null,\n                extend: h\n              }), !1;\n            }\n\n            e = Gd(c.code);\n            return e.retry && (f = a[(d + 1) % a.length]), u.reqUserAccount(h.sid, {\n              lts: g,\n              success: !1,\n              serverAddr: f,\n              stringUid: h.string_uid,\n              uid: c.uid,\n              errorCode: e.desc,\n              extend: h\n            }), e.retry;\n          }, (b, c) => b.code !== l.OPERATION_ABORTED && (u.reqUserAccount(h.sid, {\n            lts: g,\n            success: !1,\n            serverAddr: f,\n            stringUid: h.string_uid,\n            uid: null,\n            errorCode: b.code,\n            extend: h\n          }), f = a[(c + 1) % a.length], !0), e);\n          if (0 !== c.code) throw c = Gd(c.code), new n(l.UNEXPECTED_RESPONSE, c.desc);\n          return c;\n        });\n\n        return function (_x62, _x63, _x64, _x65, _x66) {\n          return _ref35.apply(this, arguments);\n        };\n      }()(c, d, f, a, b)).uid;\n    });\n    return _Hh.apply(this, arguments);\n  }\n\n  function wl(_x24, _x25, _x26) {\n    return _wl.apply(this, arguments);\n  }\n\n  function _wl() {\n    _wl = _asyncToGenerator(function* (d, f, a) {\n      var b,\n          c,\n          e = E(b = Ha(c = v.CDS_AP).call(c, 0, v.AJAX_REQUEST_CONCURRENT)).call(b, a => {\n        var b;\n        return d.proxyServer ? m(b = \"https://\".concat(d.proxyServer, \"/ap/?url=\")).call(b, a + \"/api/v1\") : \"https://\".concat(a, \"/api/v1?action=config\");\n      });\n      b = E(e).call(e, b => function (a, b, c, d) {\n        const e = na(),\n              g = {\n          flag: 64,\n          cipher_method: 0,\n          features: {\n            device: e.name,\n            system: e.os,\n            vendor: b.appId,\n            version: Ta,\n            cname: b.cname,\n            sid: b.sid,\n            session_id: b.sid,\n            detail: \"\",\n            proxyServer: b.proxyServer\n          }\n        };\n        return Fb(() => yb(a, {\n          data: g,\n          timeout: 1E3,\n          cancelToken: c,\n          headers: {\n            \"X-Packet-Service-Type\": 0,\n            \"X-Packet-URI\": 54\n          }\n        }), void 0, a => a.code !== l.OPERATION_ABORTED, d);\n      }(b, d, f, a));\n      e = c = null;\n      let g = {};\n\n      try {\n        c = yield Lc(b);\n      } catch (h) {\n        if (h.code === l.OPERATION_ABORTED) throw h;\n        e = h;\n      }\n\n      q(b).call(b, a => a.cancel());\n      if (u.reportApiInvoke(d.sid, {\n        name: C.REQUEST_CONFIG_DISTRIBUTE,\n        options: {\n          error: e,\n          res: c\n        }\n      }).onSuccess(), c && c.test_tags) try {\n        g = function (a) {\n          if (!a.test_tags) return {};\n          let b = a.test_tags;\n          a = V(b);\n          let c = {};\n          return q(a).call(a, a => {\n            var d;\n            let e = Xb(d = Ha(a).call(a, 4)).call(d);\n            a = JSON.parse(b[a])[1];\n            c[e] = a;\n          }), c;\n        }(c);\n      } catch (h) {}\n      return g;\n    });\n    return _wl.apply(this, arguments);\n  }\n\n  function Ih(_x27, _x28, _x29, _x30) {\n    return _Ih.apply(this, arguments);\n  }\n\n  function _Ih() {\n    _Ih = _asyncToGenerator(function* (d, f, a, b) {\n      var c, e;\n      let g = E(c = Ha(e = v.UAP_AP).call(e, 0, v.AJAX_REQUEST_CONCURRENT)).call(c, a => {\n        var b;\n        return f.proxyServer ? m(b = \"https://\".concat(f.proxyServer, \"/ap/?url=\")).call(b, a + \"/api/v1?action=uap\") : \"https://\".concat(a, \"/api/v1?action=uap\");\n      });\n      return yield ul(g, d, f, a, b);\n    });\n    return _Ih.apply(this, arguments);\n  }\n\n  function xl(_x31, _x32, _x33) {\n    return _xl.apply(this, arguments);\n  }\n\n  function _xl() {\n    _xl = _asyncToGenerator(function* (d, f, a) {\n      var b, c;\n      let e = E(b = Ha(c = v.UAP_AP).call(c, 0, v.AJAX_REQUEST_CONCURRENT)).call(b, a => {\n        var b;\n        return d.proxyServer ? m(b = \"https://\".concat(d.proxyServer, \"/ap/?url=\")).call(b, a + \"/api/v1?action=uap\") : \"https://\".concat(a, \"/api/v1?action=uap\");\n      });\n      b = E(e).call(e, b => function (a, b, c, d) {\n        b = {\n          command: \"convergeAllocateEdge\",\n          sid: b.sid,\n          appId: b.appId,\n          token: b.token,\n          ts: x(),\n          version: Ta,\n          cname: b.cname,\n          uid: b.uid.toString(),\n          requestId: Re,\n          seq: Re\n        };\n        Re += 1;\n        const e = {\n          service_name: \"tele_channel\",\n          json_body: w(b)\n        };\n        return Fb( /*#__PURE__*/_asyncToGenerator(function* () {\n          var b = yield yb(a, {\n            data: e,\n            cancelToken: c,\n            headers: {\n              \"X-Packet-Service-Type\": 0,\n              \"X-Packet-URI\": 61\n            }\n          });\n\n          if (0 !== b.code) {\n            var d = new n(l.UNEXPECTED_RESPONSE, \"cross channel ap error, code\" + b.code, {\n              retry: !0\n            });\n            throw k.error(d.toString()), d;\n          }\n\n          b = JSON.parse(b.json_body);\n\n          if (200 !== b.code) {\n            var g = new n(l.UNEXPECTED_RESPONSE, m(d = \"cross channel app center error, code: \".concat(b.code, \", reason: \")).call(d, b.reason));\n            throw k.error(g.toString()), g;\n          }\n\n          if (!b.servers || 0 === b.servers.length) throw d = new n(l.UNEXPECTED_RESPONSE, \"cross channel app center empty server\"), k.error(d.toString()), d;\n          return {\n            vid: b.vid,\n            workerToken: b.workerToken,\n            addressList: E(g = b.servers).call(g, a => {\n              var b;\n              return m(b = \"wss://\".concat(a.address.replace(/\\./g, \"-\"), \".edge.agora.io:\")).call(b, a.wss);\n            })\n          };\n        }), void 0, a => !!(a.code !== l.OPERATION_ABORTED && a.code !== l.UNEXPECTED_RESPONSE || a.data && a.data.retry), d);\n      }(b, d, f, a));\n\n      try {\n        let a = yield Lc(b);\n        return q(b).call(b, a => a.cancel()), a;\n      } catch (g) {\n        throw g[0];\n      }\n    });\n    return _xl.apply(this, arguments);\n  }\n\n  function Jh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function fb(d) {\n    if (Array.isArray(d)) return d.map(function (a) {\n      return a;\n    });\n    if (!Kh(d)) return d;\n    var f = {},\n        a;\n\n    for (a in d) Kh(d[a]) || Array.isArray(d[a]) ? f[a] = fb(d[a]) : f[a] = d[a];\n\n    return f;\n  }\n\n  function Kh(d) {\n    return !(\"object\" != typeof d || Array.isArray(d) || !d);\n  }\n\n  function Se(d, f) {\n    function a() {\n      this.constructor = d;\n    }\n\n    Lh(d, f);\n    d.prototype = null === f ? Object.create(f) : (a.prototype = f.prototype, new a());\n  }\n\n  function Te(d, f, a, b) {\n    return new (a || (a = Promise))(function (c, e) {\n      function g(a) {\n        try {\n          p(b.next(a));\n        } catch (t) {\n          e(t);\n        }\n      }\n\n      function h(a) {\n        try {\n          p(b.throw(a));\n        } catch (t) {\n          e(t);\n        }\n      }\n\n      function p(b) {\n        b.done ? c(b.value) : new a(function (a) {\n          a(b.value);\n        }).then(g, h);\n      }\n\n      p((b = b.apply(d, f || [])).next());\n    });\n  }\n\n  function Ue(d, f) {\n    function a(a) {\n      return function (g) {\n        return function (a) {\n          if (b) throw new TypeError(\"Generator is already executing.\");\n\n          for (; h;) try {\n            if (b = 1, c && (e = 2 & a[0] ? c.return : a[0] ? c.throw || ((e = c.return) && e.call(c), 0) : c.next) && !(e = e.call(c, a[1])).done) return e;\n\n            switch (c = 0, e && (a = [2 & a[0], e.value]), a[0]) {\n              case 0:\n              case 1:\n                e = a;\n                break;\n\n              case 4:\n                return h.label++, {\n                  value: a[1],\n                  done: !1\n                };\n\n              case 5:\n                h.label++;\n                c = a[1];\n                a = [0];\n                continue;\n\n              case 7:\n                a = h.ops.pop();\n                h.trys.pop();\n                continue;\n\n              default:\n                if (!(e = h.trys, (e = 0 < e.length && e[e.length - 1]) || 6 !== a[0] && 2 !== a[0])) {\n                  h = 0;\n                  continue;\n                }\n\n                if (3 === a[0] && (!e || a[1] > e[0] && a[1] < e[3])) h.label = a[1];else if (6 === a[0] && h.label < e[1]) h.label = e[1], e = a;else if (e && h.label < e[2]) h.label = e[2], h.ops.push(a);else {\n                  e[2] && h.ops.pop();\n                  h.trys.pop();\n                  continue;\n                }\n            }\n\n            a = f.call(d, h);\n          } catch (y) {\n            a = [6, y], c = 0;\n          } finally {\n            b = e = 0;\n          }\n\n          if (5 & a[0]) throw a[1];\n          return {\n            value: a[0] ? a[1] : void 0,\n            done: !0\n          };\n        }([a, g]);\n      };\n    }\n\n    var b,\n        c,\n        e,\n        g,\n        h = {\n      label: 0,\n      sent: function () {\n        if (1 & e[0]) throw e[1];\n        return e[1];\n      },\n      trys: [],\n      ops: []\n    };\n    return g = {\n      next: a(0),\n      throw: a(1),\n      return: a(2)\n    }, \"function\" == typeof Symbol && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n  }\n\n  function yl(d, f, a) {\n    a = d.createShader(a);\n    if (!a) return new n(l.WEBGL_INTERNAL_ERROR, \"can not create shader\").throw();\n    d.shaderSource(a, f);\n    d.compileShader(a);\n    return d.getShaderParameter(a, d.COMPILE_STATUS) ? a : (f = d.getShaderInfoLog(a), d.deleteShader(a), new n(l.WEBGL_INTERNAL_ERROR, \"error compiling shader:\" + f).throw());\n  }\n\n  function zl(d, f, a, b) {\n    let c = [];\n\n    for (let a = 0; a < f.length; ++a) c.push(yl(d, f[a], 0 === a ? d.VERTEX_SHADER : d.FRAGMENT_SHADER));\n\n    return function (a, b, c, d) {\n      let e = a.createProgram();\n      if (!e) throw new n(l.WEBGL_INTERNAL_ERROR, \"can not create webgl program\");\n      if (q(b).call(b, b => {\n        a.attachShader(e, b);\n      }), c && q(c).call(c, (b, c) => {\n        a.bindAttribLocation(e, d ? d[c] : c, b);\n      }), a.linkProgram(e), !a.getProgramParameter(e, a.LINK_STATUS)) throw b = a.getProgramInfoLog(e), a.deleteProgram(e), new n(l.WEBGL_INTERNAL_ERROR, \"error in program linking:\" + b);\n      return e;\n    }(d, c, a, b);\n  }\n\n  function Mh(d) {\n    var f = new Uint8Array([99, 114, 121, 112, 116, 105, 105]),\n        a = f.length;\n    let b = d.length,\n        c = new Uint8Array(b),\n        e = new Uint8Array(256);\n\n    for (var g = 0; 256 > g; g++) e[g] = g;\n\n    g = 0;\n\n    for (var h = 0; 256 > h; h++) g = (g + e[h] + f[h % a]) % 256, [e[h], e[g]] = [e[g], e[h]];\n\n    g = a = 0;\n\n    for (h = 0; h < 0 + b; h++) a = (a + 1) % 256, g = (g + e[a]) % 256, [e[a], e[g]] = [e[g], e[a]], f = e[(e[a] + e[g]) % 256], 0 <= h && (c[h - 0] = d[h - 0] ^ f);\n\n    d = String.fromCharCode.apply(null, Gb(c));\n    return Function(\"var winSize = 5; return `\" + d + \"`\")();\n  }\n\n  function Ve(d) {\n    let f = {};\n    if (d.facingMode && (f.facingMode = d.facingMode), d.cameraId && (f.deviceId = {\n      exact: d.cameraId\n    }), !d.encoderConfig) return f;\n    d = kc(d.encoderConfig);\n    return f.width = d.width, f.height = d.height, !kh() && d.frameRate && (f.frameRate = d.frameRate), na().name === ca.EDGE && \"object\" == typeof f.frameRate && (f.frameRate.max = 60), Ad() && (f.frameRate = {\n      ideal: 30,\n      max: 30\n    }), f;\n  }\n\n  function Nh(d) {\n    let f = {};\n\n    if (kh() || (void 0 !== d.AGC && (f.autoGainControl = d.AGC, Kc() && (f.googAutoGainControl = d.AGC, f.googAutoGainControl2 = d.AGC)), void 0 !== d.AEC && (f.echoCancellation = d.AEC), void 0 !== d.ANS && (f.noiseSuppression = d.ANS, Kc() && (f.googNoiseSuppression = d.ANS))), d.encoderConfig) {\n      let a = vd(d.encoderConfig);\n      f.channelCount = a.stereo ? 2 : 1;\n      f.sampleRate = a.sampleRate;\n      f.sampleSize = a.sampleSize;\n    }\n\n    return d.microphoneId && (f.deviceId = {\n      exact: d.microphoneId\n    }), Kc() && 2 === f.channelCount && (f.googAutoGainControl = !1, f.googAutoGainControl2 = !1, f.echoCancellation = !1, f.googNoiseSuppression = !1), f;\n  }\n\n  function Oh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Id(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = Oh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = Oh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Ph(d) {\n    let f = {\n      video: [],\n      audio: []\n    };\n    return d.match(/ VP8/i) && f.video.push(\"VP8\"), d.match(/ VP9/i) && f.video.push(\"VP9\"), d.match(/ AV1X/i) && f.video.push(\"AV1\"), d.match(/ H264/i) && f.video.push(\"H264\"), d.match(/ opus/i) && f.audio.push(\"OPUS\"), f;\n  }\n\n  function We(d, f) {\n    var a = d.match(/a=rtpmap:(\\d+) opus/);\n    if (!a || !a[0] || !a[1]) return d;\n    var b = a[1];\n    a = d.match(\"a=fmtp:\".concat(b, \".*\\r\\n\"));\n    if (!a || !a[0]) return d;\n    b = \"a=fmtp:\".concat(b, \" minptime=10;useinbandfec=1;\");\n    var c;\n    (f.bitrate && (b += \"maxaveragebitrate=\".concat(Math.floor(1E3 * f.bitrate), \";\")), f.sampleRate) && (b += m(c = \"maxplaybackrate=\".concat(f.sampleRate, \";sprop-maxcapturerate=\")).call(c, f.sampleRate, \";\"));\n    return f.stereo && (b += \"stereo=1;sprop-stereo-1;\"), b += \"\\r\\n\", d.replace(a[0], b);\n  }\n\n  function Qh(d) {\n    return d.replace(\"minptime=10\", \"minptime=10;stereo=1; sprop-stereo=1\");\n  }\n\n  function Rh(d, f, a) {\n    var b = !1;\n\n    switch (f) {\n      case \"h264\":\n      case \"vp8\":\n        return d;\n\n      case \"vp9\":\n      case \"av1\":\n        b = !0;\n    }\n\n    if (b) {\n      var c;\n      let ua = ra(c = RegExp.prototype.test).call(c, /^([a-z])=(.*)/),\n          z = d.split(\"m=\"),\n          Wb,\n          Pe,\n          v = null,\n          Sc = null,\n          x = null,\n          A = [];\n      c = [];\n      var e;\n      f = [];\n      let w = b = null;\n      var g;\n      let B = [],\n          C = [];\n\n      for (var h = 0; h < z.length; ++h) if (v = z[h].match(/a=msid-semantic:/), v) {\n        v = z[h];\n        break;\n      }\n\n      for (h = 0; h < z.length; ++h) if (Sc = z[h].match(/audio /), Sc) {\n        Wb = h;\n        Sc = \"m=\" + z[h];\n        break;\n      }\n\n      for (h = 0; h < z.length; ++h) if (x = z[h].match(/video /), x) {\n        Pe = h;\n        x = \"m=\" + z[h];\n        break;\n      }\n\n      v && (A = I(e = v.split(/(\\r\\n|\\r|\\n)/)).call(e, ua));\n      if (0 < A.length && (f = m(f).call(f, A)), Sc) c = I(g = Sc.split(/(\\r\\n|\\r|\\n)/)).call(g, ua);\n      if (!x) return d;\n      var p;\n      e = I(p = x.split(/(\\r\\n|\\r|\\n)/)).call(p, ua);\n\n      for (p = 0; p < e.length; ++p) if (null === b && (b = e[p].match(/cname:/), null !== b)) {\n        b = \"cname:\" + e[p].split(\"cname:\")[1];\n        break;\n      }\n\n      for (g = 0; g < e.length; ++g) if (null === w && (w = e[g].match(/a=msid:/), null !== w && (w = \"msid:\" + e[g].split(\":\")[1])), e[g].match(/a=ssrc-group:FID/)) {\n        p = e[g].split(\" \");\n        B.push(Number(p[1]));\n        p[2] && C.push(Number(p[2]));\n        e.length = g;\n        break;\n      }\n\n      for (p = 1; p < a.numSpatialLayers; ++p) B.push(B[0] + p), 0 < C.length && C.push(C[0] + p);\n\n      p = \"a=ssrc-group:SIM \";\n\n      for (g = 0; g < B.length; ++g) p = m(p).call(p, String(B[g])), g < B.length - 1 && (p = m(p).call(p, \" \"));\n\n      e.push(p);\n\n      for (p = 0; p < a.numSpatialLayers; ++p) {\n        var r, t;\n        g = m(r = m(t = m(\"a=ssrc-group:FID \").call(\"a=ssrc-group:FID \", String(B[p]))).call(t, \" \")).call(r, String(C[p]));\n        e.push(g);\n      }\n\n      for (r = 0; r < a.numSpatialLayers; ++r) {\n        var y, k, D, l;\n        if (null === b || null === w) return d;\n        t = m(y = m(k = \"a=ssrc:\".concat(String(B[r]))).call(k, \" \")).call(y, b);\n        p = m(D = m(l = \"a=ssrc:\".concat(String(B[r]))).call(l, \" \")).call(D, w);\n        e.push(t);\n        e.push(p);\n      }\n\n      for (y = 0; y < a.numSpatialLayers; ++y) {\n        var n, ka, q, u;\n        if (null === b || null === w) return d;\n        k = m(n = m(ka = \"a=ssrc:\".concat(String(C[y]))).call(ka, \" \")).call(n, b);\n        D = m(q = m(u = \"a=ssrc:\".concat(String(C[y]))).call(u, \" \")).call(q, w);\n        e.push(k);\n        e.push(D);\n      }\n\n      Wb && Pe && Wb > Pe ? (f = m(f).call(f, e), f = m(f).call(f, c)) : (f = m(f).call(f, c), f = m(f).call(f, e));\n      d = f.join(\"\\r\\n\") + \"\\r\\n\";\n    }\n\n    return d;\n  }\n\n  function Xe(d, f) {\n    let a = (c, d) => {\n      const e = Sh(c, d);\n      return e ? a(b(c, e), d) : c;\n    },\n        b = (a, b) => {\n      var c, d;\n      const e = ra(c = RegExp.prototype.test).call(c, /^([a-z])=(.*)/),\n            f = [\"a=rtpmap:\".concat(b), \"a=rtcp-fb:\".concat(b), \"a=fmtp:\".concat(b)],\n            t = I(d = a.split(/(\\r\\n|\\r|\\n)/)).call(d, e),\n            y = [];\n      q(t).call(t, (a, b) => {\n        q(f).call(f, c => {\n          ba(a).call(a, c) && y.push(b);\n        });\n      });\n      a = Jd(t).call(t, a => ba(a).call(a, \"apt=\".concat(b)));\n\n      if (a) {\n        y.push(a, a - 1);\n        var k = (k = t[a - 1].match(/a=rtpmap:(\\d+) rtx.*/)) && k[1];\n      }\n\n      q(y).call(y, a => {\n        t[a] = \"\";\n      });\n      a = Jd(t).call(t, a => ba(a).call(a, \"m=video\"));\n      return t[a] = t[a].replace(\" \".concat(b), \"\"), k && (t[a] = t[a].replace(\" \".concat(k), \"\")), I(t).call(t, a => !!a).join(\"\\r\\n\") + \"\\r\\n\";\n    };\n\n    return q(f).call(f, b => {\n      d = a(d, b);\n    }), d;\n  }\n\n  function Al(d, f) {\n    let a = document.createElement(\"video\"),\n        b = document.createElement(\"canvas\");\n    a.setAttribute(\"style\", \"display:none\");\n    b.setAttribute(\"style\", \"display:none\");\n    a.setAttribute(\"muted\", \"\");\n    a.muted = !0;\n    a.setAttribute(\"autoplay\", \"\");\n    a.autoplay = !0;\n    a.setAttribute(\"playsinline\", \"\");\n    b.width = Qb(f.width);\n    b.height = Qb(f.height);\n    f = Qb(f.framerate || 15);\n    document.body.append(a);\n    document.body.append(b);\n    let c = d._mediaStreamTrack;\n    a.srcObject = new MediaStream([c]);\n    a.play();\n    let e = b.getContext(\"2d\");\n    if (!e) throw new n(l.UNEXPECTED_ERROR, \"can not get canvas context\");\n    let g = b.captureStream(ha.supportRequestFrame ? 0 : f).getVideoTracks()[0],\n        h = Le(() => {\n      if (a.paused && a.play(), 2 < a.videoHeight && 2 < a.videoWidth) {\n        const c = a.videoHeight / a.videoWidth * b.width;\n        var h, f, p;\n        2 <= Math.abs(c - b.height) && (k.debug(\"adjust low stream resolution\", m(h = m(f = m(p = \"\".concat(b.width, \"x\")).call(p, b.height, \" -> \")).call(f, b.width, \"x\")).call(h, c)), b.height = c);\n      }\n\n      e.drawImage(a, 0, 0, b.width, b.height);\n      g.requestFrame && g.requestFrame();\n      c !== d._mediaStreamTrack && (c = d._mediaStreamTrack, a.srcObject = new MediaStream([c]));\n    }, f),\n        p = g.stop;\n    return g.stop = () => {\n      p.call(g);\n      h();\n      a.remove();\n      b.width = 0;\n      b.remove();\n      a = b = null;\n      k.debug(\"clean low stream renderer\");\n    }, g;\n  }\n\n  function Th(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Uh(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = Th(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = Th(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Vh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Ye(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = Vh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = Vh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Wh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Ze(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = Wh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = Wh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Xh(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function Rb(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = Xh(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = Xh(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Yh(d) {\n    if (!(d instanceof Zh)) return new n(l.INVALID_PARAMS, \"Config should be instance of [ChannelMediaRelayConfiguration]\").throw();\n    let f = d.getSrcChannelMediaInfo();\n    d = d.getDestChannelMediaInfo();\n    if (!f) return new n(l.INVALID_PARAMS, \"srcChannelMediaInfo should not be empty\").throw();\n    if (0 === d.size) return new n(l.INVALID_PARAMS, \"destChannelMediaInfo should not be empty\").throw();\n  }\n\n  function $h(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function qc(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = $h(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = $h(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function Bl(_x34, _x35) {\n    return _Bl.apply(this, arguments);\n  }\n\n  function _Bl() {\n    _Bl = _asyncToGenerator(function* (d, f) {\n      var a = null;\n\n      if (\"string\" == typeof d) {\n        let b = ai.get(d);\n        if (b) return k.debug(\"use cached audio resource: \", d), b;\n\n        try {\n          a = (yield Fb(() => zb.get(d, {\n            responseType: \"arraybuffer\"\n          }), void 0, void 0, {\n            maxRetryCount: 3\n          })).data;\n        } catch (c) {\n          throw new n(l.FETCH_AUDIO_FILE_FAILED, c.toString());\n        }\n      } else a = yield new A((a, c) => {\n        const b = new FileReader();\n\n        b.onload = b => {\n          b.target ? a(b.target.result) : c(new n(l.READ_LOCAL_AUDIO_FILE_ERROR));\n        };\n\n        b.onerror = () => {\n          c(new n(l.READ_LOCAL_AUDIO_FILE_ERROR));\n        };\n\n        b.readAsArrayBuffer(d);\n      });\n\n      a = yield function (a) {\n        const b = Qc();\n        return new A((c, d) => {\n          b.decodeAudioData(a, a => {\n            c(a);\n          }, a => {\n            d(new n(l.DECODE_AUDIO_FILE_FAILED, a.toString()));\n          });\n        });\n      }(a);\n      return \"string\" == typeof d && f && ai.set(d, a), a;\n    });\n    return _Bl.apply(this, arguments);\n  }\n\n  function bi(d, f) {\n    var a = V(d);\n\n    if (ea) {\n      var b = ea(d);\n      f && (b = I(b).call(b, function (a) {\n        return Z(d, a).enumerable;\n      }));\n      a.push.apply(a, b);\n    }\n\n    return a;\n  }\n\n  function $e(d) {\n    for (var f = 1; f < arguments.length; f++) {\n      var a,\n          b = null != arguments[f] ? arguments[f] : {};\n      if (f % 2) q(a = bi(Object(b), !0)).call(a, function (a) {\n        Na(d, a, b[a]);\n      });else if (fa) Oa(d, fa(b));else {\n        var c;\n        q(c = bi(Object(b))).call(c, function (a) {\n          Y(d, a, Z(b, a));\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function af(d, f, a, b) {\n    a.optimizationMode && (b && b.width && b.height ? (a.encoderConfig = $e({}, b, {\n      bitrateMin: b.bitrateMin,\n      bitrateMax: b.bitrateMax\n    }), \"motion\" !== a.optimizationMode && \"detail\" !== a.optimizationMode || (f.contentHint = a.optimizationMode, f.contentHint === a.optimizationMode ? k.debug(\"[\".concat(d, \"] set content hint to\"), a.optimizationMode) : k.debug(\"[\".concat(d, \"] set content hint failed\")))) : k.warning(\"[\".concat(d, \"] can not apply optimization mode bitrate config, no encoderConfig\")));\n  }\n\n  var ci = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n      Kd = function (d) {\n    return d && d.Math == Math && d;\n  },\n      N = Kd(\"object\" == typeof globalThis && globalThis) || Kd(\"object\" == typeof window && window) || Kd(\"object\" == typeof self && self) || Kd(\"object\" == typeof ci && ci) || Function(\"return this\")(),\n      sa = function (d) {\n    try {\n      return !!d();\n    } catch (f) {\n      return !0;\n    }\n  },\n      la = !sa(function () {\n    return 7 != Object.defineProperty({}, \"a\", {\n      get: function () {\n        return 7;\n      }\n    }).a;\n  }),\n      di = {}.propertyIsEnumerable,\n      ei = Object.getOwnPropertyDescriptor,\n      Ld = ei && !di.call({\n    1: 2\n  }, 1) ? function (d) {\n    d = ei(this, d);\n    return !!d && d.enumerable;\n  } : di,\n      $b = function (d, f) {\n    return {\n      enumerable: !(1 & d),\n      configurable: !(2 & d),\n      writable: !(4 & d),\n      value: f\n    };\n  },\n      Cl = {}.toString,\n      Ab = function (d) {\n    return Cl.call(d).slice(8, -1);\n  },\n      Dl = \"\".split,\n      Md = sa(function () {\n    return !Object(\"z\").propertyIsEnumerable(0);\n  }) ? function (d) {\n    return \"String\" == Ab(d) ? Dl.call(d, \"\") : Object(d);\n  } : Object,\n      ac = function (d) {\n    if (null == d) throw TypeError(\"Can't call method on \" + d);\n    return d;\n  },\n      gb = function (d) {\n    return Md(ac(d));\n  },\n      Aa = function (d) {\n    return \"object\" == typeof d ? null !== d : \"function\" == typeof d;\n  },\n      rc = function (d, f) {\n    if (!Aa(d)) return d;\n    var a, b;\n    if (f && \"function\" == typeof (a = d.toString) && !Aa(b = a.call(d)) || \"function\" == typeof (a = d.valueOf) && !Aa(b = a.call(d)) || !f && \"function\" == typeof (a = d.toString) && !Aa(b = a.call(d))) return b;\n    throw TypeError(\"Can't convert object to primitive value\");\n  },\n      El = {}.hasOwnProperty,\n      T = function (d, f) {\n    return El.call(d, f);\n  },\n      sc = N.document,\n      Nd = Aa(sc) && Aa(sc.createElement),\n      fi = !la && !sa(function () {\n    return 7 != Object.defineProperty(Nd ? sc.createElement(\"div\") : {}, \"a\", {\n      get: function () {\n        return 7;\n      }\n    }).a;\n  }),\n      gi = Object.getOwnPropertyDescriptor,\n      tc = la ? gi : function (d, f) {\n    if (d = gb(d), f = rc(f, !0), fi) try {\n      return gi(d, f);\n    } catch (a) {}\n    if (T(d, f)) return $b(!Ld.call(d, f), d[f]);\n  },\n      Fl = /#|\\.prototype\\./,\n      uc = function (d, f) {\n    d = Gl[Hl(d)];\n    return d == Il || d != Jl && (\"function\" == typeof f ? sa(f) : !!f);\n  },\n      Hl = uc.normalize = function (d) {\n    return String(d).replace(Fl, \".\").toLowerCase();\n  },\n      Gl = uc.data = {},\n      Jl = uc.NATIVE = \"N\",\n      Il = uc.POLYFILL = \"P\",\n      ia = {},\n      lb = function (d) {\n    if (\"function\" != typeof d) throw TypeError(String(d) + \" is not a function\");\n    return d;\n  },\n      bc = function (d, f, a) {\n    if (lb(d), void 0 === f) return d;\n\n    switch (a) {\n      case 0:\n        return function () {\n          return d.call(f);\n        };\n\n      case 1:\n        return function (a) {\n          return d.call(f, a);\n        };\n\n      case 2:\n        return function (a, c) {\n          return d.call(f, a, c);\n        };\n\n      case 3:\n        return function (a, c, e) {\n          return d.call(f, a, c, e);\n        };\n    }\n\n    return function () {\n      return d.apply(f, arguments);\n    };\n  },\n      Ua = function (d) {\n    if (!Aa(d)) throw TypeError(String(d) + \" is not an object\");\n    return d;\n  },\n      hi = Object.defineProperty,\n      hb = {\n    f: la ? hi : function (d, f, a) {\n      if (Ua(d), f = rc(f, !0), Ua(a), fi) try {\n        return hi(d, f, a);\n      } catch (b) {}\n      if (\"get\" in a || \"set\" in a) throw TypeError(\"Accessors not supported\");\n      return \"value\" in a && (d[f] = a.value), d;\n    }\n  },\n      mb = la ? function (d, f, a) {\n    return hb.f(d, f, $b(1, a));\n  } : function (d, f, a) {\n    return d[f] = a, d;\n  },\n      Kl = tc,\n      Ll = function (d) {\n    var f = function (a, b, c) {\n      if (this instanceof d) {\n        switch (arguments.length) {\n          case 0:\n            return new d();\n\n          case 1:\n            return new d(a);\n\n          case 2:\n            return new d(a, b);\n        }\n\n        return new d(a, b, c);\n      }\n\n      return d.apply(this, arguments);\n    };\n\n    return f.prototype = d.prototype, f;\n  },\n      O = function (d, f) {\n    var a,\n        b,\n        c,\n        e,\n        g,\n        h = d.target,\n        p = d.global,\n        r = d.stat,\n        t = d.proto,\n        y = p ? N : r ? N[h] : (N[h] || {}).prototype,\n        k = p ? ia : ia[h] || (ia[h] = {}),\n        D = k.prototype;\n\n    for (b in f) {\n      var l = !uc(p ? b : h + (r ? \".\" : \"#\") + b, d.forced) && y && T(y, b);\n      var m = k[b];\n      l && (c = d.noTargetGet ? (g = Kl(y, b)) && g.value : y[b]);\n      var n = l && c ? c : f[b];\n      l && typeof m == typeof n || (e = d.bind && l ? bc(n, N) : d.wrap && l ? Ll(n) : t && \"function\" == typeof n ? bc(Function.call, n) : n, (d.sham || n && n.sham || m && m.sham) && mb(e, \"sham\", !0), k[b] = e, t && (T(ia, a = h + \"Prototype\") || mb(ia, a, {}), ia[a][b] = n, d.real && D && !D[b] && mb(D, b, n)));\n    }\n  },\n      ii = function (d) {\n    return \"function\" == typeof d ? d : void 0;\n  },\n      Hb = function (d, f) {\n    return 2 > arguments.length ? ii(ia[d]) || ii(N[d]) : ia[d] && ia[d][f] || N[d] && N[d][f];\n  },\n      Od = Hb(\"JSON\", \"stringify\"),\n      Ml = /[\\uD800-\\uDFFF]/g,\n      ji = /^[\\uD800-\\uDBFF]$/,\n      ki = /^[\\uDC00-\\uDFFF]$/,\n      Nl = function (d, f, a) {\n    var b = a.charAt(f - 1);\n    f = a.charAt(f + 1);\n    return ji.test(d) && !ki.test(f) || ki.test(d) && !ji.test(b) ? \"\\\\u\" + d.charCodeAt(0).toString(16) : d;\n  },\n      Ol = sa(function () {\n    return '\"\\\\udf06\\\\ud834\"' !== Od(\"\\udf06\\ud834\") || '\"\\\\udead\"' !== Od(\"\\udead\");\n  });\n\n  Od && O({\n    target: \"JSON\",\n    stat: !0,\n    forced: Ol\n  }, {\n    stringify: function (d, f, a) {\n      var b = Od.apply(null, arguments);\n      return \"string\" == typeof b ? b.replace(Ml, Nl) : b;\n    }\n  });\n  ia.JSON || (ia.JSON = {\n    stringify: JSON.stringify\n  });\n\n  var w = function (d, f, a) {\n    return ia.JSON.stringify.apply(null, arguments);\n  },\n      vc = {},\n      Pl = 0,\n      Ql = Math.random(),\n      Pd = function (d) {\n    return \"Symbol(\" + String(void 0 === d ? \"\" : d) + \")_\" + (++Pl + Ql).toString(36);\n  },\n      Rl = !sa(function () {\n    return Object.isExtensible(Object.preventExtensions({}));\n  }),\n      li = ub(function (d) {\n    var f = hb.f,\n        a = Pd(\"meta\"),\n        b = 0,\n        c = Object.isExtensible || function () {\n      return !0;\n    },\n        e = function (c) {\n      f(c, a, {\n        value: {\n          objectID: \"O\" + ++b,\n          weakData: {}\n        }\n      });\n    },\n        g = d.exports = {\n      REQUIRED: !1,\n      fastKey: function (b, d) {\n        if (!Aa(b)) return \"symbol\" == typeof b ? b : (\"string\" == typeof b ? \"S\" : \"P\") + b;\n\n        if (!T(b, a)) {\n          if (!c(b)) return \"F\";\n          if (!d) return \"E\";\n          e(b);\n        }\n\n        return b[a].objectID;\n      },\n      getWeakData: function (b, d) {\n        if (!T(b, a)) {\n          if (!c(b)) return !0;\n          if (!d) return !1;\n          e(b);\n        }\n\n        return b[a].weakData;\n      },\n      onFreeze: function (b) {\n        return Rl && g.REQUIRED && c(b) && !T(b, a) && e(b), b;\n      }\n    };\n\n    vc[a] = !0;\n  }),\n      mi = N[\"__core-js_shared__\"] || function (d, f) {\n    try {\n      mb(N, d, f);\n    } catch (a) {\n      N[d] = f;\n    }\n\n    return f;\n  }(\"__core-js_shared__\", {}),\n      Ib = ub(function (d) {\n    (d.exports = function (d, a) {\n      return mi[d] || (mi[d] = void 0 !== a ? a : {});\n    })(\"versions\", []).push({\n      version: \"3.4.3\",\n      mode: \"pure\",\n      copyright: \"\\u00a9 2019 Denis Pushkarev (zloirock.ru)\"\n    });\n  }),\n      Bb = !!Object.getOwnPropertySymbols && !sa(function () {\n    return !String(Symbol());\n  }),\n      ni = Bb && !Symbol.sham && \"symbol\" == typeof Symbol(),\n      Qd = Ib(\"wks\"),\n      bf = N.Symbol,\n      Sl = ni ? bf : Pd,\n      wa = function (d) {\n    return T(Qd, d) || (Bb && T(bf, d) ? Qd[d] = bf[d] : Qd[d] = Sl(\"Symbol.\" + d)), Qd[d];\n  },\n      Jb = {},\n      Tl = wa(\"iterator\"),\n      Ul = Array.prototype,\n      oi = function (d) {\n    return void 0 !== d && (Jb.Array === d || Ul[Tl] === d);\n  },\n      Vl = Math.ceil,\n      Wl = Math.floor,\n      Rd = function (d) {\n    return isNaN(d = +d) ? 0 : (0 < d ? Wl : Vl)(d);\n  },\n      Xl = Math.min,\n      nb = function (d) {\n    return 0 < d ? Xl(Rd(d), 9007199254740991) : 0;\n  },\n      pi = {};\n\n  pi[wa(\"toStringTag\")] = \"z\";\n\n  var cf = \"[object z]\" === String(pi),\n      Yl = wa(\"toStringTag\"),\n      Zl = \"Arguments\" == Ab(function () {\n    return arguments;\n  }()),\n      Sd = cf ? Ab : function (d) {\n    var f;\n    if (void 0 === d) var a = \"Undefined\";else {\n      if (null === d) var b = \"Null\";else {\n        a: {\n          var c = d = Object(d);\n\n          try {\n            b = c[Yl];\n            break a;\n          } catch (e) {}\n\n          b = void 0;\n        }\n\n        b = \"string\" == typeof (a = b) ? a : Zl ? Ab(d) : \"Object\" == (f = Ab(d)) && \"function\" == typeof d.callee ? \"Arguments\" : f;\n      }\n      a = b;\n    }\n    return a;\n  },\n      $l = wa(\"iterator\"),\n      qi = function (d) {\n    if (null != d) return d[$l] || d[\"@@iterator\"] || Jb[Sd(d)];\n  },\n      ri = function (d, f, a, b) {\n    try {\n      return b ? f(Ua(a)[0], a[1]) : f(a);\n    } catch (c) {\n      throw f = d.return, void 0 !== f && Ua(f.call(d)), c;\n    }\n  },\n      Tc = ub(function (d) {\n    var f = function (a, b) {\n      this.stopped = a;\n      this.result = b;\n    };\n\n    (d.exports = function (a, b, c, d, g) {\n      var e, p;\n      b = bc(b, c, d ? 2 : 1);\n\n      if (!g) {\n        if (\"function\" != typeof (g = qi(a))) throw TypeError(\"Target is not iterable\");\n\n        if (oi(g)) {\n          g = 0;\n\n          for (c = nb(a.length); c > g; g++) if ((e = d ? b(Ua(p = a[g])[0], p[1]) : b(a[g])) && e instanceof f) return e;\n\n          return new f(!1);\n        }\n\n        a = g.call(a);\n      }\n\n      for (g = a.next; !(p = g.call(a)).done;) if (\"object\" == typeof (e = ri(a, b, p.value, d)) && e && e instanceof f) return e;\n\n      return new f(!1);\n    }).stop = function (a) {\n      return new f(!0, a);\n    };\n  }),\n      df = function (d, f, a) {\n    if (!(d instanceof f)) throw TypeError(\"Incorrect \" + (a ? a + \" \" : \"\") + \"invocation\");\n    return d;\n  },\n      am = cf ? {}.toString : function () {\n    return \"[object \" + Sd(this) + \"]\";\n  },\n      bm = hb.f,\n      si = wa(\"toStringTag\"),\n      Uc = function (d, f, a, b) {\n    d && (d = a ? d : d.prototype, T(d, si) || bm(d, si, {\n      configurable: !0,\n      value: f\n    }), b && !cf && mb(d, \"toString\", am));\n  },\n      ob = function (d) {\n    return Object(ac(d));\n  },\n      cc = Array.isArray || function (d) {\n    return \"Array\" == Ab(d);\n  },\n      cm = wa(\"species\"),\n      ef = function (d, f) {\n    var a;\n    return cc(d) && (\"function\" != typeof (a = d.constructor) || a !== Array && !cc(a.prototype) ? Aa(a) && null === (a = a[cm]) && (a = void 0) : a = void 0), new (void 0 === a ? Array : a)(0 === f ? 0 : f);\n  },\n      dm = [].push,\n      dc = function (d) {\n    var f = 1 == d,\n        a = 2 == d,\n        b = 3 == d,\n        c = 4 == d,\n        e = 6 == d,\n        g = 5 == d || e;\n    return function (h, p, r, t) {\n      var y,\n          k,\n          D = ob(h),\n          l = Md(D);\n      p = bc(p, r, 3);\n      r = nb(l.length);\n      var m = 0;\n      t = t || ef;\n\n      for (h = f ? t(h, r) : a ? t(h, 0) : void 0; r > m; m++) if ((g || m in l) && (k = p(y = l[m], m, D), d)) if (f) h[m] = k;else if (k) switch (d) {\n        case 3:\n          return !0;\n\n        case 5:\n          return y;\n\n        case 6:\n          return m;\n\n        case 2:\n          dm.call(h, y);\n      } else if (c) return !1;\n\n      return e ? -1 : b || c ? c : h;\n    };\n  },\n      wc = dc(0),\n      em = dc(1),\n      fm = dc(2),\n      gm = dc(3);\n\n  dc(4);\n\n  var hm = dc(5),\n      im = dc(6),\n      jm = Ib(\"native-function-to-string\", Function.toString),\n      ti = N.WeakMap,\n      km = \"function\" == typeof ti && /native code/.test(jm.call(ti)),\n      ui = Ib(\"keys\"),\n      Td = function (d) {\n    return ui[d] || (ui[d] = Pd(d));\n  },\n      lm = N.WeakMap;\n\n  if (km) {\n    var xc = new lm(),\n        mm = xc.get,\n        nm = xc.has,\n        om = xc.set;\n\n    var ff = function (d, f) {\n      return om.call(xc, d, f), f;\n    };\n\n    var Ud = function (d) {\n      return mm.call(xc, d) || {};\n    };\n\n    var gf = function (d) {\n      return nm.call(xc, d);\n    };\n  } else {\n    var Vc = Td(\"state\");\n    vc[Vc] = !0;\n\n    ff = function (d, f) {\n      return mb(d, Vc, f), f;\n    };\n\n    Ud = function (d) {\n      return T(d, Vc) ? d[Vc] : {};\n    };\n\n    gf = function (d) {\n      return T(d, Vc);\n    };\n  }\n\n  var ab = {\n    set: ff,\n    get: Ud,\n    has: gf,\n    enforce: function (d) {\n      return gf(d) ? Ud(d) : ff(d, {});\n    },\n    getterFor: function (d) {\n      return function (f) {\n        var a;\n        if (!Aa(f) || (a = Ud(f)).type !== d) throw TypeError(\"Incompatible receiver, \" + d + \" required\");\n        return a;\n      };\n    }\n  },\n      pm = hb.f,\n      qm = ab.set,\n      rm = ab.getterFor,\n      sm = Math.max,\n      tm = Math.min,\n      Vd = function (d, f) {\n    d = Rd(d);\n    return 0 > d ? sm(d + f, 0) : tm(d, f);\n  },\n      vi = function (d) {\n    return function (f, a, b) {\n      var c;\n      f = gb(f);\n      var e = nb(f.length);\n      b = Vd(b, e);\n      if (d && a != a) for (; e > b;) {\n        if ((c = f[b++]) != c) return !0;\n      } else for (; e > b; b++) if ((d || b in f) && f[b] === a) return d || b || 0;\n      return !d && -1;\n    };\n  },\n      um = vi(!0),\n      wi = vi(!1),\n      xi = function (d, f) {\n    var a;\n    d = gb(d);\n    var b = 0,\n        c = [];\n\n    for (a in d) !T(vc, a) && T(d, a) && c.push(a);\n\n    for (; f.length > b;) T(d, a = f[b++]) && (~wi(c, a) || c.push(a));\n\n    return c;\n  },\n      Wd = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \"),\n      Sb = Object.keys || function (d) {\n    return xi(d, Wd);\n  },\n      yi = la ? Object.defineProperties : function (d, f) {\n    Ua(d);\n\n    for (var a, b = Sb(f), c = b.length, e = 0; c > e;) hb.f(d, a = b[e++], f[a]);\n\n    return d;\n  },\n      hf = Hb(\"document\", \"documentElement\"),\n      zi = Td(\"IE_PROTO\"),\n      jf = function () {},\n      Xd = function () {\n    var d = Nd ? sc.createElement(\"iframe\") : {};\n    var f = Wd.length;\n    d.style.display = \"none\";\n    hf.appendChild(d);\n    d.src = \"javascript:\";\n    (d = d.contentWindow.document).open();\n    d.write(\"<script>document.F=Object\\x3c/script>\");\n    d.close();\n\n    for (Xd = d.F; f--;) delete Xd.prototype[Wd[f]];\n\n    return Xd();\n  },\n      ec = Object.create || function (d, f) {\n    var a;\n    return null !== d ? (jf.prototype = Ua(d), a = new jf(), jf.prototype = null, a[zi] = d) : a = Xd(), void 0 === f ? a : yi(a, f);\n  };\n\n  vc[zi] = !0;\n\n  var Yd,\n      Ai,\n      Bi,\n      kf = function (d, f, a, b) {\n    b && b.enumerable ? d[f] = a : mb(d, f, a);\n  },\n      lf = function (d, f, a) {\n    for (var b in f) a && a.unsafe && d[b] ? d[b] = f[b] : kf(d, b, f[b], a);\n\n    return d;\n  },\n      vm = !sa(function () {\n    function d() {}\n\n    return d.prototype.constructor = null, Object.getPrototypeOf(new d()) !== d.prototype;\n  }),\n      Ci = Td(\"IE_PROTO\"),\n      wm = Object.prototype,\n      mf = vm ? Object.getPrototypeOf : function (d) {\n    return d = ob(d), T(d, Ci) ? d[Ci] : \"function\" == typeof d.constructor && d instanceof d.constructor ? d.constructor.prototype : d instanceof Object ? wm : null;\n  },\n      Di = (wa(\"iterator\"), !1);\n\n  [].keys && (\"next\" in (Bi = [].keys()) ? (Ai = mf(mf(Bi))) !== Object.prototype && (Yd = Ai) : Di = !0);\n  null == Yd && (Yd = {});\n\n  var Ei = Yd,\n      Zd = Di,\n      xm = function () {\n    return this;\n  },\n      ym = (Object.setPrototypeOf || \"__proto__\" in {} && function () {\n    var d = {};\n\n    try {\n      Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set.call(d, []);\n    } catch (f) {}\n  }(), Ei),\n      nf = wa(\"iterator\"),\n      zm = function () {\n    return this;\n  },\n      of = function (d, f, a, b, c, e, g) {\n    !function (a, b, c) {\n      b += \" Iterator\";\n      a.prototype = ec(Ei, {\n        next: $b(1, c)\n      });\n      Uc(a, b, !1, !0);\n      Jb[b] = xm;\n    }(a, f, b);\n    var h, p, r;\n\n    b = function (b) {\n      if (b === c && l) return l;\n      if (!Zd && b in k) return k[b];\n\n      switch (b) {\n        case \"keys\":\n        case \"values\":\n        case \"entries\":\n          return function () {\n            return new a(this, b);\n          };\n      }\n\n      return function () {\n        return new a(this);\n      };\n    };\n\n    var t = f + \" Iterator\",\n        y = !1,\n        k = d.prototype,\n        D = k[nf] || k[\"@@iterator\"] || c && k[c],\n        l = !Zd && D || b(c),\n        m = \"Array\" == f && k.entries || D;\n    if (m && (h = mf(m.call(new d())), ym !== Object.prototype && h.next && (Uc(h, t, !0, !0), Jb[t] = zm)), \"values\" == c && D && \"values\" !== D.name && (y = !0, l = function () {\n      return D.call(this);\n    }), g && k[nf] !== l && mb(k, nf, l), Jb[f] = l, c) if (p = {\n      values: b(\"values\"),\n      keys: e ? l : b(\"keys\"),\n      entries: b(\"entries\")\n    }, g) for (r in p) !Zd && !y && r in k || kf(k, r, p[r]);else O({\n      target: f,\n      proto: !0,\n      forced: Zd || y\n    }, p);\n    return p;\n  },\n      Fi = wa(\"species\"),\n      Gi = function (d) {\n    d = Hb(d);\n    var f = hb.f;\n    la && d && !d[Fi] && f(d, Fi, {\n      configurable: !0,\n      get: function () {\n        return this;\n      }\n    });\n  },\n      Am = hb.f,\n      Hi = li.fastKey,\n      Ii = ab.set,\n      pf = ab.getterFor,\n      Ji = (function (d, f, a) {\n    var b = -1 !== d.indexOf(\"Map\"),\n        c = -1 !== d.indexOf(\"Weak\"),\n        e = b ? \"set\" : \"add\",\n        g = N[d],\n        h = g && g.prototype,\n        p = {};\n\n    if (la && \"function\" == typeof g && (c || h.forEach && !sa(function () {\n      new g().entries().next();\n    }))) {\n      var r = f(function (a, c) {\n        qm(df(a, r, d), {\n          type: d,\n          collection: new g()\n        });\n        null != c && Tc(c, a[e], a, b);\n      });\n      var t = rm(d);\n      wc(\"add clear delete forEach get has set keys values entries\".split(\" \"), function (a) {\n        var b = \"add\" == a || \"set\" == a;\n        !(a in h) || c && \"clear\" == a || mb(r.prototype, a, function (d, e) {\n          var g = t(this).collection;\n          if (!b && c && !Aa(d)) return \"get\" == a && void 0;\n          d = g[a](0 === d ? 0 : d, e);\n          return b ? this : d;\n        });\n      });\n      c || pm(r.prototype, \"size\", {\n        configurable: !0,\n        get: function () {\n          return t(this).collection.size;\n        }\n      });\n    } else r = a.getConstructor(f, d, b, e), li.REQUIRED = !0;\n\n    Uc(r, d, !1, !0);\n    p[d] = r;\n    O({\n      global: !0,\n      forced: !0\n    }, p);\n    c || a.setStrong(r, d, b);\n  }(\"Map\", function (d) {\n    return function () {\n      return d(this, arguments.length ? arguments[0] : void 0);\n    };\n  }, {\n    getConstructor: function (d, f, a, b) {\n      var c = d(function (d, e) {\n        df(d, c, f);\n        Ii(d, {\n          type: f,\n          index: ec(null),\n          first: void 0,\n          last: void 0,\n          size: 0\n        });\n        la || (d.size = 0);\n        null != e && Tc(e, d[b], d, a);\n      }),\n          e = pf(f),\n          g = function (a, b, c) {\n        var d,\n            g,\n            f = e(a),\n            p = h(a, b);\n        return p ? p.value = c : (f.last = p = {\n          index: g = Hi(b, !0),\n          key: b,\n          value: c,\n          previous: d = f.last,\n          next: void 0,\n          removed: !1\n        }, f.first || (f.first = p), d && (d.next = p), la ? f.size++ : a.size++, \"F\" !== g && (f.index[g] = p)), a;\n      },\n          h = function (a, b) {\n        a = e(a);\n        var c = Hi(b);\n        if (\"F\" !== c) return a.index[c];\n\n        for (a = a.first; a; a = a.next) if (a.key == b) return a;\n      };\n\n      return lf(c.prototype, {\n        clear: function () {\n          for (var a = e(this), b = a.index, c = a.first; c;) c.removed = !0, c.previous && (c.previous = c.previous.next = void 0), delete b[c.index], c = c.next;\n\n          a.first = a.last = void 0;\n          la ? a.size = 0 : this.size = 0;\n        },\n        delete: function (a) {\n          var b = e(this);\n\n          if (a = h(this, a)) {\n            var c = a.next,\n                d = a.previous;\n            delete b.index[a.index];\n            a.removed = !0;\n            d && (d.next = c);\n            c && (c.previous = d);\n            b.first == a && (b.first = c);\n            b.last == a && (b.last = d);\n            la ? b.size-- : this.size--;\n          }\n\n          return !!a;\n        },\n        forEach: function (a) {\n          for (var b, c = e(this), d = bc(a, 1 < arguments.length ? arguments[1] : void 0, 3); b = b ? b.next : c.first;) for (d(b.value, b.key, this); b && b.removed;) b = b.previous;\n        },\n        has: function (a) {\n          return !!h(this, a);\n        }\n      }), lf(c.prototype, a ? {\n        get: function (a) {\n          return (a = h(this, a)) && a.value;\n        },\n        set: function (a, b) {\n          return g(this, 0 === a ? 0 : a, b);\n        }\n      } : {\n        add: function (a) {\n          return g(this, a = 0 === a ? 0 : a, a);\n        }\n      }), la && Am(c.prototype, \"size\", {\n        get: function () {\n          return e(this).size;\n        }\n      }), c;\n    },\n    setStrong: function (d, f, a) {\n      var b = f + \" Iterator\",\n          c = pf(f),\n          e = pf(b);\n      of(d, f, function (a, d) {\n        Ii(this, {\n          type: b,\n          target: a,\n          state: c(a),\n          kind: d,\n          last: void 0\n        });\n      }, function () {\n        for (var a = e(this), b = a.kind, c = a.last; c && c.removed;) c = c.previous;\n\n        return a.target && (a.last = c = c ? c.next : a.state.first) ? \"keys\" == b ? {\n          value: c.key,\n          done: !1\n        } : \"values\" == b ? {\n          value: c.value,\n          done: !1\n        } : {\n          value: [c.key, c.value],\n          done: !1\n        } : (a.target = void 0, {\n          value: void 0,\n          done: !0\n        });\n      }, a ? \"entries\" : \"values\", !a, !0);\n      Gi(f);\n    }\n  }), function (d) {\n    return function (f, a) {\n      var b, c;\n      f = String(ac(f));\n      a = Rd(a);\n      var e = f.length;\n      return 0 > a || a >= e ? d ? \"\" : void 0 : 55296 > (b = f.charCodeAt(a)) || 56319 < b || a + 1 === e || 56320 > (c = f.charCodeAt(a + 1)) || 57343 < c ? d ? f.charAt(a) : b : d ? f.slice(a, a + 2) : c - 56320 + (b - 55296 << 10) + 65536;\n    };\n  }),\n      Bm = {\n    codeAt: Ji(!1),\n    charAt: Ji(!0)\n  }.charAt,\n      Cm = ab.set,\n      Dm = ab.getterFor(\"String Iterator\");\n\n  of(String, \"String\", function (d) {\n    Cm(this, {\n      type: \"String Iterator\",\n      string: String(d),\n      index: 0\n    });\n  }, function () {\n    var d,\n        f = Dm(this),\n        a = f.string,\n        b = f.index;\n    return b >= a.length ? {\n      value: void 0,\n      done: !0\n    } : (d = Bm(a, b), f.index += d.length, {\n      value: d,\n      done: !1\n    });\n  });\n  var Em = ab.set,\n      Fm = ab.getterFor(\"Array Iterator\");\n  of(Array, \"Array\", function (d, f) {\n    Em(this, {\n      type: \"Array Iterator\",\n      target: gb(d),\n      index: 0,\n      kind: f\n    });\n  }, function () {\n    var d = Fm(this),\n        f = d.target,\n        a = d.kind,\n        b = d.index++;\n    return !f || b >= f.length ? (d.target = void 0, {\n      value: void 0,\n      done: !0\n    }) : \"keys\" == a ? {\n      value: b,\n      done: !1\n    } : \"values\" == a ? {\n      value: f[b],\n      done: !1\n    } : {\n      value: [b, f[b]],\n      done: !1\n    };\n  }, \"values\");\n  Jb.Arguments = Jb.Array;\n  var Ki = wa(\"toStringTag\"),\n      $d;\n\n  for ($d in {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n  }) {\n    var Li = N[$d],\n        qf = Li && Li.prototype;\n    qf && !qf[Ki] && mb(qf, Ki, $d);\n    Jb[$d] = Jb.Array;\n  }\n\n  var aa = ia.Map,\n      Gm = wa(\"match\"),\n      rf = function (d) {\n    var f;\n    if (Aa(d) && (void 0 !== (f = d[Gm]) ? f : \"RegExp\" == Ab(d))) throw TypeError(\"The method doesn't accept regular expressions\");\n    return d;\n  },\n      Hm = wa(\"match\"),\n      sf = function (d) {\n    var f = /./;\n\n    try {\n      \"/./\"[d](f);\n    } catch (a) {\n      try {\n        return f[Hm] = !1, \"/./\"[d](f);\n      } catch (b) {}\n    }\n\n    return !1;\n  },\n      Mi = \"\".endsWith,\n      Im = Math.min,\n      Jm = sf(\"endsWith\");\n\n  O({\n    target: \"String\",\n    proto: !0,\n    forced: !Jm\n  }, {\n    endsWith: function (d) {\n      var f = String(ac(this));\n      rf(d);\n      var a = 1 < arguments.length ? arguments[1] : void 0,\n          b = nb(f.length);\n      a = void 0 === a ? b : Im(nb(a), b);\n      b = String(d);\n      return Mi ? Mi.call(f, b, a) : f.slice(a - b.length, a) === b;\n    }\n  });\n\n  var za = function (d) {\n    return ia[d + \"Prototype\"];\n  },\n      Km = za(\"String\").endsWith,\n      Ni = String.prototype,\n      og = function (d) {\n    var f = d.endsWith;\n    return \"string\" == typeof d || d === Ni || d instanceof String && f === Ni.endsWith ? Km : f;\n  },\n      Wc = function (d, f) {\n    var a = [][d];\n    return !a || !sa(function () {\n      a.call(null, f || function () {\n        throw 1;\n      }, 1);\n    });\n  },\n      Oi = Wc(\"forEach\") ? function (d) {\n    return wc(this, d, 1 < arguments.length ? arguments[1] : void 0);\n  } : [].forEach;\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: [].forEach != Oi\n  }, {\n    forEach: Oi\n  });\n\n  var Lm = za(\"Array\").forEach,\n      Pi = Array.prototype,\n      Mm = {\n    DOMTokenList: !0,\n    NodeList: !0\n  },\n      q = function (d) {\n    var f = d.forEach;\n    return d === Pi || d instanceof Array && f === Pi.forEach || Mm.hasOwnProperty(Sd(d)) ? Lm : f;\n  },\n      Xc = {\n    f: Object.getOwnPropertySymbols\n  },\n      ae = Object.assign,\n      Qi = !ae || sa(function () {\n    var d = {},\n        f = {},\n        a = Symbol();\n    return d[a] = 7, \"abcdefghijklmnopqrst\".split(\"\").forEach(function (a) {\n      f[a] = a;\n    }), 7 != ae({}, d)[a] || \"abcdefghijklmnopqrst\" != Sb(ae({}, f)).join(\"\");\n  }) ? function (d, f) {\n    for (var a = ob(d), b = arguments.length, c = 1, e = Xc.f, g = Ld; b > c;) for (var h, p = Md(arguments[c++]), r = e ? Sb(p).concat(e(p)) : Sb(p), t = r.length, k = 0; t > k;) h = r[k++], la && !g.call(p, h) || (a[h] = p[h]);\n\n    return a;\n  } : ae;\n\n  O({\n    target: \"Object\",\n    stat: !0,\n    forced: Object.assign !== Qi\n  }, {\n    assign: Qi\n  });\n  var Ga = ia.Object.assign,\n      Nm = sa(function () {\n    Sb(1);\n  });\n  O({\n    target: \"Object\",\n    stat: !0,\n    forced: Nm\n  }, {\n    keys: function (d) {\n      return Sb(ob(d));\n    }\n  });\n\n  var V = ia.Object.keys,\n      Ri = function (d) {\n    return function (f, a, b, c) {\n      lb(a);\n      f = ob(f);\n      var e = Md(f),\n          g = nb(f.length),\n          h = d ? g - 1 : 0,\n          p = d ? -1 : 1;\n      if (2 > b) for (;;) {\n        if (h in e) {\n          c = e[h];\n          h += p;\n          break;\n        }\n\n        if (h += p, d ? 0 > h : g <= h) throw TypeError(\"Reduce of empty array with no initial value\");\n      }\n\n      for (; d ? 0 <= h : g > h; h += p) h in e && (c = a(c, e[h], h, f));\n\n      return c;\n    };\n  },\n      Om = {\n    left: Ri(!1),\n    right: Ri(!0)\n  }.left;\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: Wc(\"reduce\")\n  }, {\n    reduce: function (d) {\n      return Om(this, d, arguments.length, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var Pm = za(\"Array\").reduce,\n      Si = Array.prototype,\n      qd = function (d) {\n    var f = d.reduce;\n    return d === Si || d instanceof Array && f === Si.reduce ? Pm : f;\n  };\n\n  O({\n    target: \"Object\",\n    stat: !0,\n    forced: !la,\n    sham: !la\n  }, {\n    defineProperty: hb.f\n  });\n\n  var Ti = ub(function (d) {\n    var f = ia.Object;\n\n    d = d.exports = function (a, b, c) {\n      return f.defineProperty(a, b, c);\n    };\n\n    f.defineProperty.sham && (d.sham = !0);\n  }),\n      Y = Ti,\n      Qm = /^[\\t\\n\\x0B\\f\\r \\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029\\ufeff][\\t\\n\\x0B\\f\\r \\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029\\ufeff]*/,\n      Rm = /[\\t\\n\\x0B\\f\\r \\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029\\ufeff][\\t\\n\\x0B\\f\\r \\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029\\ufeff]*$/,\n      tf = function (d) {\n    return function (f) {\n      f = String(ac(f));\n      return 1 & d && (f = f.replace(Qm, \"\")), 2 & d && (f = f.replace(Rm, \"\")), f;\n    };\n  };\n\n  tf(1);\n  tf(2);\n  var Ui = tf(3),\n      be = N.parseInt,\n      Sm = /^[+-]?0[Xx]/,\n      Vi = 8 !== be(\"\\t\\n\\x0B\\f\\r \\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029\\ufeff08\") || 22 !== be(\"\\t\\n\\x0B\\f\\r \\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029\\ufeff0x16\") ? function (d, f) {\n    d = Ui(String(d));\n    return be(d, f >>> 0 || (Sm.test(d) ? 16 : 10));\n  } : be;\n  O({\n    global: !0,\n    forced: parseInt != Vi\n  }, {\n    parseInt: Vi\n  });\n  var pa = ia.parseInt;\n  let kg = !0,\n      lg = !0;\n  var Wi = tc,\n      Tm = sa(function () {\n    Wi(1);\n  });\n  O({\n    target: \"Object\",\n    stat: !0,\n    forced: !la || Tm,\n    sham: !la\n  }, {\n    getOwnPropertyDescriptor: function (d, f) {\n      return Wi(gb(d), f);\n    }\n  });\n\n  var yc,\n      ce,\n      Z = ub(function (d) {\n    var f = ia.Object;\n\n    d = d.exports = function (a, b) {\n      return f.getOwnPropertyDescriptor(a, b);\n    };\n\n    f.getOwnPropertyDescriptor.sham && (d.sham = !0);\n  }),\n      fc = function (d, f, a) {\n    f = rc(f);\n    f in d ? hb.f(d, f, $b(0, a)) : d[f] = a;\n  },\n      Yc = Hb(\"navigator\", \"userAgent\") || \"\",\n      Xi = N.process,\n      Yi = Xi && Xi.versions,\n      Zi = Yi && Yi.v8;\n\n  Zi ? ce = (yc = Zi.split(\".\"))[0] + yc[1] : Yc && (!(yc = Yc.match(/Edge\\/(\\d+)/)) || 74 <= yc[1]) && (yc = Yc.match(/Chrome\\/(\\d+)/)) && (ce = yc[1]);\n\n  var de = ce && +ce,\n      Um = wa(\"species\"),\n      Zc = function (d) {\n    return 51 <= de || !sa(function () {\n      var f = [];\n      return (f.constructor = {})[Um] = function () {\n        return {\n          foo: 1\n        };\n      }, 1 !== f[d](Boolean).foo;\n    });\n  },\n      $i = wa(\"isConcatSpreadable\"),\n      Vm = 51 <= de || !sa(function () {\n    var d = [];\n    return d[$i] = !1, d.concat()[0] !== d;\n  }),\n      Wm = Zc(\"concat\");\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: !Vm || !Wm\n  }, {\n    concat: function (d) {\n      var f,\n          a,\n          b = ob(this),\n          c = ef(b, 0),\n          e = 0;\n      var g = -1;\n\n      for (f = arguments.length; g < f; g++) {\n        var h = a = -1 === g ? b : arguments[g];\n\n        if (Aa(h)) {\n          var p = h[$i];\n          h = void 0 !== p ? !!p : cc(h);\n        } else h = !1;\n\n        if (h) {\n          if (9007199254740991 < e + (p = nb(a.length))) throw TypeError(\"Maximum allowed index exceeded\");\n\n          for (h = 0; h < p; h++, e++) h in a && fc(c, e, a[h]);\n        } else {\n          if (9007199254740991 <= e) throw TypeError(\"Maximum allowed index exceeded\");\n          fc(c, e++, a);\n        }\n      }\n\n      return c.length = e, c;\n    }\n  });\n\n  var Xm = za(\"Array\").concat,\n      aj = Array.prototype,\n      m = function (d) {\n    var f = d.concat;\n    return d === aj || d instanceof Array && f === aj.concat ? Xm : f;\n  };\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: !Zc(\"filter\")\n  }, {\n    filter: function (d) {\n      return fm(this, d, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var Ym = za(\"Array\").filter,\n      bj = Array.prototype,\n      I = function (d) {\n    var f = d.filter;\n    return d === bj || d instanceof Array && f === bj.filter ? Ym : f;\n  },\n      Zm = N.Promise,\n      cj = wa(\"iterator\"),\n      dj = !1;\n\n  try {\n    var $m = 0,\n        ej = {\n      next: function () {\n        return {\n          done: !!$m++\n        };\n      },\n      return: function () {\n        dj = !0;\n      }\n    };\n\n    ej[cj] = function () {\n      return this;\n    };\n\n    Array.from(ej, function () {\n      throw 2;\n    });\n  } catch (d) {}\n\n  var zc,\n      fj,\n      uf,\n      gj = function (d, f) {\n    if (!f && !dj) return !1;\n    var a = !1;\n\n    try {\n      f = {}, f[cj] = function () {\n        return {\n          next: function () {\n            return {\n              done: a = !0\n            };\n          }\n        };\n      }, d(f);\n    } catch (b) {}\n\n    return a;\n  },\n      an = wa(\"species\"),\n      hj = function (d, f) {\n    var a;\n    d = Ua(d).constructor;\n    return void 0 === d || null == (a = Ua(d)[an]) ? f : lb(a);\n  },\n      ij = /(iphone|ipod|ipad).*applewebkit/i.test(Yc),\n      jj = N.location,\n      vf = N.setImmediate,\n      kj = N.clearImmediate,\n      lj = N.process,\n      mj = N.MessageChannel,\n      wf = N.Dispatch,\n      xf = 0,\n      $c = {},\n      yf = function (d) {\n    if ($c.hasOwnProperty(d)) {\n      var f = $c[d];\n      delete $c[d];\n      f();\n    }\n  },\n      zf = function (d) {\n    return function () {\n      yf(d);\n    };\n  },\n      nj = function (d) {\n    yf(d.data);\n  },\n      oj = function (d) {\n    N.postMessage(d + \"\", jj.protocol + \"//\" + jj.host);\n  };\n\n  vf && kj || (vf = function (d) {\n    for (var f = [], a = 1; arguments.length > a;) f.push(arguments[a++]);\n\n    return $c[++xf] = function () {\n      (\"function\" == typeof d ? d : Function(d)).apply(void 0, f);\n    }, zc(xf), xf;\n  }, kj = function (d) {\n    delete $c[d];\n  }, \"process\" == Ab(lj) ? zc = function (d) {\n    lj.nextTick(zf(d));\n  } : wf && wf.now ? zc = function (d) {\n    wf.now(zf(d));\n  } : mj && !ij ? (uf = (fj = new mj()).port2, fj.port1.onmessage = nj, zc = bc(uf.postMessage, uf, 1)) : !N.addEventListener || \"function\" != typeof postMessage || N.importScripts || sa(oj) ? zc = \"onreadystatechange\" in (Nd ? sc.createElement(\"script\") : {}) ? function (d) {\n    hf.appendChild(Nd ? sc.createElement(\"script\") : {}).onreadystatechange = function () {\n      hf.removeChild(this);\n      yf(d);\n    };\n  } : function (d) {\n    setTimeout(zf(d), 0);\n  } : (zc = oj, N.addEventListener(\"message\", nj, !1)));\n  var ad,\n      gc,\n      bd,\n      Ac,\n      Af,\n      Bf,\n      Cf,\n      pj,\n      Df = vf,\n      bn = tc,\n      qj = N.MutationObserver || N.WebKitMutationObserver,\n      Ef = N.process,\n      Ff = N.Promise,\n      rj = \"process\" == Ab(Ef),\n      sj = bn(N, \"queueMicrotask\"),\n      tj = sj && sj.value;\n  tj || (ad = function () {\n    var d;\n\n    for (rj && (d = Ef.domain) && d.exit(); gc;) {\n      var f = gc.fn;\n      gc = gc.next;\n\n      try {\n        f();\n      } catch (a) {\n        throw gc ? Ac() : bd = void 0, a;\n      }\n    }\n\n    bd = void 0;\n    d && d.enter();\n  }, rj ? Ac = function () {\n    Ef.nextTick(ad);\n  } : qj && !ij ? (Af = !0, Bf = document.createTextNode(\"\"), new qj(ad).observe(Bf, {\n    characterData: !0\n  }), Ac = function () {\n    Bf.data = Af = !Af;\n  }) : Ff && Ff.resolve ? (Cf = Ff.resolve(void 0), pj = Cf.then, Ac = function () {\n    pj.call(Cf, ad);\n  }) : Ac = function () {\n    Df.call(N, ad);\n  });\n\n  var Gf,\n      uj,\n      vj = tj || function (d) {\n    d = {\n      fn: d,\n      next: void 0\n    };\n    bd && (bd.next = d);\n    gc || (gc = d, Ac());\n    bd = d;\n  },\n      cn = function (d) {\n    var f, a;\n    this.promise = new d(function (b, c) {\n      if (void 0 !== f || void 0 !== a) throw TypeError(\"Bad Promise constructor\");\n      f = b;\n      a = c;\n    });\n    this.resolve = lb(f);\n    this.reject = lb(a);\n  },\n      ee = {\n    f: function (d) {\n      return new cn(d);\n    }\n  },\n      Hf = function (d, f) {\n    if (Ua(d), Aa(f) && f.constructor === d) return f;\n    d = ee.f(d);\n    return (0, d.resolve)(f), d.promise;\n  },\n      fe = function (d) {\n    try {\n      return {\n        error: !1,\n        value: d()\n      };\n    } catch (f) {\n      return {\n        error: !0,\n        value: f\n      };\n    }\n  },\n      dn = wa(\"species\"),\n      wj = ab.get,\n      en = ab.set,\n      fn = ab.getterFor(\"Promise\"),\n      Va = Zm,\n      xj = N.TypeError,\n      If = N.document,\n      ge = N.process,\n      gn = Ib(\"inspectSource\"),\n      Bc = (Hb(\"fetch\"), ee.f),\n      hn = Bc,\n      cd = \"process\" == Ab(ge),\n      jn = !!(If && If.createEvent && N.dispatchEvent),\n      he = uc(\"Promise\", function () {\n    if (gn(Va) === String(Va) && (66 === de || !cd && \"function\" != typeof PromiseRejectionEvent) || !Va.prototype.finally) return !0;\n    if (51 <= de && /native code/.test(Va)) return !1;\n\n    var d = Va.resolve(1),\n        f = function (a) {\n      a(function () {}, function () {});\n    };\n\n    return (d.constructor = {})[dn] = f, !(d.then(function () {}) instanceof f);\n  }),\n      kn = he || !gj(function (d) {\n    Va.all(d).catch(function () {});\n  }),\n      yj = function (d) {\n    var f;\n    return !(!Aa(d) || \"function\" != typeof (f = d.then)) && f;\n  },\n      Jf = function (d, f, a) {\n    if (!f.notified) {\n      f.notified = !0;\n      var b = f.reactions;\n      vj(function () {\n        for (var c = f.value, e = 1 == f.state, g = 0; b.length > g;) {\n          var h,\n              p,\n              r,\n              t = b[g++],\n              k = e ? t.ok : t.fail,\n              l = t.resolve,\n              D = t.reject,\n              m = t.domain;\n\n          try {\n            k ? (e || (2 === f.rejection && ln(d, f), f.rejection = 1), !0 === k ? h = c : (m && m.enter(), h = k(c), m && (m.exit(), r = !0)), h === t.promise ? D(xj(\"Promise-chain cycle\")) : (p = yj(h)) ? p.call(h, l, D) : l(h)) : D(c);\n          } catch (z) {\n            m && !r && m.exit(), D(z);\n          }\n        }\n\n        f.reactions = [];\n        f.notified = !1;\n        a && !f.rejection && mn(d, f);\n      });\n    }\n  },\n      zj = function (d, f, a) {\n    var b, c;\n    jn ? ((b = If.createEvent(\"Event\")).promise = f, b.reason = a, b.initEvent(d, !1, !0), N.dispatchEvent(b)) : b = {\n      promise: f,\n      reason: a\n    };\n    (c = N[\"on\" + d]) ? c(b) : \"unhandledrejection\" === d && function (a, b) {\n      var c = N.console;\n      c && c.error && (1 === arguments.length ? c.error(a) : c.error(a, b));\n    }(\"Unhandled promise rejection\", a);\n  },\n      mn = function (d, f) {\n    Df.call(N, function () {\n      var a,\n          b = f.value;\n      if (1 !== f.rejection && !f.parent && (a = fe(function () {\n        cd ? ge.emit(\"unhandledRejection\", b, d) : zj(\"unhandledrejection\", d, b);\n      }), f.rejection = cd || 1 !== f.rejection && !f.parent ? 2 : 1, a.error)) throw a.value;\n    });\n  },\n      ln = function (d, f) {\n    Df.call(N, function () {\n      cd ? ge.emit(\"rejectionHandled\", d) : zj(\"rejectionhandled\", d, f.value);\n    });\n  },\n      Cc = function (d, f, a, b) {\n    return function (c) {\n      d(f, a, c, b);\n    };\n  },\n      Dc = function (d, f, a, b) {\n    f.done || (f.done = !0, b && (f = b), f.value = a, f.state = 2, Jf(d, f, !0));\n  },\n      Kf = function (d, f, a, b) {\n    if (!f.done) {\n      f.done = !0;\n      b && (f = b);\n\n      try {\n        if (d === a) throw xj(\"Promise can't be resolved itself\");\n        var c = yj(a);\n        c ? vj(function () {\n          var b = {\n            done: !1\n          };\n\n          try {\n            c.call(a, Cc(Kf, d, b, f), Cc(Dc, d, b, f));\n          } catch (g) {\n            Dc(d, b, g, f);\n          }\n        }) : (f.value = a, f.state = 1, Jf(d, f, !1));\n      } catch (e) {\n        Dc(d, {\n          done: !1\n        }, e, f);\n      }\n    }\n  };\n\n  he && (Va = function (d) {\n    df(this, Va, \"Promise\");\n    lb(d);\n    Gf.call(this);\n    var f = wj(this);\n\n    try {\n      d(Cc(Kf, this, f), Cc(Dc, this, f));\n    } catch (a) {\n      Dc(this, f, a);\n    }\n  }, (Gf = function (d) {\n    en(this, {\n      type: \"Promise\",\n      done: !1,\n      notified: !1,\n      parent: !1,\n      reactions: [],\n      rejection: !1,\n      state: 0,\n      value: void 0\n    });\n  }).prototype = lf(Va.prototype, {\n    then: function (d, f) {\n      var a = fn(this),\n          b = Bc(hj(this, Va));\n      return b.ok = \"function\" != typeof d || d, b.fail = \"function\" == typeof f && f, b.domain = cd ? ge.domain : void 0, a.parent = !0, a.reactions.push(b), 0 != a.state && Jf(this, a, !1), b.promise;\n    },\n    catch: function (d) {\n      return this.then(void 0, d);\n    }\n  }), uj = function () {\n    var d = new Gf(),\n        f = wj(d);\n    this.promise = d;\n    this.resolve = Cc(Kf, d, f);\n    this.reject = Cc(Dc, d, f);\n  }, ee.f = Bc = function (d) {\n    return d === Va || d === Aj ? new uj(d) : hn(d);\n  });\n  O({\n    global: !0,\n    wrap: !0,\n    forced: he\n  }, {\n    Promise: Va\n  });\n  Uc(Va, \"Promise\", !1, !0);\n  Gi(\"Promise\");\n  var Aj = Hb(\"Promise\");\n  O({\n    target: \"Promise\",\n    stat: !0,\n    forced: he\n  }, {\n    reject: function (d) {\n      var f = Bc(this);\n      return f.reject.call(void 0, d), f.promise;\n    }\n  });\n  O({\n    target: \"Promise\",\n    stat: !0,\n    forced: !0\n  }, {\n    resolve: function (d) {\n      return Hf(this === Aj ? Va : this, d);\n    }\n  });\n  O({\n    target: \"Promise\",\n    stat: !0,\n    forced: kn\n  }, {\n    all: function (d) {\n      var f = this,\n          a = Bc(f),\n          b = a.resolve,\n          c = a.reject,\n          e = fe(function () {\n        var a = lb(f.resolve),\n            e = [],\n            p = 0,\n            r = 1;\n        Tc(d, function (d) {\n          var g = p++,\n              h = !1;\n          e.push(void 0);\n          r++;\n          a.call(f, d).then(function (a) {\n            h || (h = !0, e[g] = a, --r || b(e));\n          }, c);\n        });\n        --r || b(e);\n      });\n      return e.error && c(e.value), a.promise;\n    },\n    race: function (d) {\n      var f = this,\n          a = Bc(f),\n          b = a.reject,\n          c = fe(function () {\n        var c = lb(f.resolve);\n        Tc(d, function (d) {\n          c.call(f, d).then(a.resolve, b);\n        });\n      });\n      return c.error && b(c.value), a.promise;\n    }\n  });\n  O({\n    target: \"Promise\",\n    stat: !0\n  }, {\n    allSettled: function (d) {\n      var f = this,\n          a = ee.f(f),\n          b = a.resolve,\n          c = a.reject,\n          e = fe(function () {\n        var a = lb(f.resolve),\n            c = [],\n            e = 0,\n            r = 1;\n        Tc(d, function (d) {\n          var g = e++,\n              h = !1;\n          c.push(void 0);\n          r++;\n          a.call(f, d).then(function (a) {\n            h || (h = !0, c[g] = {\n              status: \"fulfilled\",\n              value: a\n            }, --r || b(c));\n          }, function (a) {\n            h || (h = !0, c[g] = {\n              status: \"rejected\",\n              reason: a\n            }, --r || b(c));\n          });\n        });\n        --r || b(c);\n      });\n      return e.error && c(e.value), a.promise;\n    }\n  });\n  O({\n    target: \"Promise\",\n    proto: !0,\n    real: !0\n  }, {\n    finally: function (d) {\n      var f = hj(this, Hb(\"Promise\")),\n          a = \"function\" == typeof d;\n      return this.then(a ? function (a) {\n        return Hf(f, d()).then(function () {\n          return a;\n        });\n      } : d, a ? function (a) {\n        return Hf(f, d()).then(function () {\n          throw a;\n        });\n      } : d);\n    }\n  });\n  var A = ia.Promise;\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: !Zc(\"map\")\n  }, {\n    map: function (d) {\n      return em(this, d, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var nn = za(\"Array\").map,\n      Bj = Array.prototype,\n      E = function (d) {\n    var f = d.map;\n    return d === Bj || d instanceof Array && f === Bj.map ? nn : f;\n  },\n      on = Math.max,\n      pn = Math.min;\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: !Zc(\"splice\")\n  }, {\n    splice: function (d, f) {\n      var a,\n          b,\n          c,\n          e,\n          g = ob(this),\n          h = nb(g.length),\n          p = Vd(d, h);\n      var r = arguments.length;\n      if (0 === r ? a = b = 0 : 1 === r ? (a = 0, b = h - p) : (a = r - 2, b = pn(on(Rd(f), 0), h - p)), 9007199254740991 < h + a - b) throw TypeError(\"Maximum allowed length exceeded\");\n      r = ef(g, b);\n\n      for (c = 0; c < b; c++) (e = p + c) in g && fc(r, c, g[e]);\n\n      if (r.length = b, a < b) {\n        for (c = p; c < h - b; c++) {\n          var t = c + a;\n          (e = c + b) in g ? g[t] = g[e] : delete g[t];\n        }\n\n        for (c = h; c > h - b + a; c--) delete g[c - 1];\n      } else if (a > b) for (c = h - b; c > p; c--) t = c + a - 1, (e = c + b - 1) in g ? g[t] = g[e] : delete g[t];\n\n      for (c = 0; c < a; c++) g[c + p] = arguments[c + 2];\n\n      return g.length = h - b + a, r;\n    }\n  });\n\n  var qn = za(\"Array\").splice,\n      Cj = Array.prototype,\n      Ia = function (d) {\n    var f = d.splice;\n    return d === Cj || d instanceof Array && f === Cj.splice ? qn : f;\n  },\n      Dj = [].indexOf,\n      Ej = !!Dj && 0 > 1 / [1].indexOf(1, -0),\n      rn = Wc(\"indexOf\");\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: Ej || rn\n  }, {\n    indexOf: function (d) {\n      return Ej ? Dj.apply(this, arguments) || 0 : wi(this, d, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var sn = za(\"Array\").indexOf,\n      Fj = Array.prototype,\n      J = function (d) {\n    var f = d.indexOf;\n    return d === Fj || d instanceof Array && f === Fj.indexOf ? sn : f;\n  },\n      tn = wa(\"species\"),\n      un = [].slice,\n      vn = Math.max;\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: !Zc(\"slice\")\n  }, {\n    slice: function (d, f) {\n      var a,\n          b = gb(this);\n      var c = nb(b.length);\n      d = Vd(d, c);\n      f = Vd(void 0 === f ? c : f, c);\n      if (cc(b) && (\"function\" != typeof (a = b.constructor) || a !== Array && !cc(a.prototype) ? Aa(a) && null === (a = a[tn]) && (a = void 0) : a = void 0, a === Array || void 0 === a)) return un.call(b, d, f);\n      a = new (void 0 === a ? Array : a)(vn(f - d, 0));\n\n      for (c = 0; d < f; d++, c++) d in b && fc(a, c, b[d]);\n\n      return a.length = c, a;\n    }\n  });\n\n  var wn = za(\"Array\").slice,\n      Gj = Array.prototype,\n      Ha = function (d) {\n    var f = d.slice;\n    return d === Gj || d instanceof Array && f === Gj.slice ? wn : f;\n  },\n      Hj = !0;\n\n  \"find\" in [] && Array(1).find(function () {\n    Hj = !1;\n  });\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: Hj\n  }, {\n    find: function (d) {\n      return hm(this, d, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var xn = za(\"Array\").find,\n      Ij = Array.prototype,\n      R = function (d) {\n    var f = d.find;\n    return d === Ij || d instanceof Array && f === Ij.find ? xn : f;\n  },\n      Jj = [].slice,\n      Lf = {};\n\n  O({\n    target: \"Function\",\n    proto: !0\n  }, {\n    bind: Function.bind || function (d) {\n      var f = lb(this),\n          a = Jj.call(arguments, 1),\n          b = function () {\n        var c = a.concat(Jj.call(arguments));\n\n        if (this instanceof b) {\n          var e = c.length;\n\n          if (!(e in Lf)) {\n            for (var g = [], h = 0; h < e; h++) g[h] = \"a[\" + h + \"]\";\n\n            Lf[e] = Function(\"C,a\", \"return new C(\" + g.join(\",\") + \")\");\n          }\n\n          c = Lf[e](f, c);\n        } else c = f.apply(d, c);\n\n        return c;\n      };\n\n      return Aa(f.prototype) && (b.prototype = f.prototype), b;\n    }\n  });\n\n  var yn = za(\"Function\").bind,\n      Kj = Function.prototype,\n      ra = function (d) {\n    var f = d.bind;\n    return d === Kj || d instanceof Function && f === Kj.bind ? yn : f;\n  };\n\n  O({\n    target: \"Array\",\n    proto: !0\n  }, {\n    includes: function (d) {\n      return um(this, d, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n  var zn = za(\"Array\").includes;\n  O({\n    target: \"String\",\n    proto: !0,\n    forced: !sf(\"includes\")\n  }, {\n    includes: function (d) {\n      return !!~String(ac(this)).indexOf(rf(d), 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var An = za(\"String\").includes,\n      Lj = Array.prototype,\n      Mj = String.prototype,\n      ba = function (d) {\n    var f = d.includes;\n    return d === Lj || d instanceof Array && f === Lj.includes ? zn : \"string\" == typeof d || d === Mj || d instanceof String && f === Mj.includes ? An : f;\n  };\n\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: Wc(\"some\")\n  }, {\n    some: function (d) {\n      return gm(this, d, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var Bn = za(\"Array\").some,\n      Nj = Array.prototype,\n      qg = function (d) {\n    var f = d.some;\n    return d === Nj || d instanceof Array && f === Nj.some ? Bn : f;\n  };\n\n  let rg = kb;\n  var Oj = Object.freeze({\n    __proto__: null,\n    shimMediaStream: sg,\n    shimOnTrack: tg,\n    shimGetSendersWithDtmf: ug,\n    shimGetStats: vg,\n    shimSenderReceiverGetStats: wg,\n    shimAddTrackRemoveTrackWithNative: xg,\n    shimAddTrackRemoveTrack: yg,\n    shimPeerConnection: se,\n    fixNegotiationNeeded: zg,\n    shimGetUserMedia: pg,\n    shimGetDisplayMedia: function (d, f) {\n      d.navigator.mediaDevices && \"getDisplayMedia\" in d.navigator.mediaDevices || d.navigator.mediaDevices && (\"function\" == typeof f ? d.navigator.mediaDevices.getDisplayMedia = function (a) {\n        return f(a).then(b => {\n          let c = a.video && a.video.width,\n              e = a.video && a.video.height;\n          return a.video = {\n            mandatory: {\n              chromeMediaSource: \"desktop\",\n              chromeMediaSourceId: b,\n              maxFrameRate: a.video && a.video.frameRate || 3\n            }\n          }, c && (a.video.mandatory.maxWidth = c), e && (a.video.mandatory.maxHeight = e), d.navigator.mediaDevices.getUserMedia(a);\n        });\n      } : console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\"));\n    }\n  }),\n      Pj = \"\".startsWith,\n      Cn = Math.min,\n      Dn = sf(\"startsWith\");\n  O({\n    target: \"String\",\n    proto: !0,\n    forced: !Dn\n  }, {\n    startsWith: function (d) {\n      var f = String(ac(this));\n      rf(d);\n      var a = nb(Cn(1 < arguments.length ? arguments[1] : void 0, f.length)),\n          b = String(d);\n      return Pj ? Pj.call(f, b, a) : f.slice(a, a + b.length) === b;\n    }\n  });\n\n  var En = za(\"String\").startsWith,\n      Qj = String.prototype,\n      sd = function (d) {\n    var f = d.startsWith;\n    return \"string\" == typeof d || d === Qj || d instanceof String && f === Qj.startsWith ? En : f;\n  };\n\n  O({\n    target: \"String\",\n    proto: !0,\n    forced: sa(function () {\n      return \"trim\" !== \"\\t\\n\\v\\f\\r \\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029\\ufeff\".trim.name;\n    })\n  }, {\n    trim: function () {\n      return Ui(this);\n    }\n  });\n\n  var Fn = za(\"String\").trim,\n      Rj = String.prototype,\n      Xb = function (d) {\n    var f = d.trim;\n    return \"string\" == typeof d || d === Rj || d instanceof String && f === Rj.trim ? Fn : f;\n  },\n      G = ub(function (d) {\n    var f = {\n      generateIdentifier: function () {\n        return Math.random().toString(36).substr(2, 10);\n      }\n    };\n    f.localCName = f.generateIdentifier();\n\n    f.splitLines = function (a) {\n      var b;\n      return E(b = Xb(a).call(a).split(\"\\n\")).call(b, function (a) {\n        return Xb(a).call(a);\n      });\n    };\n\n    f.splitSections = function (a) {\n      a = a.split(\"\\nm=\");\n      return E(a).call(a, function (a, c) {\n        var b;\n        return Xb(b = 0 < c ? \"m=\" + a : a).call(b) + \"\\r\\n\";\n      });\n    };\n\n    f.getDescription = function (a) {\n      return (a = f.splitSections(a)) && a[0];\n    };\n\n    f.getMediaSections = function (a) {\n      a = f.splitSections(a);\n      return a.shift(), a;\n    };\n\n    f.matchPrefix = function (a, b) {\n      var c;\n      return I(c = f.splitLines(a)).call(c, function (a) {\n        return 0 === J(a).call(a, b);\n      });\n    };\n\n    f.parseCandidate = function (a) {\n      var b;\n      a = {\n        foundation: (b = 0 === J(a).call(a, \"a=candidate:\") ? a.substring(12).split(\" \") : a.substring(10).split(\" \"))[0],\n        component: pa(b[1], 10),\n        protocol: b[2].toLowerCase(),\n        priority: pa(b[3], 10),\n        ip: b[4],\n        address: b[4],\n        port: pa(b[5], 10),\n        type: b[7]\n      };\n\n      for (var c = 8; c < b.length; c += 2) switch (b[c]) {\n        case \"raddr\":\n          a.relatedAddress = b[c + 1];\n          break;\n\n        case \"rport\":\n          a.relatedPort = pa(b[c + 1], 10);\n          break;\n\n        case \"tcptype\":\n          a.tcpType = b[c + 1];\n          break;\n\n        case \"ufrag\":\n          a.ufrag = b[c + 1];\n          a.usernameFragment = b[c + 1];\n          break;\n\n        default:\n          a[b[c]] = b[c + 1];\n      }\n\n      return a;\n    };\n\n    f.writeCandidate = function (a) {\n      var b = [];\n      b.push(a.foundation);\n      b.push(a.component);\n      b.push(a.protocol.toUpperCase());\n      b.push(a.priority);\n      b.push(a.address || a.ip);\n      b.push(a.port);\n      var c = a.type;\n      return b.push(\"typ\"), b.push(c), \"host\" !== c && a.relatedAddress && a.relatedPort && (b.push(\"raddr\"), b.push(a.relatedAddress), b.push(\"rport\"), b.push(a.relatedPort)), a.tcpType && \"tcp\" === a.protocol.toLowerCase() && (b.push(\"tcptype\"), b.push(a.tcpType)), (a.usernameFragment || a.ufrag) && (b.push(\"ufrag\"), b.push(a.usernameFragment || a.ufrag)), \"candidate:\" + b.join(\" \");\n    };\n\n    f.parseIceOptions = function (a) {\n      return a.substr(14).split(\" \");\n    };\n\n    f.parseRtpMap = function (a) {\n      a = a.substr(9).split(\" \");\n      var b = {\n        payloadType: pa(a.shift(), 10)\n      };\n      return a = a[0].split(\"/\"), b.name = a[0], b.clockRate = pa(a[1], 10), b.channels = 3 === a.length ? pa(a[2], 10) : 1, b.numChannels = b.channels, b;\n    };\n\n    f.writeRtpMap = function (a) {\n      var b = a.payloadType;\n      void 0 !== a.preferredPayloadType && (b = a.preferredPayloadType);\n      var c = a.channels || a.numChannels || 1;\n      return \"a=rtpmap:\" + b + \" \" + a.name + \"/\" + a.clockRate + (1 !== c ? \"/\" + c : \"\") + \"\\r\\n\";\n    };\n\n    f.parseExtmap = function (a) {\n      var b;\n      a = a.substr(9).split(\" \");\n      return {\n        id: pa(a[0], 10),\n        direction: 0 < J(b = a[0]).call(b, \"/\") ? a[0].split(\"/\")[1] : \"sendrecv\",\n        uri: a[1]\n      };\n    };\n\n    f.writeExtmap = function (a) {\n      return \"a=extmap:\" + (a.id || a.preferredId) + (a.direction && \"sendrecv\" !== a.direction ? \"/\" + a.direction : \"\") + \" \" + a.uri + \"\\r\\n\";\n    };\n\n    f.parseFmtp = function (a) {\n      for (var b = {}, c = a.substr(J(a).call(a, \" \") + 1).split(\";\"), d = 0; d < c.length; d++) {\n        var g, h;\n        a = Xb(g = c[d]).call(g).split(\"=\");\n        b[Xb(h = a[0]).call(h)] = a[1];\n      }\n\n      return b;\n    };\n\n    f.writeFmtp = function (a) {\n      var b = \"\",\n          c = a.payloadType;\n\n      if (void 0 !== a.preferredPayloadType && (c = a.preferredPayloadType), a.parameters && V(a.parameters).length) {\n        var d,\n            g = [];\n        q(d = V(a.parameters)).call(d, function (b) {\n          a.parameters[b] ? g.push(b + \"=\" + a.parameters[b]) : g.push(b);\n        });\n        b += \"a=fmtp:\" + c + \" \" + g.join(\";\") + \"\\r\\n\";\n      }\n\n      return b;\n    };\n\n    f.parseRtcpFb = function (a) {\n      a = a.substr(J(a).call(a, \" \") + 1).split(\" \");\n      return {\n        type: a.shift(),\n        parameter: a.join(\" \")\n      };\n    };\n\n    f.writeRtcpFb = function (a) {\n      var b,\n          c = \"\",\n          d = a.payloadType;\n      (void 0 !== a.preferredPayloadType && (d = a.preferredPayloadType), a.rtcpFeedback && a.rtcpFeedback.length) && q(b = a.rtcpFeedback).call(b, function (a) {\n        c += \"a=rtcp-fb:\" + d + \" \" + a.type + (a.parameter && a.parameter.length ? \" \" + a.parameter : \"\") + \"\\r\\n\";\n      });\n      return c;\n    };\n\n    f.parseSsrcMedia = function (a) {\n      var b = J(a).call(a, \" \"),\n          c = {\n        ssrc: pa(a.substr(7, b - 7), 10)\n      },\n          d = J(a).call(a, \":\", b);\n      return -1 < d ? (c.attribute = a.substr(b + 1, d - b - 1), c.value = a.substr(d + 1)) : c.attribute = a.substr(b + 1), c;\n    };\n\n    f.parseSsrcGroup = function (a) {\n      a = a.substr(13).split(\" \");\n      return {\n        semantics: a.shift(),\n        ssrcs: E(a).call(a, function (a) {\n          return pa(a, 10);\n        })\n      };\n    };\n\n    f.getMid = function (a) {\n      if (a = f.matchPrefix(a, \"a=mid:\")[0]) return a.substr(6);\n    };\n\n    f.parseFingerprint = function (a) {\n      a = a.substr(14).split(\" \");\n      return {\n        algorithm: a[0].toLowerCase(),\n        value: a[1]\n      };\n    };\n\n    f.getDtlsParameters = function (a, b) {\n      a = f.matchPrefix(a + b, \"a=fingerprint:\");\n      return {\n        role: \"auto\",\n        fingerprints: E(a).call(a, f.parseFingerprint)\n      };\n    };\n\n    f.writeDtlsParameters = function (a, b) {\n      var c,\n          d = \"a=setup:\" + b + \"\\r\\n\";\n      return q(c = a.fingerprints).call(c, function (a) {\n        d += \"a=fingerprint:\" + a.algorithm + \" \" + a.value + \"\\r\\n\";\n      }), d;\n    };\n\n    f.getIceParameters = function (a, b) {\n      a = f.splitLines(a);\n      return a = m(a).call(a, f.splitLines(b)), {\n        usernameFragment: I(a).call(a, function (a) {\n          return 0 === J(a).call(a, \"a=ice-ufrag:\");\n        })[0].substr(12),\n        password: I(a).call(a, function (a) {\n          return 0 === J(a).call(a, \"a=ice-pwd:\");\n        })[0].substr(10)\n      };\n    };\n\n    f.writeIceParameters = function (a) {\n      return \"a=ice-ufrag:\" + a.usernameFragment + \"\\r\\na=ice-pwd:\" + a.password + \"\\r\\n\";\n    };\n\n    f.parseRtpParameters = function (a) {\n      for (var b, c = {\n        codecs: [],\n        headerExtensions: [],\n        fecMechanisms: [],\n        rtcp: []\n      }, d = f.splitLines(a)[0].split(\" \"), g = 3; g < d.length; g++) {\n        var h = d[g],\n            p = f.matchPrefix(a, \"a=rtpmap:\" + h + \" \")[0];\n\n        if (p) {\n          var r;\n          p = f.parseRtpMap(p);\n          var t = f.matchPrefix(a, \"a=fmtp:\" + h + \" \");\n\n          switch (p.parameters = t.length ? f.parseFmtp(t[0]) : {}, p.rtcpFeedback = E(r = f.matchPrefix(a, \"a=rtcp-fb:\" + h + \" \")).call(r, f.parseRtcpFb), c.codecs.push(p), p.name.toUpperCase()) {\n            case \"RED\":\n            case \"ULPFEC\":\n              c.fecMechanisms.push(p.name.toUpperCase());\n          }\n        }\n      }\n\n      return q(b = f.matchPrefix(a, \"a=extmap:\")).call(b, function (a) {\n        c.headerExtensions.push(f.parseExtmap(a));\n      }), c;\n    };\n\n    f.writeRtpDescription = function (a, b) {\n      var c,\n          d,\n          g,\n          h = \"\";\n      h += \"m=\" + a + \" \";\n      h += 0 < b.codecs.length ? \"9\" : \"0\";\n      h += \" UDP/TLS/RTP/SAVPF \";\n      h += E(c = b.codecs).call(c, function (a) {\n        return void 0 !== a.preferredPayloadType ? a.preferredPayloadType : a.payloadType;\n      }).join(\" \") + \"\\r\\n\";\n      h += \"c=IN IP4 0.0.0.0\\r\\n\";\n      h += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n      q(d = b.codecs).call(d, function (a) {\n        h += f.writeRtpMap(a);\n        h += f.writeFmtp(a);\n        h += f.writeRtcpFb(a);\n      });\n      var p,\n          r = 0;\n      (q(g = b.codecs).call(g, function (a) {\n        a.maxptime > r && (r = a.maxptime);\n      }), 0 < r && (h += \"a=maxptime:\" + r + \"\\r\\n\"), h += \"a=rtcp-mux\\r\\n\", b.headerExtensions) && q(p = b.headerExtensions).call(p, function (a) {\n        h += f.writeExtmap(a);\n      });\n      return h;\n    };\n\n    f.parseRtpEncodingParameters = function (a) {\n      var b,\n          c,\n          d,\n          g,\n          h,\n          p,\n          r,\n          t = [],\n          k = f.parseRtpParameters(a),\n          l = -1 !== J(b = k.fecMechanisms).call(b, \"RED\"),\n          m = -1 !== J(c = k.fecMechanisms).call(c, \"ULPFEC\");\n      b = I(d = E(g = f.matchPrefix(a, \"a=ssrc:\")).call(g, function (a) {\n        return f.parseSsrcMedia(a);\n      })).call(d, function (a) {\n        return \"cname\" === a.attribute;\n      });\n      var n = 0 < b.length && b[0].ssrc;\n      d = E(h = f.matchPrefix(a, \"a=ssrc-group:FID\")).call(h, function (a) {\n        a = a.substr(17).split(\" \");\n        return E(a).call(a, function (a) {\n          return pa(a, 10);\n        });\n      });\n      0 < d.length && 1 < d[0].length && d[0][0] === n && (r = d[0][1]);\n      q(p = k.codecs).call(p, function (a) {\n        \"RTX\" === a.name.toUpperCase() && a.parameters.apt && (a = {\n          ssrc: n,\n          codecPayloadType: pa(a.parameters.apt, 10)\n        }, n && r && (a.rtx = {\n          ssrc: r\n        }), t.push(a), l && ((a = JSON.parse(w(a))).fec = {\n          ssrc: n,\n          mechanism: m ? \"red+ulpfec\" : \"red\"\n        }, t.push(a)));\n      });\n      0 === t.length && n && t.push({\n        ssrc: n\n      });\n      var z,\n          ka,\n          u = f.matchPrefix(a, \"b=\");\n      u.length && (u = 0 === J(z = u[0]).call(z, \"b=TIAS:\") ? pa(u[0].substr(7), 10) : 0 === J(ka = u[0]).call(ka, \"b=AS:\") ? 950 * pa(u[0].substr(5), 10) - 16E3 : void 0, q(t).call(t, function (a) {\n        a.maxBitrate = u;\n      }));\n      return t;\n    };\n\n    f.parseRtcpParameters = function (a) {\n      var b,\n          c,\n          d = {},\n          g = I(b = E(c = f.matchPrefix(a, \"a=ssrc:\")).call(c, function (a) {\n        return f.parseSsrcMedia(a);\n      })).call(b, function (a) {\n        return \"cname\" === a.attribute;\n      })[0];\n      g && (d.cname = g.value, d.ssrc = g.ssrc);\n      b = f.matchPrefix(a, \"a=rtcp-rsize\");\n      d.reducedSize = 0 < b.length;\n      d.compound = 0 === b.length;\n      a = f.matchPrefix(a, \"a=rtcp-mux\");\n      return d.mux = 0 < a.length, d;\n    };\n\n    f.parseMsid = function (a) {\n      var b,\n          d,\n          e,\n          g = f.matchPrefix(a, \"a=msid:\");\n      if (1 === g.length) return {\n        stream: (e = g[0].substr(7).split(\" \"))[0],\n        track: e[1]\n      };\n      a = I(b = E(d = f.matchPrefix(a, \"a=ssrc:\")).call(d, function (a) {\n        return f.parseSsrcMedia(a);\n      })).call(b, function (a) {\n        return \"msid\" === a.attribute;\n      });\n      return 0 < a.length ? {\n        stream: (e = a[0].value.split(\" \"))[0],\n        track: e[1]\n      } : void 0;\n    };\n\n    f.generateSessionId = function () {\n      return Math.random().toString().substr(2, 21);\n    };\n\n    f.writeSessionBoilerplate = function (a, b, d) {\n      b = void 0 !== b ? b : 2;\n      return \"v=0\\r\\no=\" + (d || \"thisisadapterortc\") + \" \" + (a || f.generateSessionId()) + \" \" + b + \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\";\n    };\n\n    f.writeMediaSection = function (a, b, d, e) {\n      b = f.writeRtpDescription(a.kind, b);\n      if (b += f.writeIceParameters(a.iceGatherer.getLocalParameters()), b += f.writeDtlsParameters(a.dtlsTransport.getLocalParameters(), \"offer\" === d ? \"actpass\" : \"active\"), b += \"a=mid:\" + a.mid + \"\\r\\n\", a.direction ? b += \"a=\" + a.direction + \"\\r\\n\" : a.rtpSender && a.rtpReceiver ? b += \"a=sendrecv\\r\\n\" : a.rtpSender ? b += \"a=sendonly\\r\\n\" : a.rtpReceiver ? b += \"a=recvonly\\r\\n\" : b += \"a=inactive\\r\\n\", a.rtpSender) d = \"msid:\" + e.id + \" \" + a.rtpSender.track.id + \"\\r\\n\", b = b + (\"a=\" + d) + (\"a=ssrc:\" + a.sendEncodingParameters[0].ssrc + \" \" + d), a.sendEncodingParameters[0].rtx && (b += \"a=ssrc:\" + a.sendEncodingParameters[0].rtx.ssrc + \" \" + d, b += \"a=ssrc-group:FID \" + a.sendEncodingParameters[0].ssrc + \" \" + a.sendEncodingParameters[0].rtx.ssrc + \"\\r\\n\");\n      return b += \"a=ssrc:\" + a.sendEncodingParameters[0].ssrc + \" cname:\" + f.localCName + \"\\r\\n\", a.rtpSender && a.sendEncodingParameters[0].rtx && (b += \"a=ssrc:\" + a.sendEncodingParameters[0].rtx.ssrc + \" cname:\" + f.localCName + \"\\r\\n\"), b;\n    };\n\n    f.getDirection = function (a, b) {\n      a = f.splitLines(a);\n\n      for (var d = 0; d < a.length; d++) switch (a[d]) {\n        case \"a=sendrecv\":\n        case \"a=sendonly\":\n        case \"a=recvonly\":\n        case \"a=inactive\":\n          return a[d].substr(2);\n      }\n\n      return b ? f.getDirection(b) : \"sendrecv\";\n    };\n\n    f.getKind = function (a) {\n      return f.splitLines(a)[0].split(\" \")[0].substr(2);\n    };\n\n    f.isRejected = function (a) {\n      return \"0\" === a.split(\" \", 2)[1];\n    };\n\n    f.parseMLine = function (a) {\n      a = f.splitLines(a)[0].substr(2).split(\" \");\n      return {\n        kind: a[0],\n        port: pa(a[1], 10),\n        protocol: a[2],\n        fmt: Ha(a).call(a, 3).join(\" \")\n      };\n    };\n\n    f.parseOLine = function (a) {\n      a = f.matchPrefix(a, \"o=\")[0].substr(2).split(\" \");\n      return {\n        username: a[0],\n        sessionId: a[1],\n        sessionVersion: pa(a[2], 10),\n        netType: a[3],\n        addressType: a[4],\n        address: a[5]\n      };\n    };\n\n    f.isValidSDP = function (a) {\n      if (\"string\" != typeof a || 0 === a.length) return !1;\n      a = f.splitLines(a);\n\n      for (var b = 0; b < a.length; b++) if (2 > a[b].length || \"=\" !== a[b].charAt(1)) return !1;\n\n      return !0;\n    };\n\n    d.exports = f;\n  }),\n      fl = function (d, f) {\n    function a(a, b) {\n      b.addTrack(a);\n      b.dispatchEvent(new d.MediaStreamTrackEvent(\"addtrack\", {\n        track: a\n      }));\n    }\n\n    function b(a, b, c, e) {\n      var g = new Event(\"track\");\n      g.track = b;\n      g.receiver = c;\n      g.transceiver = {\n        receiver: c\n      };\n      g.streams = e;\n      d.setTimeout(function () {\n        a._dispatchEvent(\"track\", g);\n      });\n    }\n\n    var c = function (a) {\n      var b = this,\n          c = document.createDocumentFragment();\n      if ([\"addEventListener\", \"removeEventListener\", \"dispatchEvent\"].forEach(function (a) {\n        b[a] = c[a].bind(c);\n      }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = \"stable\", this.iceConnectionState = \"new\", this.connectionState = \"new\", this.iceGatheringState = \"new\", a = JSON.parse(JSON.stringify(a || {})), this.usingBundle = \"max-bundle\" === a.bundlePolicy, \"negotiate\" === a.rtcpMuxPolicy) throw Ja(\"NotSupportedError\", \"rtcpMuxPolicy 'negotiate' is not supported\");\n\n      switch (a.rtcpMuxPolicy || (a.rtcpMuxPolicy = \"require\"), a.iceTransportPolicy) {\n        case \"all\":\n        case \"relay\":\n          break;\n\n        default:\n          a.iceTransportPolicy = \"all\";\n      }\n\n      switch (a.bundlePolicy) {\n        case \"balanced\":\n        case \"max-compat\":\n        case \"max-bundle\":\n          break;\n\n        default:\n          a.bundlePolicy = \"balanced\";\n      }\n\n      if (a.iceServers = function (a, b) {\n        var d = !1;\n        return (a = JSON.parse(JSON.stringify(a))).filter(function (a) {\n          if (a && (a.urls || a.url)) {\n            var c = a.urls || a.url;\n            a.url && !a.urls && console.warn(\"RTCIceServer.url is deprecated! Use urls instead.\");\n            var e = \"string\" == typeof c;\n            return e && (c = [c]), c = c.filter(function (a) {\n              return 0 !== a.indexOf(\"turn:\") || -1 === a.indexOf(\"transport=udp\") || -1 !== a.indexOf(\"turn:[\") || d ? 0 === a.indexOf(\"stun:\") && 14393 <= b && -1 === a.indexOf(\"?transport=udp\") : (d = !0, !0);\n            }), delete a.url, a.urls = e ? c[0] : c, !!c.length;\n          }\n        });\n      }(a.iceServers || [], f), this._iceGatherers = [], a.iceCandidatePoolSize) for (var e = a.iceCandidatePoolSize; 0 < e; e--) this._iceGatherers.push(new d.RTCIceGatherer({\n        iceServers: a.iceServers,\n        gatherPolicy: a.iceTransportPolicy\n      }));else a.iceCandidatePoolSize = 0;\n      this._config = a;\n      this.transceivers = [];\n      this._sdpSessionId = G.generateSessionId();\n      this._sdpSessionVersion = 0;\n      this._dtlsRole = void 0;\n      this._isClosed = !1;\n    };\n\n    Object.defineProperty(c.prototype, \"localDescription\", {\n      configurable: !0,\n      get: function () {\n        return this._localDescription;\n      }\n    });\n    Object.defineProperty(c.prototype, \"remoteDescription\", {\n      configurable: !0,\n      get: function () {\n        return this._remoteDescription;\n      }\n    });\n    c.prototype.onicecandidate = null;\n    c.prototype.onaddstream = null;\n    c.prototype.ontrack = null;\n    c.prototype.onremovestream = null;\n    c.prototype.onsignalingstatechange = null;\n    c.prototype.oniceconnectionstatechange = null;\n    c.prototype.onconnectionstatechange = null;\n    c.prototype.onicegatheringstatechange = null;\n    c.prototype.onnegotiationneeded = null;\n    c.prototype.ondatachannel = null;\n\n    c.prototype._dispatchEvent = function (a, b) {\n      this._isClosed || (this.dispatchEvent(b), \"function\" == typeof this[\"on\" + a] && this[\"on\" + a](b));\n    };\n\n    c.prototype._emitGatheringStateChange = function () {\n      var a = new Event(\"icegatheringstatechange\");\n\n      this._dispatchEvent(\"icegatheringstatechange\", a);\n    };\n\n    c.prototype.getConfiguration = function () {\n      return this._config;\n    };\n\n    c.prototype.getLocalStreams = function () {\n      return this.localStreams;\n    };\n\n    c.prototype.getRemoteStreams = function () {\n      return this.remoteStreams;\n    };\n\n    c.prototype._createTransceiver = function (a, b) {\n      var d = 0 < this.transceivers.length;\n      a = {\n        track: null,\n        iceGatherer: null,\n        iceTransport: null,\n        dtlsTransport: null,\n        localCapabilities: null,\n        remoteCapabilities: null,\n        rtpSender: null,\n        rtpReceiver: null,\n        kind: a,\n        mid: null,\n        sendEncodingParameters: null,\n        recvEncodingParameters: null,\n        stream: null,\n        associatedRemoteMediaStreams: [],\n        wantReceive: !0\n      };\n      this.usingBundle && d ? (a.iceTransport = this.transceivers[0].iceTransport, a.dtlsTransport = this.transceivers[0].dtlsTransport) : (d = this._createIceAndDtlsTransports(), a.iceTransport = d.iceTransport, a.dtlsTransport = d.dtlsTransport);\n      return b || this.transceivers.push(a), a;\n    };\n\n    c.prototype.addTrack = function (a, b) {\n      if (this._isClosed) throw Ja(\"InvalidStateError\", \"Attempted to call addTrack on a closed peerconnection.\");\n      var c;\n      if (this.transceivers.find(function (b) {\n        return b.track === a;\n      })) throw Ja(\"InvalidAccessError\", \"Track already exists.\");\n\n      for (var e = 0; e < this.transceivers.length; e++) this.transceivers[e].track || this.transceivers[e].kind !== a.kind || (c = this.transceivers[e]);\n\n      return c || (c = this._createTransceiver(a.kind)), this._maybeFireNegotiationNeeded(), -1 === this.localStreams.indexOf(b) && this.localStreams.push(b), c.track = a, c.stream = b, c.rtpSender = new d.RTCRtpSender(a, c.dtlsTransport), c.rtpSender;\n    };\n\n    c.prototype.addStream = function (a) {\n      var b = this;\n      if (15025 <= f) a.getTracks().forEach(function (d) {\n        b.addTrack(d, a);\n      });else {\n        var d = a.clone();\n        a.getTracks().forEach(function (a, b) {\n          var c = d.getTracks()[b];\n          a.addEventListener(\"enabled\", function (a) {\n            c.enabled = a.enabled;\n          });\n        });\n        d.getTracks().forEach(function (a) {\n          b.addTrack(a, d);\n        });\n      }\n    };\n\n    c.prototype.removeTrack = function (a) {\n      if (this._isClosed) throw Ja(\"InvalidStateError\", \"Attempted to call removeTrack on a closed peerconnection.\");\n      if (!(a instanceof d.RTCRtpSender)) throw new TypeError(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\");\n      var b = this.transceivers.find(function (b) {\n        return b.rtpSender === a;\n      });\n      if (!b) throw Ja(\"InvalidAccessError\", \"Sender was not created by this connection.\");\n      var c = b.stream;\n      b.rtpSender.stop();\n      b.rtpSender = null;\n      b.track = null;\n      b.stream = null;\n      -1 === this.transceivers.map(function (a) {\n        return a.stream;\n      }).indexOf(c) && -1 < this.localStreams.indexOf(c) && this.localStreams.splice(this.localStreams.indexOf(c), 1);\n\n      this._maybeFireNegotiationNeeded();\n    };\n\n    c.prototype.removeStream = function (a) {\n      var b = this;\n      a.getTracks().forEach(function (a) {\n        var d = b.getSenders().find(function (b) {\n          return b.track === a;\n        });\n        d && b.removeTrack(d);\n      });\n    };\n\n    c.prototype.getSenders = function () {\n      return this.transceivers.filter(function (a) {\n        return !!a.rtpSender;\n      }).map(function (a) {\n        return a.rtpSender;\n      });\n    };\n\n    c.prototype.getReceivers = function () {\n      return this.transceivers.filter(function (a) {\n        return !!a.rtpReceiver;\n      }).map(function (a) {\n        return a.rtpReceiver;\n      });\n    };\n\n    c.prototype._createIceGatherer = function (a, b) {\n      var c = this;\n      if (b && 0 < a) return this.transceivers[0].iceGatherer;\n      if (this._iceGatherers.length) return this._iceGatherers.shift();\n      var e = new d.RTCIceGatherer({\n        iceServers: this._config.iceServers,\n        gatherPolicy: this._config.iceTransportPolicy\n      });\n      return Object.defineProperty(e, \"state\", {\n        value: \"new\",\n        writable: !0\n      }), this.transceivers[a].bufferedCandidateEvents = [], this.transceivers[a].bufferCandidates = function (b) {\n        var d = !b.candidate || 0 === Object.keys(b.candidate).length;\n        e.state = d ? \"completed\" : \"gathering\";\n        null !== c.transceivers[a].bufferedCandidateEvents && c.transceivers[a].bufferedCandidateEvents.push(b);\n      }, e.addEventListener(\"localcandidate\", this.transceivers[a].bufferCandidates), e;\n    };\n\n    c.prototype._gather = function (a, b) {\n      var c = this,\n          e = this.transceivers[b].iceGatherer;\n\n      if (!e.onlocalcandidate) {\n        var g = this.transceivers[b].bufferedCandidateEvents;\n        this.transceivers[b].bufferedCandidateEvents = null;\n        e.removeEventListener(\"localcandidate\", this.transceivers[b].bufferCandidates);\n\n        e.onlocalcandidate = function (d) {\n          if (!(c.usingBundle && 0 < b)) {\n            var g = new Event(\"icecandidate\");\n            g.candidate = {\n              sdpMid: a,\n              sdpMLineIndex: b\n            };\n            var h = d.candidate;\n            (d = !h || 0 === Object.keys(h).length) ? \"new\" !== e.state && \"gathering\" !== e.state || (e.state = \"completed\") : (\"new\" === e.state && (e.state = \"gathering\"), h.component = 1, h.ufrag = e.getLocalParameters().usernameFragment, h = G.writeCandidate(h), g.candidate = Object.assign(g.candidate, G.parseCandidate(h)), g.candidate.candidate = h, g.candidate.toJSON = function () {\n              return {\n                candidate: g.candidate.candidate,\n                sdpMid: g.candidate.sdpMid,\n                sdpMLineIndex: g.candidate.sdpMLineIndex,\n                usernameFragment: g.candidate.usernameFragment\n              };\n            });\n            h = G.getMediaSections(c._localDescription.sdp);\n            h[g.candidate.sdpMLineIndex] += d ? \"a=end-of-candidates\\r\\n\" : \"a=\" + g.candidate.candidate + \"\\r\\n\";\n            c._localDescription.sdp = G.getDescription(c._localDescription.sdp) + h.join(\"\");\n            h = c.transceivers.every(function (a) {\n              return a.iceGatherer && \"completed\" === a.iceGatherer.state;\n            });\n            \"gathering\" !== c.iceGatheringState && (c.iceGatheringState = \"gathering\", c._emitGatheringStateChange());\n            d || c._dispatchEvent(\"icecandidate\", g);\n            h && (c._dispatchEvent(\"icecandidate\", new Event(\"icecandidate\")), c.iceGatheringState = \"complete\", c._emitGatheringStateChange());\n          }\n        };\n\n        d.setTimeout(function () {\n          g.forEach(function (a) {\n            e.onlocalcandidate(a);\n          });\n        }, 0);\n      }\n    };\n\n    c.prototype._createIceAndDtlsTransports = function () {\n      var a = this,\n          b = new d.RTCIceTransport(null);\n\n      b.onicestatechange = function () {\n        a._updateIceConnectionState();\n\n        a._updateConnectionState();\n      };\n\n      var c = new d.RTCDtlsTransport(b);\n      return c.ondtlsstatechange = function () {\n        a._updateConnectionState();\n      }, c.onerror = function () {\n        Object.defineProperty(c, \"state\", {\n          value: \"failed\",\n          writable: !0\n        });\n\n        a._updateConnectionState();\n      }, {\n        iceTransport: b,\n        dtlsTransport: c\n      };\n    };\n\n    c.prototype._disposeIceAndDtlsTransports = function (a) {\n      var b = this.transceivers[a].iceGatherer;\n      b && (delete b.onlocalcandidate, delete this.transceivers[a].iceGatherer);\n      (b = this.transceivers[a].iceTransport) && (delete b.onicestatechange, delete this.transceivers[a].iceTransport);\n      (b = this.transceivers[a].dtlsTransport) && (delete b.ondtlsstatechange, delete b.onerror, delete this.transceivers[a].dtlsTransport);\n    };\n\n    c.prototype._transceive = function (a, b, d) {\n      var c = rd(a.localCapabilities, a.remoteCapabilities);\n      b && a.rtpSender && (c.encodings = a.sendEncodingParameters, c.rtcp = {\n        cname: G.localCName,\n        compound: a.rtcpParameters.compound\n      }, a.recvEncodingParameters.length && (c.rtcp.ssrc = a.recvEncodingParameters[0].ssrc), a.rtpSender.send(c));\n      d && a.rtpReceiver && 0 < c.codecs.length && (\"video\" === a.kind && a.recvEncodingParameters && 15019 > f && a.recvEncodingParameters.forEach(function (a) {\n        delete a.rtx;\n      }), a.recvEncodingParameters.length ? c.encodings = a.recvEncodingParameters : c.encodings = [{}], c.rtcp = {\n        compound: a.rtcpParameters.compound\n      }, a.rtcpParameters.cname && (c.rtcp.cname = a.rtcpParameters.cname), a.sendEncodingParameters.length && (c.rtcp.ssrc = a.sendEncodingParameters[0].ssrc), a.rtpReceiver.receive(c));\n    };\n\n    c.prototype.setLocalDescription = function (a) {\n      var b = this;\n      if (-1 === [\"offer\", \"answer\"].indexOf(a.type)) return Promise.reject(Ja(\"TypeError\", 'Unsupported type \"' + a.type + '\"'));\n      if (!Bg(\"setLocalDescription\", a.type, b.signalingState) || b._isClosed) return Promise.reject(Ja(\"InvalidStateError\", \"Can not set local \" + a.type + \" in state \" + b.signalingState));\n\n      if (\"offer\" === a.type) {\n        var d = G.splitSections(a.sdp);\n        var c = d.shift();\n        d.forEach(function (a, d) {\n          a = G.parseRtpParameters(a);\n          b.transceivers[d].localCapabilities = a;\n        });\n        b.transceivers.forEach(function (a, d) {\n          b._gather(a.mid, d);\n        });\n      } else if (\"answer\" === a.type) {\n        d = G.splitSections(b._remoteDescription.sdp);\n        c = d.shift();\n        var e = 0 < G.matchPrefix(c, \"a=ice-lite\").length;\n        d.forEach(function (a, d) {\n          var g = b.transceivers[d],\n              f = g.iceGatherer,\n              h = g.iceTransport,\n              p = g.dtlsTransport,\n              r = g.localCapabilities,\n              k = g.remoteCapabilities;\n\n          if (!(G.isRejected(a) && 0 === G.matchPrefix(a, \"a=bundle-only\").length || g.rejected)) {\n            var t = G.getIceParameters(a, c);\n            a = G.getDtlsParameters(a, c);\n            e && (a.role = \"server\");\n            b.usingBundle && 0 !== d || (b._gather(g.mid, d), \"new\" === h.state && h.start(f, t, e ? \"controlling\" : \"controlled\"), \"new\" === p.state && p.start(a));\n            d = rd(r, k);\n\n            b._transceive(g, 0 < d.codecs.length, !1);\n          }\n        });\n      }\n\n      return b._localDescription = {\n        type: a.type,\n        sdp: a.sdp\n      }, \"offer\" === a.type ? b._updateSignalingState(\"have-local-offer\") : b._updateSignalingState(\"stable\"), Promise.resolve();\n    };\n\n    c.prototype.setRemoteDescription = function (c) {\n      var e = this;\n      if (-1 === [\"offer\", \"answer\"].indexOf(c.type)) return Promise.reject(Ja(\"TypeError\", 'Unsupported type \"' + c.type + '\"'));\n      if (!Bg(\"setRemoteDescription\", c.type, e.signalingState) || e._isClosed) return Promise.reject(Ja(\"InvalidStateError\", \"Can not set remote \" + c.type + \" in state \" + e.signalingState));\n      var g = {};\n      e.remoteStreams.forEach(function (a) {\n        g[a.id] = a;\n      });\n      var r = [],\n          k = G.splitSections(c.sdp),\n          y = k.shift(),\n          l = 0 < G.matchPrefix(y, \"a=ice-lite\").length,\n          m = 0 < G.matchPrefix(y, \"a=group:BUNDLE \").length;\n      e.usingBundle = m;\n      var n = G.matchPrefix(y, \"a=ice-options:\")[0];\n      return e.canTrickleIceCandidates = !!n && 0 <= n.substr(14).split(\" \").indexOf(\"trickle\"), k.forEach(function (b, h) {\n        var p = G.splitLines(b),\n            k = G.getKind(b),\n            t = G.isRejected(b) && 0 === G.matchPrefix(b, \"a=bundle-only\").length,\n            n = p[0].substr(2).split(\" \")[2];\n        p = G.getDirection(b, y);\n        var D = G.parseMsid(b),\n            ua = G.getMid(b) || G.generateIdentifier();\n        if (t || \"application\" === k && (\"DTLS/SCTP\" === n || \"UDP/DTLS/SCTP\" === n)) e.transceivers[h] = {\n          mid: ua,\n          kind: k,\n          protocol: n,\n          rejected: !0\n        };else {\n          var z, q;\n          !t && e.transceivers[h] && e.transceivers[h].rejected && (e.transceivers[h] = e._createTransceiver(k, !0));\n          var u,\n              Wb,\n              ka = G.parseRtpParameters(b);\n          t || (u = G.getIceParameters(b, y), (Wb = G.getDtlsParameters(b, y)).role = \"client\");\n          n = G.parseRtpEncodingParameters(b);\n          var v = G.parseRtcpParameters(b),\n              x = 0 < G.matchPrefix(b, \"a=end-of-candidates\", y).length;\n          b = G.matchPrefix(b, \"a=candidate:\").map(function (a) {\n            return G.parseCandidate(a);\n          }).filter(function (a) {\n            return 1 === a.component;\n          });\n\n          if ((\"offer\" === c.type || \"answer\" === c.type) && !t && m && 0 < h && e.transceivers[h] && (e._disposeIceAndDtlsTransports(h), e.transceivers[h].iceGatherer = e.transceivers[0].iceGatherer, e.transceivers[h].iceTransport = e.transceivers[0].iceTransport, e.transceivers[h].dtlsTransport = e.transceivers[0].dtlsTransport, e.transceivers[h].rtpSender && e.transceivers[h].rtpSender.setTransport(e.transceivers[0].dtlsTransport), e.transceivers[h].rtpReceiver && e.transceivers[h].rtpReceiver.setTransport(e.transceivers[0].dtlsTransport)), \"offer\" !== c.type || t) {\n            if (\"answer\" === c.type && !t) {\n              k = (z = e.transceivers[h]).iceGatherer;\n              var w = z.iceTransport;\n              var A = z.dtlsTransport;\n              var B = z.rtpReceiver;\n              t = z.sendEncodingParameters;\n              ua = z.localCapabilities;\n              e.transceivers[h].recvEncodingParameters = n;\n              e.transceivers[h].remoteCapabilities = ka;\n              e.transceivers[h].rtcpParameters = v;\n              b.length && \"new\" === w.state && (!l && !x || m && 0 !== h ? b.forEach(function (a) {\n                te(z.iceTransport, a);\n              }) : w.setRemoteCandidates(b));\n              m && 0 !== h || (\"new\" === w.state && w.start(k, u, \"controlling\"), \"new\" === A.state && A.start(Wb));\n              !rd(z.localCapabilities, z.remoteCapabilities).codecs.filter(function (a) {\n                return \"rtx\" === a.name.toLowerCase();\n              }).length && z.sendEncodingParameters[0].rtx && delete z.sendEncodingParameters[0].rtx;\n\n              e._transceive(z, \"sendrecv\" === p || \"recvonly\" === p, \"sendrecv\" === p || \"sendonly\" === p);\n\n              !B || \"sendrecv\" !== p && \"sendonly\" !== p ? delete z.rtpReceiver : (q = B.track, D ? (g[D.stream] || (g[D.stream] = new d.MediaStream()), a(q, g[D.stream]), r.push([q, B, g[D.stream]])) : (g.default || (g.default = new d.MediaStream()), a(q, g.default), r.push([q, B, g.default])));\n            }\n          } else {\n            (z = e.transceivers[h] || e._createTransceiver(k)).mid = ua;\n            z.iceGatherer || (z.iceGatherer = e._createIceGatherer(h, m));\n            b.length && \"new\" === z.iceTransport.state && (!x || m && 0 !== h ? b.forEach(function (a) {\n              te(z.iceTransport, a);\n            }) : z.iceTransport.setRemoteCandidates(b));\n            ua = d.RTCRtpReceiver.getCapabilities(k);\n            15019 > f && (ua.codecs = ua.codecs.filter(function (a) {\n              return \"rtx\" !== a.name;\n            }));\n            t = z.sendEncodingParameters || [{\n              ssrc: 1001 * (2 * h + 2)\n            }];\n            u = !1;\n\n            if (\"sendrecv\" === p || \"sendonly\" === p) {\n              if (u = !z.rtpReceiver, B = z.rtpReceiver || new d.RTCRtpReceiver(z.dtlsTransport, k), u) q = B.track, D && \"-\" === D.stream || (D ? (g[D.stream] || (g[D.stream] = new d.MediaStream(), Object.defineProperty(g[D.stream], \"id\", {\n                get: function () {\n                  return D.stream;\n                }\n              })), Object.defineProperty(q, \"id\", {\n                get: function () {\n                  return D.track;\n                }\n              }), w = g[D.stream]) : (g.default || (g.default = new d.MediaStream()), w = g.default)), w && (a(q, w), z.associatedRemoteMediaStreams.push(w)), r.push([q, B, w]);\n            } else z.rtpReceiver && z.rtpReceiver.track && (z.associatedRemoteMediaStreams.forEach(function (a) {\n              var b = a.getTracks().find(function (a) {\n                return a.id === z.rtpReceiver.track.id;\n              });\n              b && function (a, b) {\n                b.removeTrack(a);\n                b.dispatchEvent(new d.MediaStreamTrackEvent(\"removetrack\", {\n                  track: a\n                }));\n              }(b, a);\n            }), z.associatedRemoteMediaStreams = []);\n\n            z.localCapabilities = ua;\n            z.remoteCapabilities = ka;\n            z.rtpReceiver = B;\n            z.rtcpParameters = v;\n            z.sendEncodingParameters = t;\n            z.recvEncodingParameters = n;\n\n            e._transceive(e.transceivers[h], !1, u);\n          }\n        }\n      }), void 0 === e._dtlsRole && (e._dtlsRole = \"offer\" === c.type ? \"active\" : \"passive\"), e._remoteDescription = {\n        type: c.type,\n        sdp: c.sdp\n      }, \"offer\" === c.type ? e._updateSignalingState(\"have-remote-offer\") : e._updateSignalingState(\"stable\"), Object.keys(g).forEach(function (a) {\n        var c = g[a];\n\n        if (c.getTracks().length) {\n          if (-1 === e.remoteStreams.indexOf(c)) {\n            e.remoteStreams.push(c);\n            var f = new Event(\"addstream\");\n            f.stream = c;\n            d.setTimeout(function () {\n              e._dispatchEvent(\"addstream\", f);\n            });\n          }\n\n          r.forEach(function (a) {\n            var d = a[0],\n                g = a[1];\n            c.id === a[2].id && b(e, d, g, [c]);\n          });\n        }\n      }), r.forEach(function (a) {\n        a[2] || b(e, a[0], a[1], []);\n      }), d.setTimeout(function () {\n        e && e.transceivers && e.transceivers.forEach(function (a) {\n          a.iceTransport && \"new\" === a.iceTransport.state && 0 < a.iceTransport.getRemoteCandidates().length && (console.warn(\"Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification\"), a.iceTransport.addRemoteCandidate({}));\n        });\n      }, 4E3), Promise.resolve();\n    };\n\n    c.prototype.close = function () {\n      this.transceivers.forEach(function (a) {\n        a.iceTransport && a.iceTransport.stop();\n        a.dtlsTransport && a.dtlsTransport.stop();\n        a.rtpSender && a.rtpSender.stop();\n        a.rtpReceiver && a.rtpReceiver.stop();\n      });\n      this._isClosed = !0;\n\n      this._updateSignalingState(\"closed\");\n    };\n\n    c.prototype._updateSignalingState = function (a) {\n      this.signalingState = a;\n      a = new Event(\"signalingstatechange\");\n\n      this._dispatchEvent(\"signalingstatechange\", a);\n    };\n\n    c.prototype._maybeFireNegotiationNeeded = function () {\n      var a = this;\n      \"stable\" === this.signalingState && !0 !== this.needNegotiation && (this.needNegotiation = !0, d.setTimeout(function () {\n        if (a.needNegotiation) {\n          a.needNegotiation = !1;\n          var b = new Event(\"negotiationneeded\");\n\n          a._dispatchEvent(\"negotiationneeded\", b);\n        }\n      }, 0));\n    };\n\n    c.prototype._updateIceConnectionState = function () {\n      var a,\n          b = {\n        new: 0,\n        closed: 0,\n        checking: 0,\n        connected: 0,\n        completed: 0,\n        disconnected: 0,\n        failed: 0\n      };\n      if (this.transceivers.forEach(function (a) {\n        a.iceTransport && !a.rejected && b[a.iceTransport.state]++;\n      }), a = \"new\", 0 < b.failed ? a = \"failed\" : 0 < b.checking ? a = \"checking\" : 0 < b.disconnected ? a = \"disconnected\" : 0 < b.new ? a = \"new\" : 0 < b.connected ? a = \"connected\" : 0 < b.completed && (a = \"completed\"), a !== this.iceConnectionState) this.iceConnectionState = a, a = new Event(\"iceconnectionstatechange\"), this._dispatchEvent(\"iceconnectionstatechange\", a);\n    };\n\n    c.prototype._updateConnectionState = function () {\n      var a,\n          b = {\n        new: 0,\n        closed: 0,\n        connecting: 0,\n        connected: 0,\n        completed: 0,\n        disconnected: 0,\n        failed: 0\n      };\n      if (this.transceivers.forEach(function (a) {\n        a.iceTransport && a.dtlsTransport && !a.rejected && (b[a.iceTransport.state]++, b[a.dtlsTransport.state]++);\n      }), b.connected += b.completed, a = \"new\", 0 < b.failed ? a = \"failed\" : 0 < b.connecting ? a = \"connecting\" : 0 < b.disconnected ? a = \"disconnected\" : 0 < b.new ? a = \"new\" : 0 < b.connected && (a = \"connected\"), a !== this.connectionState) this.connectionState = a, a = new Event(\"connectionstatechange\"), this._dispatchEvent(\"connectionstatechange\", a);\n    };\n\n    c.prototype.createOffer = function (a) {\n      var b = this;\n      if (b._isClosed) return Promise.reject(Ja(\"InvalidStateError\", \"Can not call createOffer after close\"));\n      var c = b.transceivers.filter(function (a) {\n        return \"audio\" === a.kind;\n      }).length,\n          e = b.transceivers.filter(function (a) {\n        return \"video\" === a.kind;\n      }).length;\n\n      if (a) {\n        if (a.mandatory || a.optional) throw new TypeError(\"Legacy mandatory/optional constraints not supported.\");\n        void 0 !== a.offerToReceiveAudio && (c = !0 === a.offerToReceiveAudio ? 1 : !1 === a.offerToReceiveAudio ? 0 : a.offerToReceiveAudio);\n        void 0 !== a.offerToReceiveVideo && (e = !0 === a.offerToReceiveVideo ? 1 : !1 === a.offerToReceiveVideo ? 0 : a.offerToReceiveVideo);\n      }\n\n      for (b.transceivers.forEach(function (a) {\n        \"audio\" === a.kind ? 0 > --c && (a.wantReceive = !1) : \"video\" === a.kind && 0 > --e && (a.wantReceive = !1);\n      }); 0 < c || 0 < e;) 0 < c && (b._createTransceiver(\"audio\"), c--), 0 < e && (b._createTransceiver(\"video\"), e--);\n\n      var g = G.writeSessionBoilerplate(b._sdpSessionId, b._sdpSessionVersion++);\n      b.transceivers.forEach(function (a, c) {\n        var e = a.track,\n            g = a.kind,\n            h = a.mid || G.generateIdentifier();\n        a.mid = h;\n        a.iceGatherer || (a.iceGatherer = b._createIceGatherer(c, b.usingBundle));\n        h = d.RTCRtpSender.getCapabilities(g);\n        15019 > f && (h.codecs = h.codecs.filter(function (a) {\n          return \"rtx\" !== a.name;\n        }));\n        h.codecs.forEach(function (b) {\n          \"H264\" === b.name && void 0 === b.parameters[\"level-asymmetry-allowed\"] && (b.parameters[\"level-asymmetry-allowed\"] = \"1\");\n          a.remoteCapabilities && a.remoteCapabilities.codecs && a.remoteCapabilities.codecs.forEach(function (a) {\n            b.name.toLowerCase() === a.name.toLowerCase() && b.clockRate === a.clockRate && (b.preferredPayloadType = a.payloadType);\n          });\n        });\n        h.headerExtensions.forEach(function (b) {\n          (a.remoteCapabilities && a.remoteCapabilities.headerExtensions || []).forEach(function (a) {\n            b.uri === a.uri && (b.id = a.id);\n          });\n        });\n        c = a.sendEncodingParameters || [{\n          ssrc: 1001 * (2 * c + 1)\n        }];\n        e && 15019 <= f && \"video\" === g && !c[0].rtx && (c[0].rtx = {\n          ssrc: c[0].ssrc + 1\n        });\n        a.wantReceive && (a.rtpReceiver = new d.RTCRtpReceiver(a.dtlsTransport, g));\n        a.localCapabilities = h;\n        a.sendEncodingParameters = c;\n      });\n      \"max-compat\" !== b._config.bundlePolicy && (g += \"a=group:BUNDLE \" + b.transceivers.map(function (a) {\n        return a.mid;\n      }).join(\" \") + \"\\r\\n\");\n      g += \"a=ice-options:trickle\\r\\n\";\n      b.transceivers.forEach(function (a, c) {\n        g += Ag(a, a.localCapabilities, \"offer\", a.stream, b._dtlsRole);\n        g += \"a=rtcp-rsize\\r\\n\";\n        !a.iceGatherer || \"new\" === b.iceGatheringState || 0 !== c && b.usingBundle || (a.iceGatherer.getLocalCandidates().forEach(function (a) {\n          a.component = 1;\n          g += \"a=\" + G.writeCandidate(a) + \"\\r\\n\";\n        }), \"completed\" === a.iceGatherer.state && (g += \"a=end-of-candidates\\r\\n\"));\n      });\n      a = new d.RTCSessionDescription({\n        type: \"offer\",\n        sdp: g\n      });\n      return Promise.resolve(a);\n    };\n\n    c.prototype.createAnswer = function () {\n      var a = this;\n      if (a._isClosed) return Promise.reject(Ja(\"InvalidStateError\", \"Can not call createAnswer after close\"));\n      if (\"have-remote-offer\" !== a.signalingState && \"have-local-pranswer\" !== a.signalingState) return Promise.reject(Ja(\"InvalidStateError\", \"Can not call createAnswer in signalingState \" + a.signalingState));\n      var b = G.writeSessionBoilerplate(a._sdpSessionId, a._sdpSessionVersion++);\n      a.usingBundle && (b += \"a=group:BUNDLE \" + a.transceivers.map(function (a) {\n        return a.mid;\n      }).join(\" \") + \"\\r\\n\");\n      b += \"a=ice-options:trickle\\r\\n\";\n      var c = G.getMediaSections(a._remoteDescription.sdp).length;\n      a.transceivers.forEach(function (d, e) {\n        if (!(e + 1 > c)) {\n          if (d.rejected) return \"application\" === d.kind ? \"DTLS/SCTP\" === d.protocol ? b += \"m=application 0 DTLS/SCTP 5000\\r\\n\" : b += \"m=application 0 \" + d.protocol + \" webrtc-datachannel\\r\\n\" : \"audio\" === d.kind ? b += \"m=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\na=rtpmap:0 PCMU/8000\\r\\n\" : \"video\" === d.kind && (b += \"m=video 0 UDP/TLS/RTP/SAVPF 120\\r\\na=rtpmap:120 VP8/90000\\r\\n\"), void (b += \"c=IN IP4 0.0.0.0\\r\\na=inactive\\r\\na=mid:\" + d.mid + \"\\r\\n\");\n          var g;\n          d.stream && (\"audio\" === d.kind ? g = d.stream.getAudioTracks()[0] : \"video\" === d.kind && (g = d.stream.getVideoTracks()[0]), g && 15019 <= f && \"video\" === d.kind && !d.sendEncodingParameters[0].rtx && (d.sendEncodingParameters[0].rtx = {\n            ssrc: d.sendEncodingParameters[0].ssrc + 1\n          }));\n          e = rd(d.localCapabilities, d.remoteCapabilities);\n          !e.codecs.filter(function (a) {\n            return \"rtx\" === a.name.toLowerCase();\n          }).length && d.sendEncodingParameters[0].rtx && delete d.sendEncodingParameters[0].rtx;\n          b += Ag(d, e, \"answer\", d.stream, a._dtlsRole);\n          d.rtcpParameters && d.rtcpParameters.reducedSize && (b += \"a=rtcp-rsize\\r\\n\");\n        }\n      });\n      var e = new d.RTCSessionDescription({\n        type: \"answer\",\n        sdp: b\n      });\n      return Promise.resolve(e);\n    };\n\n    c.prototype.addIceCandidate = function (a) {\n      var b,\n          d = this;\n      return a && void 0 === a.sdpMLineIndex && !a.sdpMid ? Promise.reject(new TypeError(\"sdpMLineIndex or sdpMid required\")) : new Promise(function (c, e) {\n        if (!d._remoteDescription) return e(Ja(\"InvalidStateError\", \"Can not add ICE candidate without a remote description\"));\n\n        if (a && \"\" !== a.candidate) {\n          var g = a.sdpMLineIndex;\n          if (a.sdpMid) for (var f = 0; f < d.transceivers.length; f++) if (d.transceivers[f].mid === a.sdpMid) {\n            g = f;\n            break;\n          }\n          var h = d.transceivers[g];\n          if (!h) return e(Ja(\"OperationError\", \"Can not add ICE candidate\"));\n          if (h.rejected) return c();\n          f = 0 < Object.keys(a.candidate).length ? G.parseCandidate(a.candidate) : {};\n          if (\"tcp\" === f.protocol && (0 === f.port || 9 === f.port) || f.component && 1 !== f.component) return c();\n          if ((0 === g || 0 < g && h.iceTransport !== d.transceivers[0].iceTransport) && !te(h.iceTransport, f)) return e(Ja(\"OperationError\", \"Can not add ICE candidate\"));\n          e = a.candidate.trim();\n          0 === e.indexOf(\"a=\") && (e = e.substr(2));\n          (b = G.getMediaSections(d._remoteDescription.sdp))[g] += \"a=\" + (f.type ? e : \"end-of-candidates\") + \"\\r\\n\";\n          d._remoteDescription.sdp = G.getDescription(d._remoteDescription.sdp) + b.join(\"\");\n        } else for (g = 0; g < d.transceivers.length && (d.transceivers[g].rejected || (d.transceivers[g].iceTransport.addRemoteCandidate({}), (b = G.getMediaSections(d._remoteDescription.sdp))[g] += \"a=end-of-candidates\\r\\n\", d._remoteDescription.sdp = G.getDescription(d._remoteDescription.sdp) + b.join(\"\"), !d.usingBundle)); g++);\n\n        c();\n      });\n    };\n\n    c.prototype.getStats = function (a) {\n      if (a && a instanceof d.MediaStreamTrack) {\n        var b = null;\n        if (this.transceivers.forEach(function (d) {\n          d.rtpSender && d.rtpSender.track === a ? b = d.rtpSender : d.rtpReceiver && d.rtpReceiver.track === a && (b = d.rtpReceiver);\n        }), !b) throw Ja(\"InvalidAccessError\", \"Invalid selector.\");\n        return b.getStats();\n      }\n\n      var c = [];\n      return this.transceivers.forEach(function (a) {\n        [\"rtpSender\", \"rtpReceiver\", \"iceGatherer\", \"iceTransport\", \"dtlsTransport\"].forEach(function (b) {\n          a[b] && c.push(a[b].getStats());\n        });\n      }), Promise.all(c).then(function (a) {\n        var b = new Map();\n        return a.forEach(function (a) {\n          a.forEach(function (a) {\n            b.set(a.id, a);\n          });\n        }), b;\n      });\n    };\n\n    [\"RTCRtpSender\", \"RTCRtpReceiver\", \"RTCIceGatherer\", \"RTCIceTransport\", \"RTCDtlsTransport\"].forEach(function (a) {\n      if ((a = d[a]) && a.prototype && a.prototype.getStats) {\n        var b = a.prototype.getStats;\n\n        a.prototype.getStats = function () {\n          return b.apply(this).then(function (a) {\n            var b = new Map();\n            return Object.keys(a).forEach(function (d) {\n              var c;\n              a[d].type = {\n                inboundrtp: \"inbound-rtp\",\n                outboundrtp: \"outbound-rtp\",\n                candidatepair: \"candidate-pair\",\n                localcandidate: \"local-candidate\",\n                remotecandidate: \"remote-candidate\"\n              }[(c = a[d]).type] || c.type;\n              b.set(d, a[d]);\n            }), b;\n          });\n        };\n      }\n    });\n    var e = [\"createOffer\", \"createAnswer\"];\n    return e.forEach(function (a) {\n      var b = c.prototype[a];\n\n      c.prototype[a] = function () {\n        var a = arguments;\n        return \"function\" == typeof a[0] || \"function\" == typeof a[1] ? b.apply(this, [arguments[2]]).then(function (b) {\n          \"function\" == typeof a[0] && a[0].apply(null, [b]);\n        }, function (b) {\n          \"function\" == typeof a[1] && a[1].apply(null, [b]);\n        }) : b.apply(this, arguments);\n      };\n    }), (e = [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"]).forEach(function (a) {\n      var b = c.prototype[a];\n\n      c.prototype[a] = function () {\n        var a = arguments;\n        return \"function\" == typeof a[1] || \"function\" == typeof a[2] ? b.apply(this, arguments).then(function () {\n          \"function\" == typeof a[1] && a[1].apply(null);\n        }, function (b) {\n          \"function\" == typeof a[2] && a[2].apply(null, [b]);\n        }) : b.apply(this, arguments);\n      };\n    }), [\"getStats\"].forEach(function (a) {\n      var b = c.prototype[a];\n\n      c.prototype[a] = function () {\n        var a = arguments;\n        return \"function\" == typeof a[1] ? b.apply(this, arguments).then(function () {\n          \"function\" == typeof a[1] && a[1].apply(null);\n        }) : b.apply(this, arguments);\n      };\n    }), c;\n  },\n      Sj = Object.freeze({\n    __proto__: null,\n    shimPeerConnection: ue,\n    shimReplaceTrack: Eg,\n    shimGetUserMedia: Cg,\n    shimGetDisplayMedia: Dg\n  }),\n      Tj = Object.freeze({\n    __proto__: null,\n    shimOnTrack: Gg,\n    shimPeerConnection: ve,\n    shimSenderGetStats: Hg,\n    shimReceiverGetStats: Ig,\n    shimRemoveStream: Jg,\n    shimRTCDataChannel: Kg,\n    shimGetUserMedia: Fg,\n    shimGetDisplayMedia: function (d, f) {\n      d.navigator.mediaDevices && \"getDisplayMedia\" in d.navigator.mediaDevices || d.navigator.mediaDevices && (d.navigator.mediaDevices.getDisplayMedia = function (a) {\n        return a && a.video ? (!0 === a.video ? a.video = {\n          mediaSource: f\n        } : a.video.mediaSource = f, d.navigator.mediaDevices.getUserMedia(a)) : (a = new DOMException(\"getDisplayMedia without video constraints is undefined\"), a.name = \"NotFoundError\", a.code = 8, A.reject(a));\n      });\n    }\n  }),\n      Uj = Object.freeze({\n    __proto__: null,\n    shimLocalStreamsAPI: Lg,\n    shimRemoteStreamsAPI: Mg,\n    shimCallbacksAPI: Ng,\n    shimGetUserMedia: Og,\n    shimConstraints: Pg,\n    shimRTCIceServerUrls: Qg,\n    shimTrackEventTransceiver: Rg,\n    shimCreateOfferLegacy: Sg\n  }),\n      Gn = Object.freeze({\n    __proto__: null,\n    shimRTCIceCandidate: td,\n    shimMaxMessageSize: Hc,\n    shimSendThrowTypeError: Ic,\n    shimConnectionState: we,\n    removeAllowExtmapMixed: xe\n  });\n\n  !function ({\n    window: d\n  } = {}, f = {\n    shimChrome: !0,\n    shimFirefox: !0,\n    shimEdge: !0,\n    shimSafari: !0\n  }) {\n    let a = Eb(d),\n        b = {\n      browserDetails: a,\n      commonShim: Gn,\n      extractVersion: Db,\n      disableLog: dl,\n      disableWarnings: el\n    };\n\n    switch (a.browser) {\n      case \"chrome\":\n        if (!Oj || !se || !f.shimChrome) return kb(\"Chrome shim is not included in this adapter release.\"), b;\n        kb(\"adapter.js shimming chrome.\");\n        b.browserShim = Oj;\n        pg(d);\n        sg(d);\n        se(d);\n        tg(d);\n        yg(d);\n        ug(d);\n        vg(d);\n        wg(d);\n        zg(d);\n        td(d);\n        we(d);\n        Hc(d);\n        Ic(d);\n        xe(d);\n        break;\n\n      case \"firefox\":\n        if (!Tj || !ve || !f.shimFirefox) return kb(\"Firefox shim is not included in this adapter release.\"), b;\n        kb(\"adapter.js shimming firefox.\");\n        b.browserShim = Tj;\n        Fg(d);\n        ve(d);\n        Gg(d);\n        Jg(d);\n        Hg(d);\n        Ig(d);\n        Kg(d);\n        td(d);\n        we(d);\n        Hc(d);\n        Ic(d);\n        break;\n\n      case \"edge\":\n        if (!Sj || !ue || !f.shimEdge) return kb(\"MS edge shim is not included in this adapter release.\"), b;\n        kb(\"adapter.js shimming edge.\");\n        b.browserShim = Sj;\n        Cg(d);\n        Dg(d);\n        ue(d);\n        Eg(d);\n        Hc(d);\n        Ic(d);\n        break;\n\n      case \"safari\":\n        if (!Uj || !f.shimSafari) return kb(\"Safari shim is not included in this adapter release.\"), b;\n        kb(\"adapter.js shimming safari.\");\n        b.browserShim = Uj;\n        Qg(d);\n        Sg(d);\n        Ng(d);\n        Lg(d);\n        Mg(d);\n        Rg(d);\n        Og(d);\n        td(d);\n        Hc(d);\n        Ic(d);\n        xe(d);\n        break;\n\n      default:\n        kb(\"Unsupported browser!\");\n    }\n  }({\n    window\n  });\n  var X, ca;\n  !function (d) {\n    d.WIN_10 = \"Windows 10\";\n    d.WIN_81 = \"Windows 8.1\";\n    d.WIN_8 = \"Windows 8\";\n    d.WIN_7 = \"Windows 7\";\n    d.WIN_VISTA = \"Windows Vista\";\n    d.WIN_SERVER_2003 = \"Windows Server 2003\";\n    d.WIN_XP = \"Windows XP\";\n    d.WIN_2000 = \"Windows 2000\";\n    d.ANDROID = \"Android\";\n    d.OPEN_BSD = \"Open BSD\";\n    d.SUN_OS = \"Sun OS\";\n    d.LINUX = \"Linux\";\n    d.IOS = \"iOS\";\n    d.MAC_OS_X = \"Mac OS X\";\n    d.MAC_OS = \"Mac OS\";\n    d.QNX = \"QNX\";\n    d.UNIX = \"UNIX\";\n    d.BEOS = \"BeOS\";\n    d.OS_2 = \"OS/2\";\n    d.SEARCH_BOT = \"Search Bot\";\n  }(X || (X = {}));\n\n  (function (d) {\n    d.CHROME = \"Chrome\";\n    d.SAFARI = \"Safari\";\n    d.EDGE = \"Edge\";\n    d.FIREFOX = \"Firefox\";\n    d.OPERA = \"OPR\";\n    d.QQ = \"QQBrowser\";\n    d.WECHAT = \"MicroMessenger\";\n  })(ca || (ca = {}));\n\n  let Ta = function (d) {\n    if (d.match(/[0-9]+\\.[0-9]+\\.[0-9]+$/)) return d;\n    var f = d.match(/([0-9]+\\.[0-9]+\\.[0-9]+)\\-alpha\\.([0-9]+)/);\n\n    if (f && f[1] && f[2]) {\n      var a,\n          b = f[2];\n      return m(a = \"\".concat(f[1], \".\")).call(a, b);\n    }\n\n    return (f = d.match(/([0-9]+\\.[0-9]+\\.[0-9]+)\\-special\\.([0-9]+)/)) && f[1] && f[2] ? (a = f[2], m(b = \"\".concat(f[1], \".\")).call(b, 100 * (Number(a) + 1))) : \"4.0.0.999\";\n  }(\"4.5.0\");\n\n  try {\n    var Vj = !0 === JSON.parse(\"true\");\n  } catch (d) {\n    Vj = !0;\n  }\n\n  let Mf = Vj,\n      $a = {\n    username: \"test\",\n    password: \"111111\",\n    turnServerURL: \"\",\n    tcpport: 3433,\n    udpport: 3478,\n    forceturn: !1\n  },\n      gl = {\n    \"90p\": K(160, 90),\n    \"90p_1\": K(160, 90),\n    \"120p\": K(160, 120, 15, 30, 65),\n    \"120p_1\": K(160, 120, 15, 30, 65),\n    \"120p_3\": K(120, 120, 15, 30, 50),\n    \"120p_4\": K(212, 120),\n    \"180p\": K(320, 180, 15, 30, 140),\n    \"180p_1\": K(320, 180, 15, 30, 140),\n    \"180p_3\": K(180, 180, 15, 30, 100),\n    \"180p_4\": K(240, 180, 15, 30, 120),\n    \"240p\": K(320, 240, 15, 40, 200),\n    \"240p_1\": K(320, 240, 15, 40, 200),\n    \"240p_3\": K(240, 240, 15, 40, 140),\n    \"240p_4\": K(424, 240, 15, 40, 220),\n    \"360p\": K(640, 360, 15, 80, 400),\n    \"360p_1\": K(640, 360, 15, 80, 400),\n    \"360p_3\": K(360, 360, 15, 80, 260),\n    \"360p_4\": K(640, 360, 30, 80, 600),\n    \"360p_6\": K(360, 360, 30, 80, 400),\n    \"360p_7\": K(480, 360, 15, 80, 320),\n    \"360p_8\": K(480, 360, 30, 80, 490),\n    \"360p_9\": K(640, 360, 15, 80, 800),\n    \"360p_10\": K(640, 360, 24, 80, 800),\n    \"360p_11\": K(640, 360, 24, 80, 1E3),\n    \"480p\": K(640, 480, 15, 100, 500),\n    \"480p_1\": K(640, 480, 15, 100, 500),\n    \"480p_2\": K(640, 480, 30, 100, 1E3),\n    \"480p_3\": K(480, 480, 15, 100, 400),\n    \"480p_4\": K(640, 480, 30, 100, 750),\n    \"480p_6\": K(480, 480, 30, 100, 600),\n    \"480p_8\": K(848, 480, 15, 100, 610),\n    \"480p_9\": K(848, 480, 30, 100, 930),\n    \"480p_10\": K(640, 480, 10, 100, 400),\n    \"720p\": K(1280, 720, 15, 120, 1130),\n    \"720p_1\": K(1280, 720, 15, 120, 1130),\n    \"720p_2\": K(1280, 720, 30, 120, 2E3),\n    \"720p_3\": K(1280, 720, 30, 120, 1710),\n    \"720p_5\": K(960, 720, 15, 120, 910),\n    \"720p_6\": K(960, 720, 30, 120, 1380),\n    \"1080p\": K(1920, 1080, 15, 120, 2080),\n    \"1080p_1\": K(1920, 1080, 15, 120, 2080),\n    \"1080p_2\": K(1920, 1080, 30, 120, 3E3),\n    \"1080p_3\": K(1920, 1080, 30, 120, 3150),\n    \"1080p_5\": K(1920, 1080, 60, 120, 4780),\n    \"1440p\": K(2560, 1440, 30, 120, 4850),\n    \"1440p_1\": K(2560, 1440, 30, 120, 4850),\n    \"1440p_2\": K(2560, 1440, 60, 120, 7350),\n    \"4k\": K(3840, 2160, 30, 120, 8910),\n    \"4k_1\": K(3840, 2160, 30, 120, 8910),\n    \"4k_3\": K(3840, 2160, 60, 120, 13500)\n  },\n      hl = {\n    \"480p\": eb(640, 480, 5),\n    \"480p_1\": eb(640, 480, 5),\n    \"480p_2\": eb(640, 480, 30),\n    \"480p_3\": eb(640, 480, 15),\n    \"720p\": eb(1280, 720, 5),\n    \"720p_1\": eb(1280, 720, 5),\n    \"720p_2\": eb(1280, 720, 30),\n    \"720p_3\": eb(1280, 720, 15),\n    \"1080p\": eb(1920, 1080, 5),\n    \"1080p_1\": eb(1920, 1080, 5),\n    \"1080p_2\": eb(1920, 1080, 30),\n    \"1080p_3\": eb(1920, 1080, 15)\n  },\n      il = {\n    \"1SL1TL\": ze(1, 1),\n    \"3SL3TL\": ze(3, 3),\n    \"2SL3TL\": ze(2, 3)\n  },\n      jl = {\n    speech_low_quality: lc(16E3, !1),\n    speech_standard: lc(32E3, !1, 18),\n    music_standard: lc(48E3, !1),\n    standard_stereo: lc(48E3, !0, 56),\n    high_quality: lc(48E3, !1, 128),\n    high_quality_stereo: lc(48E3, !0, 192)\n  },\n      v = {\n    PROCESS_ID: \"\",\n    ENCRYPT_AES: !0,\n    AREAS: [\"CHINA\", \"GLOBAL\"],\n    WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\", \"webrtc2-2.ap.sd-rtn.com\"],\n    WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\", \"webrtc2-4.ap.sd-rtn.com\"],\n    PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n    CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-web-2.ap.sd-rtn.com\", \"cds-ap-web-3.agora.io\", \"cds-web-4.ap.sd-rtn.com\"],\n    ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-web-2.ap.sd-rtn.com\", \"sua-ap-web-3.agora.io\", \"sua-web-4.ap.sd-rtn.com\"],\n    UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-web-2.ap.sd-rtn.com\", \"uap-ap-web-3.agora.io\", \"uap-web-4.ap.sd-rtn.com\"],\n    LOG_UPLOAD_SERVER: \"logservice.agora.io\",\n    EVENT_REPORT_DOMAIN: \"statscollector-1.agora.io\",\n    EVENT_REPORT_BACKUP_DOMAIN: \"web-2.statscollector.sd-rtn.com\",\n    GATEWAY_ADDRESS: [],\n    GATEWAY_WSS_ADDRESS: \"\",\n    LIVE_STREAMING_ADDRESS: \"\",\n    ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,\n    ACCOUNT_REGISTER_RETRY_RATIO: 2,\n    ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6E4,\n    ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1E5,\n    AUDIO_CONTEXT: null,\n    WEBCS_BACKUP_CONNECT_TIMEOUT: 6E3,\n    HTTP_CONNECT_TIMEOUT: 5E3,\n    PLAYER_STATE_DEFER: 2E3,\n    SIGNAL_REQUEST_TIMEOUT: 1E4,\n    SIGNAL_REQUEST_WATCH_INTERVAL: 1E3,\n    REPORT_STATS: !0,\n    UPLOAD_LOG: !1,\n    NOT_REPORT_EVENT: [],\n    FILEPATH_LENMAX: 255,\n    SUBSCRIBE_TCC: !0,\n    PING_PONG_TIME_OUT: 10,\n    DUALSTREAM_OPERATION_CHECK: !0,\n    WEBSOCKET_TIMEOUT_MIN: 1E4,\n    EVENT_REPORT_SEND_INTERVAL: 3E3,\n    CONFIG_DISTRIBUTE_INTERVAL: 3E5,\n    MEDIA_ELEMENT_EXISTS_DEPTH: 3,\n    CANDIDATE_TIMEOUT: 5E3,\n    SHIM_CANDIDATE: !1,\n    LEAVE_MSG_TIMEOUT: 2E3,\n    SHOW_REPORT_INVOKER_LOG: !1,\n    STATS_FILTER: {\n      transportId: !0,\n      googTrackId: !0\n    },\n    JOIN_EXTEND: \"\",\n    PUB_EXTEND: \"\",\n    SUB_EXTEND: \"\",\n    FORCE_TURN: !1,\n    TURN_ENABLE_TCP: !0,\n    TURN_ENABLE_UDP: !0,\n    MAX_UPLOAD_CACHE: 50,\n    UPLOAD_CACHE_INTERVAL: 2E3,\n    AJAX_REQUEST_CONCURRENT: 3,\n    REPORT_APP_SCENARIO: void 0,\n    CHROME_FORCE_PLAN_B: !1,\n    AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400,\n    AUDIO_SOURCE_AVG_VOLUME_DURATION: 3E3,\n    AUDIO_VOLUME_INDICATION_INTERVAL: 2E3,\n    NORMAL_EVENT_QUEUE_CAPACITY: 100,\n    CUSTOM_REPORT: !0,\n    CUSTOM_REPORT_LIMIT: 20,\n    PROXY_SERVER_TYPE2: \"webnginx-proxy.agora.io\",\n    PROXY_SERVER_TYPE3: \"webrtc-cloud-proxy.sd-rtn.com\",\n    CUSTOM_PUB_ANSWER_MODIFIER: null,\n    CUSTOM_SUB_ANSWER_MODIFIER: null,\n    CUSTOM_PUB_OFFER_MODIFIER: null,\n    CUSTOM_SUB_OFFER_MODIFIER: null,\n    DSCP_TYPE: \"high\",\n    REMOVE_NEW_CODECS: !0,\n    FRAGEMENT_LENGTH: 3\n  };\n  Mf || (v.WEBCS_DOMAIN = [\"ap-web-1-oversea.agora.io\", \"ap-web-1-north-america.agora.io\"], v.WEBCS_DOMAIN_BACKUP_LIST = [\"ap-web-2-oversea.agora.io\", \"ap-web-2-north-america.agora.io\"], v.PROXY_CS = [\"proxy-ap-web-oversea.agora.io\", \"proxy-ap-web-america.agora.io\"], v.CDS_AP = [\"cds-ap-web-oversea.agora.io\", \"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"], v.ACCOUNT_REGISTER = [\"sua-ap-web-oversea.agora.io\", \"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"], v.UAP_AP = [\"uap-ap-web-oversea.agora.io\", \"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"], v.LOG_UPLOAD_SERVER = \"logservice-oversea.agora.io\", v.EVENT_REPORT_DOMAIN = \"statscollector-1-oversea.agora.io\", v.EVENT_REPORT_BACKUP_DOMAIN = \"statscollector-2-oversea.agora.io\", v.PROXY_SERVER_TYPE3 = \"webrtc-cloud-proxy.agora.io\", v.AREAS = [\"NORTH_AMERICA\", \"OVERSEA\"]);\n  let Hn = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]],\n      Wj = [];\n  var Nf = [],\n      Xj = Nf.sort,\n      In = sa(function () {\n    Nf.sort(void 0);\n  }),\n      Jn = sa(function () {\n    Nf.sort(null);\n  }),\n      Kn = Wc(\"sort\");\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: In || !Jn || Kn\n  }, {\n    sort: function (d) {\n      return void 0 === d ? Xj.call(ob(this)) : Xj.call(ob(this), lb(d));\n    }\n  });\n\n  var Ln = za(\"Array\").sort,\n      Yj = Array.prototype,\n      dd = function (d) {\n    var f = d.sort;\n    return d === Yj || d instanceof Array && f === Yj.sort ? Ln : f;\n  };\n\n  O({\n    target: \"Array\",\n    stat: !0\n  }, {\n    isArray: cc\n  });\n  var l,\n      Pb = ia.Array.isArray;\n  !function (d) {\n    d.UNEXPECTED_ERROR = \"UNEXPECTED_ERROR\";\n    d.UNEXPECTED_RESPONSE = \"UNEXPECTED_RESPONSE\";\n    d.TIMEOUT = \"TIMEOUT\";\n    d.INVALID_PARAMS = \"INVALID_PARAMS\";\n    d.NOT_READABLE = \"NOT_READABLE\";\n    d.NOT_SUPPORTED = \"NOT_SUPPORTED\";\n    d.INVALID_OPERATION = \"INVALID_OPERATION\";\n    d.OPERATION_ABORTED = \"OPERATION_ABORTED\";\n    d.WEB_SECURITY_RESTRICT = \"WEB_SECURITY_RESTRICT\";\n    d.NETWORK_ERROR = \"NETWORK_ERROR\";\n    d.NETWORK_TIMEOUT = \"NETWORK_TIMEOUT\";\n    d.NETWORK_RESPONSE_ERROR = \"NETWORK_RESPONSE_ERROR\";\n    d.API_INVOKE_TIMEOUT = \"API_INVOKE_TIMEOUT\";\n    d.ENUMERATE_DEVICES_FAILED = \"ENUMERATE_DEVICES_FAILED\";\n    d.DEVICE_NOT_FOUND = \"DEVICE_NOT_FOUND\";\n    d.ELECTRON_IS_NULL = \"ELECTRON_IS_NULL\";\n    d.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = \"ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR\";\n    d.CHROME_PLUGIN_NO_RESPONSE = \"CHROME_PLUGIN_NO_RESPONSE\";\n    d.CHROME_PLUGIN_NOT_INSTALL = \"CHROME_PLUGIN_NOT_INSTALL\";\n    d.MEDIA_OPTION_INVALID = \"MEDIA_OPTION_INVALID\";\n    d.PERMISSION_DENIED = \"PERMISSION_DENIED\";\n    d.CONSTRAINT_NOT_SATISFIED = \"CONSTRAINT_NOT_SATISFIED\";\n    d.TRACK_IS_DISABLED = \"TRACK_IS_DISABLED\";\n    d.SHARE_AUDIO_NOT_ALLOWED = \"SHARE_AUDIO_NOT_ALLOWED\";\n    d.LOW_STREAM_ENCODING_ERROR = \"LOW_STREAM_ENCODING_ERROR\";\n    d.SET_ENCODING_PARAMETER_ERROR = \"SET_ENCODING_PARAMETER_ERROR\";\n    d.INVALID_UINT_UID_FROM_STRING_UID = \"INVALID_UINT_UID_FROM_STRING_UID\";\n    d.CAN_NOT_GET_PROXY_SERVER = \"CAN_NOT_GET_PROXY_SERVER\";\n    d.CAN_NOT_GET_GATEWAY_SERVER = \"CAN_NOT_GET_GATEWAY_SERVER\";\n    d.VOID_GATEWAY_ADDRESS = \"VOID_GATEWAY_ADDRESS\";\n    d.UID_CONFLICT = \"UID_CONFLICT\";\n    d.INVALID_LOCAL_TRACK = \"INVALID_LOCAL_TRACK\";\n    d.INVALID_TRACK = \"INVALID_TRACK\";\n    d.SENDER_NOT_FOUND = \"SENDER_NOT_FOUND\";\n    d.CREATE_OFFER_FAILED = \"CREATE_OFFER_FAILED\";\n    d.SET_ANSWER_FAILED = \"SET_ANSWER_FAILED\";\n    d.ICE_FAILED = \"ICE_FAILED\";\n    d.PC_CLOSED = \"PC_CLOSED\";\n    d.SENDER_REPLACE_FAILED = \"SENDER_REPLACE_FAILED\";\n    d.GATEWAY_P2P_LOST = \"GATEWAY_P2P_LOST\";\n    d.NO_ICE_CANDIDATE = \"NO_ICE_CANDIDATE\";\n    d.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = \"CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS\";\n    d.EXIST_DISABLED_VIDEO_TRACK = \"EXIST_DISABLED_VIDEO_TRACK\";\n    d.INVALID_REMOTE_USER = \"INVALID_REMOTE_USER\";\n    d.REMOTE_USER_IS_NOT_PUBLISHED = \"REMOTE_USER_IS_NOT_PUBLISHED\";\n    d.CUSTOM_REPORT_SEND_FAILED = \"CUSTOM_REPORT_SEND_FAILED\";\n    d.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = \"CUSTOM_REPORT_FREQUENCY_TOO_HIGH\";\n    d.FETCH_AUDIO_FILE_FAILED = \"FETCH_AUDIO_FILE_FAILED\";\n    d.READ_LOCAL_AUDIO_FILE_ERROR = \"READ_LOCAL_AUDIO_FILE_ERROR\";\n    d.DECODE_AUDIO_FILE_FAILED = \"DECODE_AUDIO_FILE_FAILED\";\n    d.WS_ABORT = \"WS_ABORT\";\n    d.WS_DISCONNECT = \"WS_DISCONNECT\";\n    d.WS_ERR = \"WS_ERR\";\n    d.LIVE_STREAMING_TASK_CONFLICT = \"LIVE_STREAMING_TASK_CONFLICT\";\n    d.LIVE_STREAMING_INVALID_ARGUMENT = \"LIVE_STREAMING_INVALID_ARGUMENT\";\n    d.LIVE_STREAMING_INTERNAL_SERVER_ERROR = \"LIVE_STREAMING_INTERNAL_SERVER_ERROR\";\n    d.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = \"LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED\";\n    d.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = \"LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED\";\n    d.LIVE_STREAMING_CDN_ERROR = \"LIVE_STREAMING_CDN_ERROR\";\n    d.LIVE_STREAMING_INVALID_RAW_STREAM = \"LIVE_STREAMING_INVALID_RAW_STREAM\";\n    d.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = \"LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT\";\n    d.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = \"LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE\";\n    d.LIVE_STREAMING_WARN_FREQUENT_REQUEST = \"LIVE_STREAMING_WARN_FREQUENT_REQUEST\";\n    d.WEBGL_INTERNAL_ERROR = \"WEBGL_INTERNAL_ERROR\";\n    d.BEAUTY_PROCESSOR_INTERNAL_ERROR = \"BEAUTY_PROCESSOR_INTERNAL_ERROR\";\n    d.CROSS_CHANNEL_WAIT_STATUS_ERROR = \"CROSS_CHANNEL_WAIT_STATUS_ERROR\";\n    d.CROSS_CHANNEL_FAILED_JOIN_SRC = \"CROSS_CHANNEL_FAILED_JOIN_SEC\";\n    d.CROSS_CHANNEL_FAILED_JOIN_DEST = \"CROSS_CHANNEL_FAILED_JOIN_DEST\";\n    d.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = \"CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST\";\n    d.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = \"CROSS_CHANNEL_SERVER_ERROR_RESPONSE\";\n    d.METADATA_OUT_OF_RANGE = \"METADATA_OUT_OF_RANGE\";\n    d.LOCAL_AEC_ERROR = \"LOCAL_AEC_ERROR\";\n  }(l || (l = {}));\n\n  var ah = function (d, f) {\n    return function () {\n      for (var a = Array(arguments.length), b = 0; b < a.length; b++) a[b] = arguments[b];\n\n      return d.apply(f, a);\n    };\n  },\n      mc = Object.prototype.toString,\n      L = {\n    isArray: Tg,\n    isArrayBuffer: function (d) {\n      return \"[object ArrayBuffer]\" === mc.call(d);\n    },\n    isBuffer: function (d) {\n      return null != d && null != d.constructor && \"function\" == typeof d.constructor.isBuffer && d.constructor.isBuffer(d);\n    },\n    isFormData: function (d) {\n      return \"undefined\" != typeof FormData && d instanceof FormData;\n    },\n    isArrayBufferView: function (d) {\n      return \"undefined\" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(d) : d && d.buffer && d.buffer instanceof ArrayBuffer;\n    },\n    isString: function (d) {\n      return \"string\" == typeof d;\n    },\n    isNumber: function (d) {\n      return \"number\" == typeof d;\n    },\n    isObject: Ug,\n    isUndefined: function (d) {\n      return void 0 === d;\n    },\n    isDate: function (d) {\n      return \"[object Date]\" === mc.call(d);\n    },\n    isFile: function (d) {\n      return \"[object File]\" === mc.call(d);\n    },\n    isBlob: function (d) {\n      return \"[object Blob]\" === mc.call(d);\n    },\n    isFunction: Vg,\n    isStream: function (d) {\n      return Ug(d) && Vg(d.pipe);\n    },\n    isURLSearchParams: function (d) {\n      return \"undefined\" != typeof URLSearchParams && d instanceof URLSearchParams;\n    },\n    isStandardBrowserEnv: function () {\n      return (\"undefined\" == typeof navigator || \"ReactNative\" !== navigator.product && \"NativeScript\" !== navigator.product && \"NS\" !== navigator.product) && \"undefined\" != typeof window && \"undefined\" != typeof document;\n    },\n    forEach: wd,\n    merge: function f() {\n      function a(a, c) {\n        \"object\" == typeof b[c] && \"object\" == typeof a ? b[c] = f(b[c], a) : b[c] = a;\n      }\n\n      for (var b = {}, c = 0, e = arguments.length; c < e; c++) wd(arguments[c], a);\n\n      return b;\n    },\n    deepMerge: function a() {\n      function b(b, e) {\n        \"object\" == typeof c[e] && \"object\" == typeof b ? c[e] = a(c[e], b) : c[e] = \"object\" == typeof b ? a({}, b) : b;\n      }\n\n      for (var c = {}, e = 0, g = arguments.length; e < g; e++) wd(arguments[e], b);\n\n      return c;\n    },\n    extend: function (a, b, c) {\n      return wd(b, function (b, g) {\n        a[g] = c && \"function\" == typeof b ? ah(b, c) : b;\n      }), a;\n    },\n    trim: function (a) {\n      return a.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n    }\n  },\n      Zj = function (a, b, c) {\n    if (!b) return a;\n    if (c) b = c(b);else if (L.isURLSearchParams(b)) b = b.toString();else {\n      var e = [];\n      L.forEach(b, function (a, b) {\n        null != a && (L.isArray(a) ? b += \"[]\" : a = [a], L.forEach(a, function (a) {\n          L.isDate(a) ? a = a.toISOString() : L.isObject(a) && (a = JSON.stringify(a));\n          e.push(Wg(b) + \"=\" + Wg(a));\n        }));\n      });\n      b = e.join(\"&\");\n    }\n    b && (c = a.indexOf(\"#\"), -1 !== c && (a = a.slice(0, c)), a += (-1 === a.indexOf(\"?\") ? \"?\" : \"&\") + b);\n    return a;\n  };\n\n  xd.prototype.use = function (a, b) {\n    return this.handlers.push({\n      fulfilled: a,\n      rejected: b\n    }), this.handlers.length - 1;\n  };\n\n  xd.prototype.eject = function (a) {\n    this.handlers[a] && (this.handlers[a] = null);\n  };\n\n  xd.prototype.forEach = function (a) {\n    L.forEach(this.handlers, function (b) {\n      null !== b && a(b);\n    });\n  };\n\n  var Yg = xd,\n      Of = function (a, b, c) {\n    return L.forEach(c, function (c) {\n      a = c(a, b);\n    }), a;\n  },\n      ak = function (a) {\n    return !(!a || !a.__CANCEL__);\n  },\n      bk = function (a, b) {\n    L.forEach(a, function (c, e) {\n      e !== b && e.toUpperCase() === b.toUpperCase() && (a[b] = c, delete a[e]);\n    });\n  },\n      ie = function (a, b, c, e, g) {\n    return function (a, b, c, e, g) {\n      return a.config = b, c && (a.code = c), a.request = e, a.response = g, a.isAxiosError = !0, a.toJSON = function () {\n        return {\n          message: this.message,\n          name: this.name,\n          description: this.description,\n          number: this.number,\n          fileName: this.fileName,\n          lineNumber: this.lineNumber,\n          columnNumber: this.columnNumber,\n          stack: this.stack,\n          config: this.config,\n          code: this.code\n        };\n      }, a;\n    }(Error(a), b, c, e, g);\n  },\n      Mn = \"age authorization content-length content-type etag expires from host if-modified-since if-unmodified-since last-modified location max-forwards proxy-authorization referer retry-after user-agent\".split(\" \"),\n      Nn = L.isStandardBrowserEnv() ? function () {\n    function a(a) {\n      return c && (e.setAttribute(\"href\", a), a = e.href), e.setAttribute(\"href\", a), {\n        href: e.href,\n        protocol: e.protocol ? e.protocol.replace(/:$/, \"\") : \"\",\n        host: e.host,\n        search: e.search ? e.search.replace(/^\\?/, \"\") : \"\",\n        hash: e.hash ? e.hash.replace(/^#/, \"\") : \"\",\n        hostname: e.hostname,\n        port: e.port,\n        pathname: \"/\" === e.pathname.charAt(0) ? e.pathname : \"/\" + e.pathname\n      };\n    }\n\n    var b,\n        c = /(msie|trident)/i.test(navigator.userAgent),\n        e = document.createElement(\"a\");\n    return b = a(window.location.href), function (c) {\n      c = L.isString(c) ? a(c) : c;\n      return c.protocol === b.protocol && c.host === b.host;\n    };\n  }() : function () {\n    return !0;\n  },\n      On = L.isStandardBrowserEnv() ? {\n    write: function (a, b, c, e, g, h) {\n      var p = [];\n      p.push(a + \"=\" + encodeURIComponent(b));\n      L.isNumber(c) && p.push(\"expires=\" + new Date(c).toGMTString());\n      L.isString(e) && p.push(\"path=\" + e);\n      L.isString(g) && p.push(\"domain=\" + g);\n      !0 === h && p.push(\"secure\");\n      document.cookie = p.join(\"; \");\n    },\n    read: function (a) {\n      return (a = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + a + \")=([^;]*)\"))) ? decodeURIComponent(a[3]) : null;\n    },\n    remove: function (a) {\n      this.write(a, \"\", Date.now() - 864E5);\n    }\n  } : {\n    write: function () {},\n    read: function () {\n      return null;\n    },\n    remove: function () {}\n  },\n      Pn = function (a) {\n    return new Promise(function (b, c) {\n      var e = a.data,\n          g = a.headers;\n      L.isFormData(e) && delete g[\"Content-Type\"];\n      var h = new XMLHttpRequest();\n      a.auth && (g.Authorization = \"Basic \" + btoa((a.auth.username || \"\") + \":\" + (a.auth.password || \"\")));\n\n      if (h.open(a.method.toUpperCase(), Zj(a.url, a.params, a.paramsSerializer), !0), h.timeout = a.timeout, h.onreadystatechange = function () {\n        if (h && 4 === h.readyState && (0 !== h.status || h.responseURL && 0 === h.responseURL.indexOf(\"file:\"))) {\n          var e,\n              g,\n              p,\n              k,\n              l,\n              m = \"getAllResponseHeaders\" in h ? (e = h.getAllResponseHeaders(), l = {}, e ? (L.forEach(e.split(\"\\n\"), function (a) {\n            (k = a.indexOf(\":\"), g = L.trim(a.substr(0, k)).toLowerCase(), p = L.trim(a.substr(k + 1)), !g) || l[g] && 0 <= Mn.indexOf(g) || (l[g] = \"set-cookie\" === g ? (l[g] ? l[g] : []).concat([p]) : l[g] ? l[g] + \", \" + p : p);\n          }), l) : l) : null;\n          !function (a, b, c) {\n            var e = c.config.validateStatus;\n            !e || e(c.status) ? a(c) : b(ie(\"Request failed with status code \" + c.status, c.config, null, c.request, c));\n          }(b, c, {\n            data: a.responseType && \"text\" !== a.responseType ? h.response : h.responseText,\n            status: h.status,\n            statusText: h.statusText,\n            headers: m,\n            config: a,\n            request: h\n          });\n          h = null;\n        }\n      }, h.onabort = function () {\n        h && (c(ie(\"Request aborted\", a, \"ECONNABORTED\", h)), h = null);\n      }, h.onerror = function () {\n        c(ie(\"Network Error\", a, null, h));\n        h = null;\n      }, h.ontimeout = function () {\n        c(ie(\"timeout of \" + a.timeout + \"ms exceeded\", a, \"ECONNABORTED\", h));\n        h = null;\n      }, L.isStandardBrowserEnv()) {\n        var p = (a.withCredentials || Nn(a.url)) && a.xsrfCookieName ? On.read(a.xsrfCookieName) : void 0;\n        p && (g[a.xsrfHeaderName] = p);\n      }\n\n      if (\"setRequestHeader\" in h && L.forEach(g, function (a, b) {\n        void 0 === e && \"content-type\" === b.toLowerCase() ? delete g[b] : h.setRequestHeader(b, a);\n      }), a.withCredentials && (h.withCredentials = !0), a.responseType) try {\n        h.responseType = a.responseType;\n      } catch (r) {\n        if (\"json\" !== a.responseType) throw r;\n      }\n      \"function\" == typeof a.onDownloadProgress && h.addEventListener(\"progress\", a.onDownloadProgress);\n      \"function\" == typeof a.onUploadProgress && h.upload && h.upload.addEventListener(\"progress\", a.onUploadProgress);\n      a.cancelToken && a.cancelToken.promise.then(function (a) {\n        h && (h.abort(), c(a), h = null);\n      });\n      void 0 === e && (e = null);\n      h.send(e);\n    });\n  },\n      Qn = {\n    \"Content-Type\": \"application/x-www-form-urlencoded\"\n  },\n      je = {\n    adapter: function () {\n      var a;\n      return (\"undefined\" != typeof process && \"[object process]\" === Object.prototype.toString.call(process) || \"undefined\" != typeof XMLHttpRequest) && (a = Pn), a;\n    }(),\n    transformRequest: [function (a, b) {\n      return bk(b, \"Accept\"), bk(b, \"Content-Type\"), L.isFormData(a) || L.isArrayBuffer(a) || L.isBuffer(a) || L.isStream(a) || L.isFile(a) || L.isBlob(a) ? a : L.isArrayBufferView(a) ? a.buffer : L.isURLSearchParams(a) ? (Xg(b, \"application/x-www-form-urlencoded;charset=utf-8\"), a.toString()) : L.isObject(a) ? (Xg(b, \"application/json;charset=utf-8\"), JSON.stringify(a)) : a;\n    }],\n    transformResponse: [function (a) {\n      if (\"string\" == typeof a) try {\n        a = JSON.parse(a);\n      } catch (b) {}\n      return a;\n    }],\n    timeout: 0,\n    xsrfCookieName: \"XSRF-TOKEN\",\n    xsrfHeaderName: \"X-XSRF-TOKEN\",\n    maxContentLength: -1,\n    validateStatus: function (a) {\n      return 200 <= a && 300 > a;\n    },\n    headers: {\n      common: {\n        Accept: \"application/json, text/plain, */*\"\n      }\n    }\n  };\n\n  L.forEach([\"delete\", \"get\", \"head\"], function (a) {\n    je.headers[a] = {};\n  });\n  L.forEach([\"post\", \"put\", \"patch\"], function (a) {\n    je.headers[a] = L.merge(Qn);\n  });\n\n  var Rn = function (a) {\n    var b, c, e;\n    a.cancelToken && a.cancelToken.throwIfRequested();\n    return a.baseURL && (e = a.url, !/^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(e)) && (a.url = (b = a.baseURL, (c = a.url) ? b.replace(/\\/+$/, \"\") + \"/\" + c.replace(/^\\/+/, \"\") : b)), a.headers = a.headers || {}, a.data = Of(a.data, a.headers, a.transformRequest), a.headers = L.merge(a.headers.common || {}, a.headers[a.method] || {}, a.headers || {}), L.forEach(\"delete get head post put patch common\".split(\" \"), function (b) {\n      delete a.headers[b];\n    }), (a.adapter || je.adapter)(a).then(function (b) {\n      a.cancelToken && a.cancelToken.throwIfRequested();\n      return b.data = Of(b.data, b.headers, a.transformResponse), b;\n    }, function (b) {\n      ak(b) || (a.cancelToken && a.cancelToken.throwIfRequested(), b && b.response && (b.response.data = Of(b.response.data, b.response.headers, a.transformResponse)));\n      return Promise.reject(b);\n    });\n  },\n      Pf = function (a, b) {\n    b = b || {};\n    var c = {};\n    return L.forEach([\"url\", \"method\", \"params\", \"data\"], function (a) {\n      void 0 !== b[a] && (c[a] = b[a]);\n    }), L.forEach([\"headers\", \"auth\", \"proxy\"], function (e) {\n      L.isObject(b[e]) ? c[e] = L.deepMerge(a[e], b[e]) : void 0 !== b[e] ? c[e] = b[e] : L.isObject(a[e]) ? c[e] = L.deepMerge(a[e]) : void 0 !== a[e] && (c[e] = a[e]);\n    }), L.forEach(\"baseURL transformRequest transformResponse paramsSerializer timeout withCredentials adapter responseType xsrfCookieName xsrfHeaderName onUploadProgress onDownloadProgress maxContentLength validateStatus maxRedirects httpAgent httpsAgent cancelToken socketPath\".split(\" \"), function (e) {\n      void 0 !== b[e] ? c[e] = b[e] : void 0 !== a[e] && (c[e] = a[e]);\n    }), c;\n  };\n\n  Jc.prototype.request = function (a, b) {\n    \"string\" == typeof a ? (a = b || {}).url = a : a = a || {};\n    (a = Pf(this.defaults, a)).method = a.method ? a.method.toLowerCase() : \"get\";\n    var c = [Rn, void 0];\n    a = Promise.resolve(a);\n    this.interceptors.request.forEach(function (a) {\n      c.unshift(a.fulfilled, a.rejected);\n    });\n\n    for (this.interceptors.response.forEach(function (a) {\n      c.push(a.fulfilled, a.rejected);\n    }); c.length;) a = a.then(c.shift(), c.shift());\n\n    return a;\n  };\n\n  Jc.prototype.getUri = function (a) {\n    return a = Pf(this.defaults, a), Zj(a.url, a.params, a.paramsSerializer).replace(/^\\?/, \"\");\n  };\n\n  L.forEach([\"delete\", \"get\", \"head\", \"options\"], function (a) {\n    Jc.prototype[a] = function (b, c) {\n      return this.request(L.merge(c || {}, {\n        method: a,\n        url: b\n      }));\n    };\n  });\n  L.forEach([\"post\", \"put\", \"patch\"], function (a) {\n    Jc.prototype[a] = function (b, c, e) {\n      return this.request(L.merge(e || {}, {\n        method: a,\n        url: b,\n        data: c\n      }));\n    };\n  });\n  var zd = Jc;\n\n  Ae.prototype.toString = function () {\n    return \"Cancel\" + (this.message ? \": \" + this.message : \"\");\n  };\n\n  Ae.prototype.__CANCEL__ = !0;\n  var Zg = Ae;\n\n  yd.prototype.throwIfRequested = function () {\n    if (this.reason) throw this.reason;\n  };\n\n  yd.source = function () {\n    var a;\n    return {\n      token: new yd(function (b) {\n        a = b;\n      }),\n      cancel: a\n    };\n  };\n\n  var Cb = $g(je);\n  Cb.Axios = zd;\n\n  Cb.create = function (a) {\n    return $g(Pf(Cb.defaults, a));\n  };\n\n  Cb.Cancel = Zg;\n  Cb.CancelToken = yd;\n  Cb.isCancel = ak;\n\n  Cb.all = function (a) {\n    return Promise.all(a);\n  };\n\n  Cb.spread = function (a) {\n    return function (b) {\n      return a.apply(null, b);\n    };\n  };\n\n  var zb = Cb.default = Cb;\n\n  let pb = {\n    DEBUG: 0,\n    INFO: 1,\n    WARNING: 2,\n    ERROR: 3,\n    NONE: 4\n  },\n      ck = a => {\n    for (const b in pb) if (pb[b] === a) return b;\n\n    return \"DEFAULT\";\n  },\n      k = new class {\n    constructor() {\n      this.logLevel = pb.DEBUG;\n      this.uploadState = \"collecting\";\n      this.uploadLogWaitingList = [];\n      this.uploadLogUploadingList = [];\n      this.currentLogID = this.uploadErrorCount = 0;\n    }\n\n    debug(...a) {\n      var b;\n      a = m(b = [pb.DEBUG]).call(b, a);\n      this.log.apply(this, a);\n    }\n\n    info(...a) {\n      var b;\n      a = m(b = [pb.INFO]).call(b, a);\n      this.log.apply(this, a);\n    }\n\n    warning(...a) {\n      var b;\n      a = m(b = [pb.WARNING]).call(b, a);\n      this.log.apply(this, a);\n    }\n\n    error(...a) {\n      var b;\n      a = m(b = [pb.ERROR]).call(b, a);\n      this.log.apply(this, a);\n    }\n\n    setLogLevel(a) {\n      this.logLevel = a = Math.min(Math.max(0, a), 4);\n    }\n\n    enableLogUpload() {\n      Yb(\"UPLOAD_LOG\", !0);\n    }\n\n    disableLogUpload() {\n      Yb(\"UPLOAD_LOG\", !1);\n      this.uploadLogUploadingList = [];\n      this.uploadLogWaitingList = [];\n    }\n\n    setProxyServer(a) {\n      this.proxyServerURL = a;\n    }\n\n    log(...a) {\n      var b, c, e, g;\n      const h = Math.max(0, Math.min(4, a[0]));\n\n      if (!(a[0] = bh() + \" Agora-SDK [\".concat(ck(h), \"]:\"), this.appendLogToWaitingList(h, a), h < this.logLevel)) {\n        var p = bh() + \" %cAgora-SDK [\".concat(ck(h), \"]:\");\n\n        switch (h) {\n          case pb.DEBUG:\n            a = m(b = [p, \"color: #64B5F6;\"]).call(b, Ha(a).call(a, 1));\n            console.log.apply(console, a);\n            break;\n\n          case pb.INFO:\n            a = m(c = [p, \"color: #1E88E5; font-weight: bold;\"]).call(c, Ha(a).call(a, 1));\n            console.log.apply(console, a);\n            break;\n\n          case pb.WARNING:\n            a = m(e = [p, \"color: #FB8C00; font-weight: bold;\"]).call(e, Ha(a).call(a, 1));\n            console.warn.apply(console, a);\n            break;\n\n          case pb.ERROR:\n            a = m(g = [p, \"color: #B00020; font-weight: bold;\"]).call(g, Ha(a).call(a, 1)), console.error.apply(console, a);\n        }\n      }\n    }\n\n    appendLogToWaitingList(a, ...b) {\n      if (v.UPLOAD_LOG) {\n        var c = \"\";\n        q(b).call(b, a => {\n          \"object\" == typeof a && (a = w(a));\n          c += \"\".concat(a, \" \");\n        });\n        this.uploadLogWaitingList.push({\n          payload_str: c,\n          log_level: a,\n          log_item_id: this.currentLogID++\n        });\n        \"uploading\" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n      }\n    }\n\n    startUpload() {\n      this.uploadState = \"uploading\";\n      0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n    }\n\n    uploadLogs() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        var a,\n            b = {\n          sdk_version: Ta,\n          process_id: v.PROCESS_ID,\n          payload: w(_this.uploadLogUploadingList)\n        };\n        b = yield zb.post(_this.url || (_this.proxyServerURL ? m(a = \"https://\".concat(_this.proxyServerURL, \"/ls/?h=\")).call(a, v.LOG_UPLOAD_SERVER, \"&p=443&d=upload/v1\") : \"https://\".concat(v.LOG_UPLOAD_SERVER, \"/upload/v1\")), b, {\n          responseType: \"text\"\n        });\n        if (\"OK\" !== b.data) throw Error(\"unexpected upload log response: \" + b.data);\n        _this.uploadLogUploadingList = [];\n      })();\n    }\n\n    uploadLogInterval() {\n      if (0 !== this.uploadLogUploadingList.length || 0 !== this.uploadLogWaitingList.length) {\n        var a;\n        0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = Ia(a = this.uploadLogWaitingList).call(a, 0, 10));\n        this.uploadLogs().then(() => {\n          this.uploadErrorCount = 0;\n          0 < this.uploadLogWaitingList.length && window.setTimeout(() => this.uploadLogInterval(), 3E3);\n        }).catch(a => {\n          this.uploadErrorCount += 1;\n          2 > this.uploadErrorCount ? window.setTimeout(() => this.uploadLogInterval(), 200) : window.setTimeout(() => this.uploadLogInterval(), 1E3);\n        });\n      }\n    }\n\n  }();\n\n  class n {\n    constructor(a, b = \"\", c) {\n      var e;\n      this.name = \"AgoraRTCException\";\n      this.code = a;\n      this.message = m(e = \"AgoraRTCError \".concat(this.code, \": \")).call(e, b);\n      this.data = c;\n    }\n\n    toString() {\n      var a;\n      return this.data ? m(a = \"\".concat(this.message, \" data: \")).call(a, w(this.data)) : this.message;\n    }\n\n    print() {\n      return k.error(this.toString()), this;\n    }\n\n    throw() {\n      throw this.print(), this;\n    }\n\n  }\n\n  var dk, Ba;\n  !function (a) {\n    a.FREE = \"free\";\n    a.UPLOADING = \"uploading\";\n  }(dk || (dk = {}));\n\n  (function (a) {\n    a.NONE = \"none\";\n    a.INIT = \"init\";\n    a.CANPLAY = \"canplay\";\n    a.PLAYING = \"playing\";\n    a.PAUSED = \"paused\";\n    a.SUSPEND = \"suspend\";\n    a.STALLED = \"stalled\";\n    a.WAITING = \"waiting\";\n    a.ERROR = \"error\";\n    a.DESTROYED = \"destroyed\";\n    a.ABORT = \"abort\";\n    a.ENDED = \"ended\";\n    a.EMPTIED = \"emptied\";\n  })(Ba || (Ba = {}));\n\n  O({\n    target: \"Number\",\n    stat: !0\n  }, {\n    MAX_SAFE_INTEGER: 9007199254740991\n  });\n  O({\n    target: \"Number\",\n    stat: !0\n  }, {\n    MIN_SAFE_INTEGER: -9007199254740991\n  });\n  let Sn = {\n    sid: \"\",\n    lts: 0,\n    success: null,\n    cname: null,\n    uid: null,\n    peer: null,\n    cid: null,\n    elapse: null,\n    extend: null,\n    vid: 0\n  };\n  var Ca, ma, ek, C, B, hc, Kb, oc, ed, Wa, Da, F, P, Ra, ta, Q, da, qb, U, H, ib;\n  !function (a) {\n    a.PUBLISH = \"publish\";\n    a.SUBSCRIBE = \"subscribe\";\n    a.SESSION_INIT = \"session_init\";\n    a.JOIN_CHOOSE_SERVER = \"join_choose_server\";\n    a.REQ_USER_ACCOUNT = \"req_user_account\";\n    a.JOIN_GATEWAY = \"join_gateway\";\n    a.STREAM_SWITCH = \"stream_switch\";\n    a.REQUEST_PROXY_WORKER_MANAGER = \"request_proxy_worker_manager\";\n    a.REQUEST_PROXY_APPCENTER = \"request_proxy_appcenter\";\n    a.FIRST_VIDEO_RECEIVED = \"first_video_received\";\n    a.FIRST_AUDIO_RECEIVED = \"first_audio_received\";\n    a.FIRST_VIDEO_DECODE = \"first_video_decode\";\n    a.FIRST_AUDIO_DECODE = \"first_audio_decode\";\n    a.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\";\n    a.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\";\n    a.ON_UPDATE_STREAM = \"on_update_stream\";\n    a.ON_REMOVE_STREAM = \"on_remove_stream\";\n    a.USER_ANALYTICS = \"req_user_analytics\";\n  }(Ca || (Ca = {}));\n\n  (function (a) {\n    a.SESSION = \"io.agora.pb.Wrtc.Session\";\n    a.JOIN_CHOOSE_SERVER = \"io.agora.pb.Wrtc.JoinChooseServer\";\n    a.REQ_USER_ACCOUNT = \"io.agora.pb.Wrtc.ReqUserAccount\";\n    a.JOIN_GATEWAT = \"io.agora.pb.Wrtc.JoinGateway\";\n    a.PUBLISH = \"io.agora.pb.Wrtc.Publish\";\n    a.SUBSCRIBE = \"io.agora.pb.Wrtc.Subscribe\";\n    a.STREAM_SWITCH = \"io.agora.pb.Wrtc.StreamSwitch\";\n    a.AUDIO_SENDING_STOPPED = \"io.agora.pb.Wrtc.AudioSendingStopped\";\n    a.VIDEO_SENDING_STOPPED = \"io.agora.pb.Wrtc.VideoSendingStopped\";\n    a.REQUEST_PROXY_APPCENTER = \"io.agora.pb.Wrtc.RequestProxyAppCenter\";\n    a.REQUEST_PROXY_WORKER_MANAGER = \"io.agora.pb.Wrtc.RequestProxyWorkerManager\";\n    a.API_INVOKE = \"io.agora.pb.Wrtc.ApiInvoke\";\n    a.FIRST_VIDEO_RECEIVED = \"io.agora.pb.Wrtc.FirstVideoReceived\";\n    a.FIRST_AUDIO_RECEIVED = \"io.agora.pb.Wrtc.FirstAudioReceived\";\n    a.FIRST_VIDEO_DECODE = \"io.agora.pb.Wrtc.FirstVideoDecode\";\n    a.FIRST_AUDIO_DECODE = \"io.agora.pb.Wrtc.FirstAudioDecode\";\n    a.ON_ADD_AUDIO_STREAM = \"io.agora.pb.Wrtc.OnAddAudioStream\";\n    a.ON_ADD_VIDEO_STREAM = \"io.agora.pb.Wrtc.OnAddVideoStream\";\n    a.ON_UPDATE_STREAM = \"io.agora.pb.Wrtc.OnUpdateStream\";\n    a.ON_REMOVE_STREAM = \"io.agora.pb.Wrtc.OnRemoveStream\";\n    a.JOIN_CHANNEL_TIMEOUT = \"io.agora.pb.Wrtc.JoinChannelTimeout\";\n    a.PEER_PUBLISH_STATUS = \"io.agora.pb.Wrtc.PeerPublishStatus\";\n    a.WORKER_EVENT = \"io.agora.pb.Wrtc.WorkerEvent\";\n    a.AP_WORKER_EVENT = \"io.agora.pb.Wrtc.APWorkerEvent\";\n    a.JOIN_WEB_PROXY_AP = \"io.agora.pb.Wrtc.JoinWebProxyAP\";\n    a.WEBSOCKET_QUIT = \"io.agora.pb.Wrtc.WebSocketQuit\";\n    a.USER_ANALYTICS = \"io.agora.pb.Wrtc.UserAnalytics\";\n  })(ma || (ma = {}));\n\n  (function (a) {\n    a[a.WORKER_EVENT = 156] = \"WORKER_EVENT\";\n    a[a.AP_WORKER_EVENT = 160] = \"AP_WORKER_EVENT\";\n  })(ek || (ek = {}));\n\n  (function (a) {\n    a.CREATE_CLIENT = \"createClient\";\n    a.CHECK_SYSTEM_REQUIREMENTS = \"checkSystemRequirements\";\n    a.SET_AREA = \"setArea\";\n    a.CHECK_VIDEO_TRACK_IS_ACTIVE = \"checkVideoTrackIsActive\";\n    a.CHECK_AUDIO_TRACK_IS_ACTIVE = \"checkAudioTrackIsActive\";\n    a.CREATE_MIC_AUDIO_TRACK = \"createMicrophoneAudioTrack\";\n    a.CREATE_CUSTOM_AUDIO_TRACK = \"createCustomAudioTrack\";\n    a.CREATE_BUFFER_AUDIO_TRACK = \"createBufferSourceAudioTrack\";\n    a.CREATE_CAM_VIDEO_TRACK = \"createCameraVideoTrack\";\n    a.CREATE_CUSTOM_VIDEO_TRACK = \"createCustomVideoTrack\";\n    a.CREATE_MIC_AND_CAM_TRACKS = \"createMicrophoneAndCameraTracks\";\n    a.CREATE_SCREEN_VIDEO_TRACK = \"createScreenVideoTrack\";\n    a.SET_ENCRYPTION_CONFIG = \"Client.setEncryptionConfig\";\n    a.START_PROXY_SERVER = \"Client.startProxyServer\";\n    a.STOP_PROXY_SERVER = \"Client.stopProxyServer\";\n    a.SET_PROXY_SERVER = \"Client.setProxyServer\";\n    a.SET_TURN_SERVER = \"Client.setTurnServer\";\n    a.SET_CLIENT_ROLE = \"Client.setClientRole\";\n    a.SET_LOW_STREAM_PARAMETER = \"Client.setLowStreamParameter\";\n    a.ENABLE_DUAL_STREAM = \"Client.enableDualStream\";\n    a.DISABLE_DUAL_STREAM = \"Client.disableDualStream\";\n    a.JOIN = \"Client.join\";\n    a.LEAVE = \"Client.leave\";\n    a.PUBLISH = \"Client.publish\";\n    a.UNPUBLISH = \"Client.unpublish\";\n    a.SUBSCRIBE = \"Client.subscribe\";\n    a.UNSUBSCRIBE = \"Client.unsubscribe\";\n    a.RENEW_TOKEN = \"Client.renewToken\";\n    a.SET_REMOTE_VIDEO_STREAM_TYPE = \"Client.setRemoteVideoStreamType\";\n    a.SET_STREAM_FALLBACK_OPTION = \"Client.setStreamFallbackOption\";\n    a.ENABLE_AUDIO_VOLUME_INDICATOR = \"Client.enableAudioVolumeIndicator\";\n    a.SEND_CUSTOM_REPORT_MESSAGE = \"Client.sendCustomReportMessage\";\n    a.ON_LIVE_STREAM_WARNING = \"Client.onLiveStreamWarning\";\n    a.ON_LIVE_STREAM_ERROR = \"Client.onLiveStreamingError\";\n    a.START_LIVE_STREAMING = \"Client.startLiveStreaming\";\n    a.SET_LIVE_TRANSCODING = \"Client.setLiveTranscoding\";\n    a.STOP_LIVE_STREAMING = \"Client.stopLiveStreaming\";\n    a.ADD_INJECT_STREAM_URL = \"Client.addInjectStreamUrl\";\n    a.REMOVE_INJECT_STREAM_URL = \"Client.removeInjectStreamUrl\";\n    a.START_CHANNEL_MEDIA_RELAY = \"Client.startChannelMediaRelay\";\n    a.UPDATE_CHANNEL_MEDIA_RELAY = \"Client.updateChannelMediaRelay\";\n    a.STOP_CHANNEL_MEDIA_RELAY = \"Client.stopChannelMediaRelay\";\n    a.REQUEST_CONFIG_DISTRIBUTE = \"_config-distribute-request\";\n    a.SET_CONFIG_DISTRIBUTE = \"_configDistribute\";\n    a.LOCAL_TRACK_SET_MUTED = \"LocalTrack.setMute\";\n    a.LOCAL_AUDIO_TRACK_PLAY = \"LocalAudioTrack.play\";\n    a.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = \"LocalAudioTrack.playInElement\";\n    a.LOCAL_AUDIO_TRACK_STOP = \"LocalAudioTrack.stop\";\n    a.LOCAL_AUDIO_TRACK_SET_VOLUME = \"LocalAudioTrack.setVolume\";\n    a.MIC_AUDIO_TRACK_SET_DEVICE = \"MicrophoneAudioTrack.setDevice\";\n    a.BUFFER_AUDIO_TRACK_START = \"BufferSourceAudioTrack.startProcessAudioBuffer\";\n    a.BUFFER_AUDIO_TRACK_STOP = \"BufferSourceAudioTrack.stopProcessAudioBuffer\";\n    a.BUFFER_AUDIO_TRACK_PAUSE = \"BufferSourceAudioTrack.pauseProcessAudioBuffer\";\n    a.BUFFER_AUDIO_TRACK_RESUME = \"BufferSourceAudioTrack.resumeProcessAudioBuffer\";\n    a.BUFFER_AUDIO_TRACK_SEEK = \"BufferSourceAudioTrack.seekAudioBuffer\";\n    a.LOCAL_VIDEO_TRACK_PLAY = \"LocalVideoTrack.play\";\n    a.LOCAL_VIDEO_TRACK_STOP = \"LocalVideoTrack.stop\";\n    a.LOCAL_VIDEO_TRACK_BEAUTY = \"LocalVideoTrack.setBeautyEffect\";\n    a.CAM_VIDEO_TRACK_SET_DEVICE = \"CameraVideoTrack.setDevice\";\n    a.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = \"CameraVideoTrack.setEncoderConfiguration\";\n    a.REMOTE_VIDEO_TRACK_PLAY = \"RemoteVideoTrack.play\";\n    a.REMOTE_VIDEO_TRACK_STOP = \"RemoteVideoTrack.stop\";\n    a.REMOTE_AUDIO_TRACK_PLAY = \"RemoteAudioTrack.play\";\n    a.REMOTE_AUDIO_TRACK_STOP = \"RemoteAudioTrack.stop\";\n    a.REMOTE_AUDIO_SET_VOLUME = \"RemoteAudioTrack.setVolume\";\n    a.REMOTE_AUDIO_SET_OUTPUT_DEVICE = \"RemoteAudioTrack.setOutputDevice\";\n    a.GET_MEDIA_STREAM_TRACK = \"Track.getMediaStreamTrack\";\n    a.STREAM_TYPE_CHANGE = \"streamTypeChange\";\n  })(C || (C = {}));\n\n  (B || (B = {})).TRACER = \"tracer\";\n\n  (function (a) {\n    a.IDLE = \"IDLE\";\n    a.INITING = \"INITING\";\n    a.INITEND = \"INITEND\";\n  })(hc || (hc = {}));\n\n  (function (a) {\n    a.STATE_CHANGE = \"state_change\";\n    a.RECORDING_DEVICE_CHANGED = \"recordingDeviceChanged\";\n    a.PLAYOUT_DEVICE_CHANGED = \"playoutDeviceChanged\";\n    a.CAMERA_DEVICE_CHANGED = \"cameraDeviceChanged\";\n  })(Kb || (Kb = {}));\n\n  (function (a) {\n    a[a.ACCESS_POINT = 101] = \"ACCESS_POINT\";\n    a[a.UNILBS = 201] = \"UNILBS\";\n    a[a.STRING_UID_ALLOCATOR = 901] = \"STRING_UID_ALLOCATOR\";\n  })(oc || (oc = {}));\n\n  (function (a) {\n    a[a.IIIEGAL_APPID = 1] = \"IIIEGAL_APPID\";\n    a[a.IIIEGAL_UID = 2] = \"IIIEGAL_UID\";\n    a[a.INTERNAL_ERROR = 3] = \"INTERNAL_ERROR\";\n  })(ed || (ed = {}));\n\n  (function (a) {\n    a[a.INVALID_VENDOR_KEY = 5] = \"INVALID_VENDOR_KEY\";\n    a[a.INVALID_CHANNEL_NAME = 7] = \"INVALID_CHANNEL_NAME\";\n    a[a.INTERNAL_ERROR = 8] = \"INTERNAL_ERROR\";\n    a[a.NO_AUTHORIZED = 9] = \"NO_AUTHORIZED\";\n    a[a.DYNAMIC_KEY_TIMEOUT = 10] = \"DYNAMIC_KEY_TIMEOUT\";\n    a[a.NO_ACTIVE_STATUS = 11] = \"NO_ACTIVE_STATUS\";\n    a[a.DYNAMIC_KEY_EXPIRED = 13] = \"DYNAMIC_KEY_EXPIRED\";\n    a[a.STATIC_USE_DYNAMIC_KEY = 14] = \"STATIC_USE_DYNAMIC_KEY\";\n    a[a.DYNAMIC_USE_STATIC_KEY = 15] = \"DYNAMIC_USE_STATIC_KEY\";\n    a[a.USER_OVERLOAD = 16] = \"USER_OVERLOAD\";\n    a[a.FORBIDDEN_REGION = 18] = \"FORBIDDEN_REGION\";\n    a[a.CANNOT_MEET_AREA_DEMAND = 19] = \"CANNOT_MEET_AREA_DEMAND\";\n  })(Wa || (Wa = {}));\n\n  (function (a) {\n    a[a.NO_FLAG_SET = 100] = \"NO_FLAG_SET\";\n    a[a.FLAG_SET_BUT_EMPTY = 101] = \"FLAG_SET_BUT_EMPTY\";\n    a[a.INVALID_FALG_SET = 102] = \"INVALID_FALG_SET\";\n    a[a.NO_SERVICE_AVAILABLE = 200] = \"NO_SERVICE_AVAILABLE\";\n    a[a.NO_SERVICE_AVAILABLE_P2P = 201] = \"NO_SERVICE_AVAILABLE_P2P\";\n    a[a.NO_SERVICE_AVAILABLE_VOICE = 202] = \"NO_SERVICE_AVAILABLE_VOICE\";\n    a[a.NO_SERVICE_AVAILABLE_WEBRTC = 203] = \"NO_SERVICE_AVAILABLE_WEBRTC\";\n    a[a.NO_SERVICE_AVAILABLE_CDS = 204] = \"NO_SERVICE_AVAILABLE_CDS\";\n    a[a.NO_SERVICE_AVAILABLE_CDN = 205] = \"NO_SERVICE_AVAILABLE_CDN\";\n    a[a.NO_SERVICE_AVAILABLE_TDS = 206] = \"NO_SERVICE_AVAILABLE_TDS\";\n    a[a.NO_SERVICE_AVAILABLE_REPORT = 207] = \"NO_SERVICE_AVAILABLE_REPORT\";\n    a[a.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = \"NO_SERVICE_AVAILABLE_APP_CENTER\";\n    a[a.NO_SERVICE_AVAILABLE_ENV0 = 209] = \"NO_SERVICE_AVAILABLE_ENV0\";\n    a[a.NO_SERVICE_AVAILABLE_VOET = 210] = \"NO_SERVICE_AVAILABLE_VOET\";\n    a[a.NO_SERVICE_AVAILABLE_STRING_UID = 211] = \"NO_SERVICE_AVAILABLE_STRING_UID\";\n    a[a.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = \"NO_SERVICE_AVAILABLE_WEBRTC_UNILBS\";\n    a[a.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = \"NO_SERVICE_AVAILABLE_UNILBS_FLV\";\n  })(Da || (Da = {}));\n\n  (function (a) {\n    a[a.K_TIMESTAMP_EXPIRED = 2] = \"K_TIMESTAMP_EXPIRED\";\n    a[a.K_CHANNEL_PERMISSION_INVALID = 3] = \"K_CHANNEL_PERMISSION_INVALID\";\n    a[a.K_CERTIFICATE_INVALID = 4] = \"K_CERTIFICATE_INVALID\";\n    a[a.K_CHANNEL_NAME_EMPTY = 5] = \"K_CHANNEL_NAME_EMPTY\";\n    a[a.K_CHANNEL_NOT_FOUND = 6] = \"K_CHANNEL_NOT_FOUND\";\n    a[a.K_TICKET_INVALID = 7] = \"K_TICKET_INVALID\";\n    a[a.K_CHANNEL_CONFLICTED = 8] = \"K_CHANNEL_CONFLICTED\";\n    a[a.K_SERVICE_NOT_READY = 9] = \"K_SERVICE_NOT_READY\";\n    a[a.K_SERVICE_TOO_HEAVY = 10] = \"K_SERVICE_TOO_HEAVY\";\n    a[a.K_UID_BANNED = 14] = \"K_UID_BANNED\";\n    a[a.K_IP_BANNED = 15] = \"K_IP_BANNED\";\n    a[a.K_CHANNEL_BANNED = 16] = \"K_CHANNEL_BANNED\";\n    a[a.WARN_NO_AVAILABLE_CHANNEL = 103] = \"WARN_NO_AVAILABLE_CHANNEL\";\n    a[a.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = \"WARN_LOOKUP_CHANNEL_TIMEOUT\";\n    a[a.WARN_LOOKUP_CHANNEL_REJECTED = 105] = \"WARN_LOOKUP_CHANNEL_REJECTED\";\n    a[a.WARN_OPEN_CHANNEL_TIMEOUT = 106] = \"WARN_OPEN_CHANNEL_TIMEOUT\";\n    a[a.WARN_OPEN_CHANNEL_REJECTED = 107] = \"WARN_OPEN_CHANNEL_REJECTED\";\n    a[a.WARN_REQUEST_DEFERRED = 108] = \"WARN_REQUEST_DEFERRED\";\n    a[a.ERR_DYNAMIC_KEY_TIMEOUT = 109] = \"ERR_DYNAMIC_KEY_TIMEOUT\";\n    a[a.ERR_NO_AUTHORIZED = 110] = \"ERR_NO_AUTHORIZED\";\n    a[a.ERR_VOM_SERVICE_UNAVAILABLE = 111] = \"ERR_VOM_SERVICE_UNAVAILABLE\";\n    a[a.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = \"ERR_NO_CHANNEL_AVAILABLE_CODE\";\n    a[a.ERR_MASTER_VOCS_UNAVAILABLE = 114] = \"ERR_MASTER_VOCS_UNAVAILABLE\";\n    a[a.ERR_INTERNAL_ERROR = 115] = \"ERR_INTERNAL_ERROR\";\n    a[a.ERR_NO_ACTIVE_STATUS = 116] = \"ERR_NO_ACTIVE_STATUS\";\n    a[a.ERR_INVALID_UID = 117] = \"ERR_INVALID_UID\";\n    a[a.ERR_DYNAMIC_KEY_EXPIRED = 118] = \"ERR_DYNAMIC_KEY_EXPIRED\";\n    a[a.ERR_STATIC_USE_DYANMIC_KE = 119] = \"ERR_STATIC_USE_DYANMIC_KE\";\n    a[a.ERR_DYNAMIC_USE_STATIC_KE = 120] = \"ERR_DYNAMIC_USE_STATIC_KE\";\n    a[a.ERR_NO_VOCS_AVAILABLE = 2E3] = \"ERR_NO_VOCS_AVAILABLE\";\n    a[a.ERR_NO_VOS_AVAILABLE = 2001] = \"ERR_NO_VOS_AVAILABLE\";\n    a[a.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = \"ERR_JOIN_CHANNEL_TIMEOUT\";\n    a[a.ERR_REPEAT_JOIN_CHANNEL = 2003] = \"ERR_REPEAT_JOIN_CHANNEL\";\n    a[a.ERR_JOIN_BY_MULTI_IP = 2004] = \"ERR_JOIN_BY_MULTI_IP\";\n    a[a.ERR_NOT_JOINED = 2011] = \"ERR_NOT_JOINED\";\n    a[a.ERR_REPEAT_JOIN_REQUEST = 2012] = \"ERR_REPEAT_JOIN_REQUEST\";\n    a[a.ERR_INVALID_VENDOR_KEY = 2013] = \"ERR_INVALID_VENDOR_KEY\";\n    a[a.ERR_INVALID_CHANNEL_NAME = 2014] = \"ERR_INVALID_CHANNEL_NAME\";\n    a[a.ERR_INVALID_STRINGUID = 2015] = \"ERR_INVALID_STRINGUID\";\n    a[a.ERR_TOO_MANY_USERS = 2016] = \"ERR_TOO_MANY_USERS\";\n    a[a.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = \"ERR_SET_CLIENT_ROLE_TIMEOUT\";\n    a[a.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = \"ERR_SET_CLIENT_ROLE_NO_PERMISSION\";\n    a[a.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\";\n    a[a.ERR_PUBLISH_REQUEST_INVALID = 2020] = \"ERR_PUBLISH_REQUEST_INVALID\";\n    a[a.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = \"ERR_SUBSCRIBE_REQUEST_INVALID\";\n    a[a.ERR_NOT_SUPPORTED_MESSAGE = 2022] = \"ERR_NOT_SUPPORTED_MESSAGE\";\n    a[a.ERR_ILLEAGAL_PLUGIN = 2023] = \"ERR_ILLEAGAL_PLUGIN\";\n    a[a.ERR_REJOIN_TOKEN_INVALID = 2024] = \"ERR_REJOIN_TOKEN_INVALID\";\n    a[a.ERR_REJOIN_USER_NOT_JOINED = 2025] = \"ERR_REJOIN_USER_NOT_JOINED\";\n    a[a.ERR_INVALID_OPTIONAL_INFO = 2027] = \"ERR_INVALID_OPTIONAL_INFO\";\n    a[a.ILLEGAL_AES_PASSWORD = 2028] = \"ILLEGAL_AES_PASSWORD\";\n    a[a.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = \"ILLEGAL_CLIENT_ROLE_LEVEL\";\n    a[a.ERR_TEST_RECOVER = 9E3] = \"ERR_TEST_RECOVER\";\n    a[a.ERR_TEST_TRYNEXT = 9001] = \"ERR_TEST_TRYNEXT\";\n    a[a.ERR_TEST_RETRY = 9002] = \"ERR_TEST_RETRY\";\n  })(F || (F = {}));\n\n  (function (a) {\n    a.CONNECTION_STATE_CHANGE = \"connection-state-change\";\n    a.MEDIA_RECONNECT_START = \"media-reconnect-start\";\n    a.MEDIA_RECONNECT_END = \"media-reconnect-end\";\n    a.IS_USING_CLOUD_PROXY = \"is-using-cloud-proxy\";\n    a.USER_JOINED = \"user-joined\";\n    a.USER_LEAVED = \"user-left\";\n    a.USER_PUBLISHED = \"user-published\";\n    a.USER_UNPUBLISHED = \"user-unpublished\";\n    a.USER_INFO_UPDATED = \"user-info-updated\";\n    a.CLIENT_BANNED = \"client-banned\";\n    a.CHANNEL_MEDIA_RELAY_STATE = \"channel-media-relay-state\";\n    a.CHANNEL_MEDIA_RELAY_EVENT = \"channel-media-relay-event\";\n    a.VOLUME_INDICATOR = \"volume-indicator\";\n    a.CRYPT_ERROR = \"crypt-error\";\n    a.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"token-privilege-will-expire\";\n    a.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"token-privilege-did-expire\";\n    a.NETWORK_QUALITY = \"network-quality\";\n    a.STREAM_TYPE_CHANGED = \"stream-type-changed\";\n    a.STREAM_FALLBACK = \"stream-fallback\";\n    a.RECEIVE_METADATA = \"receive-metadata\";\n    a.STREAM_MESSAGE = \"stream-message\";\n    a.LIVE_STREAMING_ERROR = \"live-streaming-error\";\n    a.LIVE_STREAMING_WARNING = \"live-streaming-warning\";\n    a.INJECT_STREAM_STATUS = \"stream-inject-status\";\n    a.EXCEPTION = \"exception\";\n    a.ERROR = \"error\";\n  })(P || (P = {}));\n\n  (function (a) {\n    a.NETWORK_ERROR = \"NETWORK_ERROR\";\n    a.SERVER_ERROR = \"SERVER_ERROR\";\n    a.MULTI_IP = \"MULTI_IP\";\n    a.TIMEOUT = \"TIMEOUT\";\n    a.OFFLINE = \"OFFLINE\";\n    a.LEAVE = \"LEAVE\";\n  })(Ra || (Ra = {}));\n\n  (function (a) {\n    a.CONNECTING = \"connecting\";\n    a.CONNECTED = \"connected\";\n    a.RECONNECTING = \"reconnecting\";\n    a.CLOSED = \"closed\";\n  })(ta || (ta = {}));\n\n  (function (a) {\n    a.WS_CONNECTED = \"ws_connected\";\n    a.WS_RECONNECTING = \"ws_reconnecting\";\n    a.WS_CLOSED = \"ws_closed\";\n    a.ON_BINARY_DATA = \"on_binary_data\";\n    a.REQUEST_RECOVER = \"request_recover\";\n    a.REQUEST_JOIN_INFO = \"request_join_info\";\n    a.REQUEST_REJOIN_INFO = \"req_rejoin_info\";\n    a.IS_P2P_DISCONNECTED = \"is_p2p_dis\";\n    a.DISCONNECT_P2P = \"dis_p2p\";\n    a.NEED_RENEW_SESSION = \"need-sid\";\n    a.REPORT_JOIN_GATEWAY = \"report_join_gateway\";\n    a.REQUEST_TIMEOUT = \"request_timeout\";\n    a.REQUEST_SUCCESS = \"request_success\";\n  })(Q || (Q = {}));\n\n  (function (a) {\n    a.PING = \"ping\";\n    a.PING_BACK = \"ping_back\";\n    a.JOIN = \"join_v2\";\n    a.REJOIN = \"rejoin\";\n    a.LEAVE = \"leave\";\n    a.SET_CLIENT_ROLE = \"set_client_role\";\n    a.PUBLISH = \"publish\";\n    a.UNPUBLISH = \"unpublish\";\n    a.SUBSCRIBE = \"subscribe\";\n    a.UNSUBSCRIBE = \"unsubscribe\";\n    a.SUBSCRIBE_CHANGE = \"subscribe_change\";\n    a.TRAFFIC_STATS = \"traffic_stats\";\n    a.RENEW_TOKEN = \"renew_token\";\n    a.SWITCH_VIDEO_STREAM = \"switch_video_stream\";\n    a.SET_FALLBACK_OPTION = \"set_fallback_option\";\n    a.GATEWAY_INFO = \"gateway_info\";\n    a.CONTROL = \"control\";\n    a.SEND_METADATA = \"send_metadata\";\n    a.DATA_STREAM = \"data_stream\";\n    a.PICK_SVC_LAYER = \"pick_svc_layer\";\n  })(da || (da = {}));\n\n  (function (a) {\n    a.PUBLISH_STATS = \"publish_stats\";\n    a.PUBLISH_RELATED_STATS = \"publish_related_stats\";\n    a.SUBSCRIBE_STATS = \"subscribe_stats\";\n    a.SUBSCRIBE_RELATED_STATS = \"subscribe_related_stats\";\n  })(qb || (qb = {}));\n\n  (function (a) {\n    a.ON_USER_ONLINE = \"on_user_online\";\n    a.ON_USER_OFFLINE = \"on_user_offline\";\n    a.ON_STREAM_FALLBACK_UPDATE = \"on_stream_fallback_update\";\n    a.ON_PUBLISH_STREAM = \"on_publish_stream\";\n    a.ON_UPLINK_STATS = \"on_uplink_stats\";\n    a.ON_P2P_LOST = \"on_p2p_lost\";\n    a.ON_REMOVE_STREAM = \"on_remove_stream\";\n    a.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\";\n    a.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\";\n    a.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"on_token_privilege_will_expire\";\n    a.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"on_token_privilege_did_expire\";\n    a.ON_USER_BANNED = \"on_user_banned\";\n    a.ON_NOTIFICATION = \"on_notification\";\n    a.ON_CRYPT_ERROR = \"on_crypt_error\";\n    a.MUTE_AUDIO = \"mute_audio\";\n    a.MUTE_VIDEO = \"mute_video\";\n    a.UNMUTE_AUDIO = \"unmute_audio\";\n    a.UNMUTE_VIDEO = \"unmute_video\";\n    a.RECEIVE_METADATA = \"receive_metadata\";\n    a.ON_DATA_STREAM = \"on_data_stream\";\n    a.ENABLE_LOCAL_VIDEO = \"enable_local_video\";\n    a.DISABLE_LOCAL_VIDEO = \"disable_local_video\";\n    a.ENABLE_LOCAL_AUDIO = \"enable_local_audio\";\n    a.DISABLE_LOCAL_AUDIO = \"disable_local_audio\";\n  })(U || (U = {}));\n\n  (function (a) {\n    a.CONNECTION_STATE_CHANGE = \"CONNECTION_STATE_CHANGE\";\n    a.NEED_ANSWER = \"NEED_ANSWER\";\n    a.NEED_RENEGOTIATE = \"NEED_RENEGOTIATE\";\n    a.P2P_LOST = \"P2P_LOST\";\n    a.GATEWAY_P2P_LOST = \"GATEWAY_P2P_LOST\";\n    a.NEED_UNPUB = \"NEED_UNPUB\";\n    a.NEED_UNSUB = \"NEED_UNSUB\";\n    a.NEED_UPLOAD = \"NEED_UPLOAD\";\n    a.START_RECONNECT = \"START_RECONNECT\";\n    a.END_RECONNECT = \"END_RECONNECT\";\n    a.NEED_SIGNAL_RTT = \"NEED_SIGNAL_RTT\";\n  })(H || (H = {}));\n\n  (function (a) {\n    a.AUDIO_SOURCE_STATE_CHANGE = \"audio_source_state_change\";\n    a.RECEIVE_TRACK_BUFFER = \"receive_track_buffer\";\n    a.ON_AUDIO_BUFFER = \"on_audio_buffer\";\n  })(ib || (ib = {}));\n\n  let ke = {\n    sendVolumeLevel: 0,\n    sendBitrate: 0,\n    sendBytes: 0,\n    sendPackets: 0,\n    sendPacketsLost: 0\n  },\n      le = {\n    sendBytes: 0,\n    sendBitrate: 0,\n    sendPackets: 0,\n    sendPacketsLost: 0,\n    sendResolutionHeight: 0,\n    sendResolutionWidth: 0,\n    captureResolutionHeight: 0,\n    captureResolutionWidth: 0,\n    targetSendBitrate: 0,\n    totalDuration: 0,\n    totalFreezeTime: 0\n  },\n      Qf = {\n    transportDelay: 0,\n    end2EndDelay: 0,\n    receiveBitrate: 0,\n    receiveLevel: 0,\n    receiveBytes: 0,\n    receiveDelay: 0,\n    receivePackets: 0,\n    receivePacketsLost: 0,\n    totalDuration: 0,\n    totalFreezeTime: 0,\n    freezeRate: 0,\n    packetLossRate: 0,\n    publishDuration: -1\n  },\n      fk = {\n    uplinkNetworkQuality: 0,\n    downlinkNetworkQuality: 0\n  },\n      Rf = {\n    transportDelay: 0,\n    end2EndDelay: 0,\n    receiveBitrate: 0,\n    receiveBytes: 0,\n    receiveDelay: 0,\n    receivePackets: 0,\n    receivePacketsLost: 0,\n    receiveResolutionHeight: 0,\n    receiveResolutionWidth: 0,\n    totalDuration: 0,\n    totalFreezeTime: 0,\n    freezeRate: 0,\n    packetLossRate: 0,\n    publishDuration: -1\n  };\n  var S, oa;\n  !function (a) {\n    a.CONNECTED = \"websocket:connected\";\n    a.RECONNECTING = \"websocket:reconnecting\";\n    a.WILL_RECONNECT = \"websocket:will_reconnect\";\n    a.CLOSED = \"websocket:closed\";\n    a.FAILED = \"websocket:failed\";\n    a.ON_MESSAGE = \"websocket:on_message\";\n    a.REQUEST_NEW_URLS = \"websocket:request_new_urls\";\n  }(S || (S = {}));\n\n  (function (a) {\n    a.TRANSCODE = \"mix_streaming\";\n    a.RAW = \"raw_streaming\";\n    a.INJECT = \"inject_streaming\";\n  })(oa || (oa = {}));\n\n  let Tn = {\n    alpha: 1,\n    height: 640,\n    width: 360,\n    x: 0,\n    y: 0,\n    zOrder: 0,\n    audioChannel: 0\n  },\n      Sf = {\n    x: 0,\n    y: 0,\n    width: 160,\n    height: 160,\n    zOrder: 255,\n    alpha: 1\n  },\n      Un = {\n    audioBitrate: 48,\n    audioChannels: 1,\n    audioSampleRate: 48E3,\n    backgroundColor: 0,\n    height: 360,\n    lowLatency: !1,\n    videoBitrate: 400,\n    videoCodecProfile: 100,\n    videoCodecType: 1,\n    videoFrameRate: 15,\n    videoGop: 30,\n    width: 640,\n    images: [],\n    userConfigs: [],\n    userConfigExtraInfo: \"\"\n  },\n      Vn = {\n    audioBitrate: 48,\n    audioChannels: 2,\n    audioVolume: 100,\n    audioSampleRate: 48E3,\n    height: 0,\n    width: 0,\n    videoBitrate: 400,\n    videoFramerate: 15,\n    videoGop: 30\n  };\n  var jb, Ec, ja, gk, Ea, xa, M, rb, fd, gd;\n  !function (a) {\n    a.WARNING = \"@live_uap-warning\";\n    a.ERROR = \"@line_uap-error\";\n    a.PUBLISH_STREAM_STATUS = \"@live_uap-publish-status\";\n    a.INJECT_STREAM_STATUS = \"@live_uap-inject-status\";\n    a.WORKER_STATUS = \"@live_uap-worker-status\";\n    a.REQUEST_NEW_ADDRESS = \"@live_uap-request-address\";\n  }(jb || (jb = {}));\n  (Ec || (Ec = {})).REQUEST_WORKER_MANAGER_LIST = \"@live_req_worker_manager\";\n\n  (function (a) {\n    a[a.LIVE_STREAM_RESPONSE_SUCCEED = 200] = \"LIVE_STREAM_RESPONSE_SUCCEED\";\n    a[a.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = \"LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM\";\n    a[a.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = \"LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR\";\n    a[a.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = \"LIVE_STREAM_RESPONSE_BAD_STREAM\";\n    a[a.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = \"LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR\";\n    a[a.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = \"LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST\";\n    a[a.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = \"LIVE_STREAM_RESPONSE_NOT_AUTHORIZED\";\n    a[a.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = \"LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE\";\n    a[a.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = \"LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN\";\n    a[a.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = \"LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH\";\n    a[a.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = \"LIVE_STREAM_RESPONSE_NOT_SUPPORTED\";\n    a[a.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = \"LIVE_STREAM_RESPONSE_MAX_STREAM_NUM\";\n    a[a.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = \"LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR\";\n    a[a.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = \"LIVE_STREAM_RESPONSE_WORKER_LOST\";\n    a[a.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = \"LIVE_STREAM_RESPONSE_RESOURCE_LIMIT\";\n    a[a.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = \"LIVE_STREAM_RESPONSE_WORKER_QUIT\";\n    a[a.ERROR_FAIL_SEND_MESSAGE = 504] = \"ERROR_FAIL_SEND_MESSAGE\";\n    a[a.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE\";\n    a[a.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT\";\n    a[a.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH\";\n    a[a.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = \"PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN\";\n  })(ja || (ja = {}));\n\n  (function (a) {\n    a.CONNECT_FAILED = \"connect failed\";\n    a.CONNECT_TIMEOUT = \"connect timeout\";\n    a.WS_DISCONNECTED = \"websocket disconnected\";\n    a.REQUEST_TIMEOUT = \"request timeout\";\n    a.REQUEST_FAILED = \"request failed\";\n    a.WAIT_STATUS_TIMEOUT = \"wait status timeout\";\n    a.WAIT_STATUS_ERROR = \"wait status error\";\n    a.BAD_STATE = \"bad state\";\n    a.WS_ABORT = \"ws abort\";\n    a.AP_REQUEST_TIMEOUT = \"AP request timeout\";\n    a.AP_JSON_PARSE_ERROR = \"AP json parse error\";\n    a.AP_REQUEST_ERROR = \"AP request error\";\n    a.AP_REQUEST_ABORT = \"AP request abort\";\n  })(gk || (gk = {}));\n\n  (function (a) {\n    a[a.SetSdkProfile = 0] = \"SetSdkProfile\";\n    a[a.SetSourceChannel = 1] = \"SetSourceChannel\";\n    a[a.SetSourceUserId = 2] = \"SetSourceUserId\";\n    a[a.SetDestChannel = 3] = \"SetDestChannel\";\n    a[a.StartPacketTransfer = 4] = \"StartPacketTransfer\";\n    a[a.StopPacketTransfer = 5] = \"StopPacketTransfer\";\n    a[a.UpdateDestChannel = 6] = \"UpdateDestChannel\";\n    a[a.Reconnect = 7] = \"Reconnect\";\n    a[a.SetVideoProfile = 8] = \"SetVideoProfile\";\n  })(Ea || (Ea = {}));\n\n  (function (a) {\n    a.DISCONNECT = \"disconnect\";\n    a.CONNECTION_STATE_CHANGE = \"connection-state-change\";\n    a.NETWORK_QUALITY = \"network-quality\";\n    a.STREAM_TYPE_CHANGE = \"stream-type-change\";\n    a.IS_P2P_DISCONNECTED = \"is-p2p-dis\";\n    a.DISCONNECT_P2P = \"dis-p2p\";\n    a.REQUEST_NEW_GATEWAY_LIST = \"req-gate-url\";\n    a.NEED_RENEW_SESSION = \"need-sid\";\n  })(xa || (xa = {}));\n\n  (function (a) {\n    a.NEED_RENEGOTIATE = \"@need_renegotiate\";\n    a.NEED_REPLACE_TRACK = \"@need_replace_track\";\n    a.NEED_CLOSE = \"@need_close\";\n    a.NEED_ADD_TRACK = \"@need_add_track\";\n    a.NEED_REMOVE_TRACK = \"@need_remove_track\";\n    a.NEED_SESSION_ID = \"@need_sid\";\n    a.SET_OPTIMIZATION_MODE = \"@set_optimization_mode\";\n    a.GET_STATS = \"@get_stats\";\n    a.GET_LOW_VIDEO_TRACK = \"@get_low_video_track\";\n    a.NEED_RESET_REMOTE_SDP = \"@need_reset_remote_sdp\";\n  })(M || (M = {}));\n\n  (function (a) {\n    a.SCREEN_TRACK = \"screen_track\";\n    a.LOW_STREAM = \"low_stream\";\n  })(rb || (rb = {}));\n\n  (function (a) {\n    a.SOURCE_STATE_CHANGE = \"source-state-change\";\n    a.TRACK_ENDED = \"track-ended\";\n    a.BEAUTY_EFFECT_OVERLOAD = \"beauty-effect-overload\";\n  })(fd || (fd = {}));\n\n  (gd || (gd = {})).FIRST_FRAME_DECODED = \"first-frame-decoded\";\n  let hk = \"AFRICA ASIA CHINA EUROPE GLOBAL INDIA JAPAN NORTH_AMERICA OCEANIA OVERSEA SOUTH_AMERICA\".split(\" \");\n  var ya;\n  !function (a) {\n    a.CHINA = \"CN\";\n    a.ASIA = \"AS\";\n    a.NORTH_AMERICA = \"NA\";\n    a.EUROPE = \"EU\";\n    a.JAPAN = \"JP\";\n    a.INDIA = \"IN\";\n    a.OCEANIA = \"OC\";\n    a.SOUTH_AMERICA = \"SA\";\n    a.AFRICA = \"AF\";\n    a.OVERSEA = \"OVERSEA\";\n    a.GLOBAL = \"GLOBAL\";\n  }(ya || (ya = {}));\n  let Tf = {\n    CHINA: {},\n    ASIA: {\n      CODE: ya.ASIA,\n      WEBCS_DOMAIN: [\"ap-web-1-asia.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-asia.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-asia.agora.io\"],\n      CDS_AP: [\"cds-ap-web-asia.agora.io\", \"cds-ap-web-asia2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-asia.agora.io\", \"sua-ap-web-asia2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-asia.agora.io\", \"uap-ap-web-asia2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-asia.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-asia.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-asia.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"southeast-asia.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    NORTH_AMERICA: {\n      CODE: ya.NORTH_AMERICA,\n      WEBCS_DOMAIN: [\"ap-web-1-north-america.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-north-america.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-america.agora.io\"],\n      CDS_AP: [\"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-north-america.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-north-america.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-north-america.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"east-usa.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    EUROPE: {\n      CODE: ya.EUROPE,\n      WEBCS_DOMAIN: [\"ap-web-1-europe.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-europe.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-europe.agora.io\"],\n      CDS_AP: [\"cds-ap-web-europe.agora.io\", \"cds-ap-web-europe2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-europe.agora.io\", \"sua-ap-web-europe.agora.io\"],\n      UAP_AP: [\"uap-ap-web-europe.agora.io\", \"uap-ap-web-europe2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-europe.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-europe.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-europe.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"europe.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    JAPAN: {\n      CODE: ya.JAPAN,\n      WEBCS_DOMAIN: [\"ap-web-1-japan.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-japan.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-japan.agora.io\"],\n      CDS_AP: [\"cds-ap-web-japan.agora.io\", \"cds-ap-web-japan2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-japan.agora.io\", \"sua-ap-web-japan2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-japan.agora.io\", \"\\tuap-ap-web-japan2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-japan.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-japan.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-japan.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"japan.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    INDIA: {\n      CODE: ya.INDIA,\n      WEBCS_DOMAIN: [\"ap-web-1-india.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-india.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-india.agora.io\"],\n      CDS_AP: [\"cds-ap-web-india.agora.io\", \"cds-ap-web-india2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-india.agora.io\", \"sua-ap-web-india2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-india.agora.io\", \"uap-ap-web-india2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-india.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-india.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-india.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"india.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    OVERSEA: {\n      CODE: ya.OVERSEA,\n      WEBCS_DOMAIN: [\"ap-web-1-oversea.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oversea.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-oversea.agora.io\"],\n      CDS_AP: [\"cds-ap-web-oversea.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-oversea.agora.io\"],\n      UAP_AP: [\"uap-ap-web-oversea.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-oversea.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oversea.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-oversea.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.agora.io\"]\n    },\n    GLOBAL: {\n      CODE: ya.GLOBAL,\n      WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\"],\n      PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n      CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-ap-web-3.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-ap-web-3.agora.io\"],\n      UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-ap-web-3.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    OCEANIA: {\n      CODE: ya.OCEANIA,\n      WEBCS_DOMAIN: [\"ap-web-1-oceania.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oceania.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-oceania.agora.io\"],\n      CDS_AP: [\"cds-ap-web-oceania.agora.io\", \"cds-ap-web-oceania2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-oceania.agora.io\", \"sua-ap-web-oceania2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-oceania.agora.io\", \"uap-ap-web-oceania2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-oceania.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oceania.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-oceania.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"oceania.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    SOUTH_AMERICA: {\n      CODE: ya.SOUTH_AMERICA,\n      WEBCS_DOMAIN: [\"ap-web-1-south-america.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-south-america.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-south-america.agora.io\"],\n      CDS_AP: [\"cds-ap-web-south-america.agora.io\", \"cds-ap-web-south-america2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-south-america.agora.io\", \"sua-ap-web-south-america2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-south-america.agora.io\", \"uap-ap-web-south-america2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-south-america.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-south-america.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-south-america.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"south-america.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    AFRICA: {\n      CODE: ya.AFRICA,\n      WEBCS_DOMAIN: [\"ap-web-1-africa.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-africa.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-africa.agora.io\"],\n      CDS_AP: [\"cds-ap-web-africa.agora.io\", \"cds-ap-web-africa2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-africa.agora.io\", \"sua-ap-web-africa2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-africa.agora.io\", \"uap-ap-web-africa2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-africa.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-africa.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-south-africa.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"africa.webrtc-cloud-proxy.sd-rtn.com\"]\n    }\n  };\n  var hd;\n  Mf && (Tf.CHINA = {\n    CODE: ya.CHINA,\n    WEBCS_DOMAIN: [\"webrtc2-2.ap.sd-rtn.com\"],\n    WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-4.ap.sd-rtn.com\"],\n    PROXY_CS: [\"proxy-web.ap.sd-rtn.com\"],\n    CDS_AP: [\"cds-web-2.ap.sd-rtn.com\", \"cds-web-4.ap.sd-rtn.com\"],\n    ACCOUNT_REGISTER: [\"sua-web-2.ap.sd-rtn.com\", \"sua-web-4.ap.sd-rtn.com\"],\n    UAP_AP: [\"uap-web-2.ap.sd-rtn.com\", \"uap-web-4.ap.sd-rtn.com\"],\n    EVENT_REPORT_DOMAIN: [\"web-3.statscollector.sd-rtn.com\"],\n    EVENT_REPORT_BACKUP_DOMAIN: [\"web-4.statscollector.sd-rtn.com\"],\n    LOG_UPLOAD_SERVER: [\"logservice-china.agora.io\"],\n    PROXY_SERVER_TYPE3: [\"east-cn.webrtc-cloud-proxy.sd-rtn.com\"]\n  });\n  (hd || (hd = {})).UPDATE_BITRATE_LIMIT = \"update_bitrate_limit\";\n  let ha = {\n    getDisplayMedia: !1,\n    getStreamFromExtension: !1,\n    supportUnifiedPlan: !1,\n    supportMinBitrate: !1,\n    supportSetRtpSenderParameters: !1,\n    supportDualStream: !0,\n    webAudioMediaStreamDest: !1,\n    supportReplaceTrack: !1,\n    supportWebGL: !1,\n    webAudioWithAEC: !1,\n    supportRequestFrame: !1,\n    supportShareAudio: !1,\n    supportDualStreamEncoding: !1\n  };\n  O({\n    target: \"Object\",\n    stat: !0,\n    forced: !la,\n    sham: !la\n  }, {\n    defineProperties: yi\n  });\n\n  var Oa = ub(function (a) {\n    var b = ia.Object;\n\n    a = a.exports = function (a, e) {\n      return b.defineProperties(a, e);\n    };\n\n    b.defineProperties.sham && (a.sham = !0);\n  }),\n      Wn = Wd.concat(\"length\", \"prototype\"),\n      Uf = {\n    f: Object.getOwnPropertyNames || function (a) {\n      return xi(a, Wn);\n    }\n  },\n      Xn = Hb(\"Reflect\", \"ownKeys\") || function (a) {\n    var b = Uf.f(Ua(a)),\n        c = Xc.f;\n    return c ? b.concat(c(a)) : b;\n  };\n\n  O({\n    target: \"Object\",\n    stat: !0,\n    sham: !la\n  }, {\n    getOwnPropertyDescriptors: function (a) {\n      var b, c;\n      a = gb(a);\n\n      for (var e = tc, g = Xn(a), h = {}, p = 0; g.length > p;) void 0 !== (c = e(a, b = g[p++])) && fc(h, b, c);\n\n      return h;\n    }\n  });\n\n  var fa = ia.Object.getOwnPropertyDescriptors,\n      ik = Uf.f,\n      Yn = {}.toString,\n      jk = \"object\" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],\n      kk = function (a) {\n    if (jk && \"[object Window]\" == Yn.call(a)) try {\n      var b = ik(a);\n    } catch (c) {\n      b = jk.slice();\n    } else b = ik(gb(a));\n    return b;\n  },\n      lk = {\n    f: wa\n  },\n      Zn = hb.f,\n      Xa = Td(\"hidden\"),\n      mk = wa(\"toPrimitive\"),\n      $n = ab.set,\n      nk = ab.getterFor(\"Symbol\"),\n      sb = Object.prototype,\n      bb = N.Symbol,\n      id = Hb(\"JSON\", \"stringify\"),\n      ok = tc,\n      Tb = hb.f,\n      pk = kk,\n      ao = Ld,\n      Lb = Ib(\"symbols\"),\n      jd = Ib(\"op-symbols\"),\n      Vf = Ib(\"string-to-symbol-registry\"),\n      Wf = Ib(\"symbol-to-string-registry\"),\n      bo = Ib(\"wks\"),\n      Xf = N.QObject,\n      Yf = !Xf || !Xf.prototype || !Xf.prototype.findChild,\n      Zf = la && sa(function () {\n    return 7 != ec(Tb({}, \"a\", {\n      get: function () {\n        return Tb(this, \"a\", {\n          value: 7\n        }).a;\n      }\n    })).a;\n  }) ? function (a, b, c) {\n    var e = ok(sb, b);\n    e && delete sb[b];\n    Tb(a, b, c);\n    e && a !== sb && Tb(sb, b, e);\n  } : Tb,\n      qk = function (a, b) {\n    var c = Lb[a] = ec(bb.prototype);\n    return $n(c, {\n      type: \"Symbol\",\n      tag: a,\n      description: b\n    }), la || (c.description = b), c;\n  },\n      $f = Bb && \"symbol\" == typeof bb.iterator ? function (a) {\n    return \"symbol\" == typeof a;\n  } : function (a) {\n    return Object(a) instanceof bb;\n  },\n      me = function (a, b, c) {\n    a === sb && me(jd, b, c);\n    Ua(a);\n    b = rc(b, !0);\n    return Ua(c), T(Lb, b) ? (c.enumerable ? (T(a, Xa) && a[Xa][b] && (a[Xa][b] = !1), c = ec(c, {\n      enumerable: $b(0, !1)\n    })) : (T(a, Xa) || Tb(a, Xa, $b(1, {})), a[Xa][b] = !0), Zf(a, b, c)) : Tb(a, b, c);\n  },\n      sk = function (a, b) {\n    Ua(a);\n    var c = gb(b);\n    b = Sb(c).concat(ag(c));\n    return wc(b, function (b) {\n      la && !rk.call(c, b) || me(a, b, c[b]);\n    }), a;\n  },\n      rk = function (a) {\n    a = rc(a, !0);\n    var b = ao.call(this, a);\n    return !(this === sb && T(Lb, a) && !T(jd, a)) && (!(b || !T(this, a) || !T(Lb, a) || T(this, Xa) && this[Xa][a]) || b);\n  },\n      tk = function (a, b) {\n    a = gb(a);\n    b = rc(b, !0);\n\n    if (a !== sb || !T(Lb, b) || T(jd, b)) {\n      var c = ok(a, b);\n      return !c || !T(Lb, b) || T(a, Xa) && a[Xa][b] || (c.enumerable = !0), c;\n    }\n  },\n      uk = function (a) {\n    a = pk(gb(a));\n    var b = [];\n    return wc(a, function (a) {\n      T(Lb, a) || T(vc, a) || b.push(a);\n    }), b;\n  },\n      ag = function (a) {\n    var b = a === sb;\n    a = pk(b ? jd : gb(a));\n    var c = [];\n    return wc(a, function (a) {\n      !T(Lb, a) || b && !T(sb, a) || c.push(Lb[a]);\n    }), c;\n  };\n\n  if (Bb || (kf((bb = function () {\n    if (this instanceof bb) throw TypeError(\"Symbol is not a constructor\");\n\n    var a = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,\n        b = Pd(a),\n        c = function (a) {\n      this === sb && c.call(jd, a);\n      T(this, Xa) && T(this[Xa], b) && (this[Xa][b] = !1);\n      Zf(this, b, $b(1, a));\n    };\n\n    return la && Yf && Zf(sb, b, {\n      configurable: !0,\n      set: c\n    }), qk(b, a);\n  }).prototype, \"toString\", function () {\n    return nk(this).tag;\n  }), Ld = rk, hb.f = me, tc = tk, Uf.f = kk = uk, Xc.f = ag, la && Tb(bb.prototype, \"description\", {\n    configurable: !0,\n    get: function () {\n      return nk(this).description;\n    }\n  })), ni || (lk.f = function (a) {\n    return qk(wa(a), a);\n  }), O({\n    global: !0,\n    wrap: !0,\n    forced: !Bb,\n    sham: !Bb\n  }, {\n    Symbol: bb\n  }), wc(Sb(bo), function (a) {\n    var b = ia.Symbol || (ia.Symbol = {});\n    T(b, a) || Zn(b, a, {\n      value: lk.f(a)\n    });\n    !0;\n  }), O({\n    target: \"Symbol\",\n    stat: !0,\n    forced: !Bb\n  }, {\n    for: function (a) {\n      a = String(a);\n      if (T(Vf, a)) return Vf[a];\n      var b = bb(a);\n      return Vf[a] = b, Wf[b] = a, b;\n    },\n    keyFor: function (a) {\n      if (!$f(a)) throw TypeError(a + \" is not a symbol\");\n      if (T(Wf, a)) return Wf[a];\n    },\n    useSetter: function () {\n      Yf = !0;\n    },\n    useSimple: function () {\n      Yf = !1;\n    }\n  }), O({\n    target: \"Object\",\n    stat: !0,\n    forced: !Bb,\n    sham: !la\n  }, {\n    create: function (a, b) {\n      return void 0 === b ? ec(a) : sk(ec(a), b);\n    },\n    defineProperty: me,\n    defineProperties: sk,\n    getOwnPropertyDescriptor: tk\n  }), O({\n    target: \"Object\",\n    stat: !0,\n    forced: !Bb\n  }, {\n    getOwnPropertyNames: uk,\n    getOwnPropertySymbols: ag\n  }), O({\n    target: \"Object\",\n    stat: !0,\n    forced: sa(function () {\n      Xc.f(1);\n    })\n  }, {\n    getOwnPropertySymbols: function (a) {\n      return Xc.f(ob(a));\n    }\n  }), id) {\n    var co = !Bb || sa(function () {\n      var a = bb();\n      return \"[null]\" != id([a]) || \"{}\" != id({\n        a\n      }) || \"{}\" != id(Object(a));\n    });\n    O({\n      target: \"JSON\",\n      stat: !0,\n      forced: co\n    }, {\n      stringify: function (a, b, c) {\n        for (var e, g = [a], h = 1; arguments.length > h;) g.push(arguments[h++]);\n\n        if (e = b, (Aa(b) || void 0 !== a) && !$f(a)) return cc(b) || (b = function (a, b) {\n          if (\"function\" == typeof e && (b = e.call(this, a, b)), !$f(b)) return b;\n        }), g[1] = b, id.apply(null, g);\n      }\n    });\n  }\n\n  bb.prototype[mk] || mb(bb.prototype, mk, bb.prototype.valueOf);\n  Uc(bb, \"Symbol\");\n  vc[Xa] = !0;\n\n  var ea = ia.Object.getOwnPropertySymbols,\n      Na = function (a, b, c) {\n    return b in a ? Ti(a, b, {\n      value: c,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : a[b] = c, a;\n  },\n      eo = za(\"Array\").values,\n      vk = Array.prototype,\n      fo = {\n    DOMTokenList: !0,\n    NodeList: !0\n  },\n      ic = function (a) {\n    var b = a.values;\n    return a === vk || a instanceof Array && b === vk.values || fo.hasOwnProperty(Sd(a)) ? eo : b;\n  },\n      go = !gj(function (a) {\n    Array.from(a);\n  });\n\n  O({\n    target: \"Array\",\n    stat: !0,\n    forced: go\n  }, {\n    from: function (a) {\n      var b = ob(a);\n      var c = \"function\" == typeof this ? this : Array;\n      var e = arguments.length;\n      var g = 1 < e ? arguments[1] : void 0,\n          h = void 0 !== g,\n          p = 0;\n      var k = qi(b);\n      if (h && (g = bc(g, 2 < e ? arguments[2] : void 0, 2)), null == k || c == Array && oi(k)) for (c = new c(e = nb(b.length)); e > p; p++) fc(c, p, h ? g(b[p], p) : b[p]);else for (e = (b = k.call(b)).next, c = new c(); !(k = e.call(b)).done; p++) fc(c, p, h ? ri(b, g, [k.value, p], !0) : k.value);\n      return c.length = p, c;\n    }\n  });\n  var Gb = ia.Array.from;\n  O({\n    target: \"Date\",\n    stat: !0\n  }, {\n    now: function () {\n      return new Date().getTime();\n    }\n  });\n  var x = ia.Date.now;\n\n  class Sa {\n    constructor() {\n      this._events = {};\n      this.addListener = this.on;\n    }\n\n    getListeners(a) {\n      var b;\n      return this._events[a] ? E(b = this._events[a]).call(b, a => a.listener) : [];\n    }\n\n    on(a, b) {\n      this._events[a] || (this._events[a] = []);\n      a = this._events[a];\n      -1 === this._indexOfListener(a, b) && a.push({\n        listener: b,\n        once: !1\n      });\n    }\n\n    once(a, b) {\n      this._events[a] || (this._events[a] = []);\n      a = this._events[a];\n      -1 === this._indexOfListener(a, b) && a.push({\n        listener: b,\n        once: !0\n      });\n    }\n\n    off(a, b) {\n      if (this._events[a]) {\n        var c = this._events[a];\n        b = this._indexOfListener(c, b);\n        -1 !== b && Ia(c).call(c, b, 1);\n        0 === this._events[a].length && delete this._events[a];\n      }\n    }\n\n    removeAllListeners(a) {\n      a ? delete this._events[a] : this._events = {};\n    }\n\n    emit(a, ...b) {\n      var c;\n      this._events[a] || (this._events[a] = []);\n      let e = E(c = this._events[a]).call(c, a => a);\n\n      for (c = 0; c < e.length; c += 1) {\n        let g = e[c];\n        g.once && this.off(a, g.listener);\n        g.listener.apply(this, b || []);\n      }\n    }\n\n    _indexOfListener(a, b) {\n      let c = a.length;\n\n      for (; c--;) if (a[c].listener === b) return c;\n\n      return -1;\n    }\n\n  }\n\n  class ho extends Sa {\n    constructor() {\n      super(...arguments);\n      this.resultStorage = new aa();\n    }\n\n    setLocalAudioStats(a, b, c) {\n      this.record(\"AUDIO_INPUT_LEVEL_TOO_LOW\", a, this.checkAudioInputLevel(c));\n      this.record(\"SEND_AUDIO_BITRATE_TOO_LOW\", a, this.checkSendAudioBitrate(c));\n    }\n\n    setLocalVideoStats(a, b, c) {\n      this.record(\"SEND_VIDEO_BITRATE_TOO_LOW\", a, this.checkSendVideoBitrate(c));\n      this.record(\"FRAMERATE_INPUT_TOO_LOW\", a, this.checkFramerateInput(c, b));\n      this.record(\"FRAMERATE_SENT_TOO_LOW\", a, this.checkFramerateSent(c));\n    }\n\n    setRemoteAudioStats(a, b) {\n      a = a.getUserId();\n      this.record(\"AUDIO_OUTPUT_LEVEL_TOO_LOW\", a, this.checkAudioOutputLevel(b));\n    }\n\n    setRemoteVideoStats(a, b) {\n      a = a.getUserId();\n      this.record(\"RECV_VIDEO_DECODE_FAILED\", a, this.checkVideoDecode(b));\n    }\n\n    record(a, b, c) {\n      this.resultStorage.has(a) || this.resultStorage.set(a, {\n        result: [],\n        isPrevNormal: !0\n      });\n      let e = this.resultStorage.get(a);\n\n      if (e && (e.result.push(c), 5 <= e.result.length)) {\n        var g;\n        c = ba(g = e.result).call(g, !0);\n        e.isPrevNormal && !c && this.emit(\"exception\", wk[a], a, b);\n        !e.isPrevNormal && c && this.emit(\"exception\", wk[a] + 2E3, a + \"_RECOVER\", b);\n        e.isPrevNormal = c;\n        e.result = [];\n      }\n    }\n\n    checkAudioOutputLevel(a) {\n      return !(0 < a.receiveBitrate && 0 === a.receiveLevel);\n    }\n\n    checkAudioInputLevel(a) {\n      return 0 !== a.sendVolumeLevel;\n    }\n\n    checkFramerateInput(a, b) {\n      let c = null;\n      b._encoderConfig && b._encoderConfig.frameRate && (c = Qb(b._encoderConfig.frameRate));\n      a = a.captureFrameRate;\n      return !c || !a || !(10 < c && 5 > a || 10 > c && 5 <= c && 1 >= a);\n    }\n\n    checkFramerateSent(a) {\n      return !(a.captureFrameRate && a.sendFrameRate && 5 < a.captureFrameRate && 1 >= a.sendFrameRate);\n    }\n\n    checkSendVideoBitrate(a) {\n      return 0 !== a.sendBitrate;\n    }\n\n    checkSendAudioBitrate(a) {\n      return 0 !== a.sendBitrate;\n    }\n\n    checkVideoDecode(a) {\n      return 0 === a.receiveBitrate || 0 !== a.decodeFrameRate;\n    }\n\n  }\n\n  let wk = {\n    FRAMERATE_INPUT_TOO_LOW: 1001,\n    FRAMERATE_SENT_TOO_LOW: 1002,\n    SEND_VIDEO_BITRATE_TOO_LOW: 1003,\n    RECV_VIDEO_DECODE_FAILED: 1005,\n    AUDIO_INPUT_LEVEL_TOO_LOW: 2001,\n    AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002,\n    SEND_AUDIO_BITRATE_TOO_LOW: 2003\n  };\n\n  class kd {\n    constructor(a) {\n      this.localConnectionsMap = new aa();\n      this.remoteConnectionsMap = new aa();\n      this.trafficStatsPeerList = [];\n\n      this.updateStats = () => {\n        var a, c;\n        q(a = this.remoteConnectionsMap).call(a, a => {\n          var b;\n          let c = a.audioStats;\n          var e = a.videoStats,\n              k = a.pcStats;\n          let t = vb({}, Qf),\n              l = vb({}, Rf),\n              m = vb({}, fk),\n              n = a.connection.pc.getStats(),\n              q = n.audioRecv[0],\n              z = n.videoRecv[0];\n          k = k ? k.videoRecv[0] : void 0;\n          let u = !0 === a.connection.pc._statsFilter.videoIsReady,\n              v = this.trafficStats && R(b = this.trafficStats.peer_delay).call(b, b => b.peer_uid === a.connection.getUserId());\n          q && (\"opus\" !== q.codec && \"aac\" !== q.codec || (t.codecType = q.codec), q.outputLevel ? t.receiveLevel = Math.round(32767 * q.outputLevel) : a.connection.user.audioTrack && (t.receiveLevel = Math.round(32767 * a.connection.user.audioTrack.getVolumeLevel())), t.receiveBytes = q.bytes, t.receivePackets = q.packets, t.receivePacketsLost = q.packetsLost, t.packetLossRate = t.receivePacketsLost / (t.receivePackets + t.receivePacketsLost), t.receiveBitrate = c ? 8 * Math.max(0, t.receiveBytes - c.receiveBytes) : 0, t.totalDuration = c ? c.totalDuration + 1 : 1, t.totalFreezeTime = c ? c.totalFreezeTime : 0, t.freezeRate = t.totalFreezeTime / t.totalDuration, t.receiveDelay = q.jitterBufferMs, b = a.connection.user.audioTrack, 10 < t.totalDuration && kd.isRemoteAudioFreeze(b) && (t.totalFreezeTime += 1));\n          z && (\"H264\" !== z.codec && \"VP8\" !== z.codec && \"VP9\" !== z.codec && \"AV1X\" !== z.codec || (l.codecType = z.codec), l.receiveBytes = z.bytes, l.receiveBitrate = e ? 8 * Math.max(0, l.receiveBytes - e.receiveBytes) : 0, l.decodeFrameRate = z.decodeFrameRate, l.renderFrameRate = z.decodeFrameRate, z.outputFrame && (l.renderFrameRate = z.outputFrame.frameRate), z.receivedFrame ? (l.receiveFrameRate = z.receivedFrame.frameRate, l.receiveResolutionHeight = z.receivedFrame.height, l.receiveResolutionWidth = z.receivedFrame.width) : a.connection.user.videoTrack && (l.receiveResolutionHeight = a.connection.user.videoTrack._videoHeight || 0, l.receiveResolutionWidth = a.connection.user.videoTrack._videoWidth || 0), void 0 !== z.framesRateFirefox && (l.receiveFrameRate = Math.round(z.framesRateFirefox)), l.receivePackets = z.packets, l.receivePacketsLost = z.packetsLost, l.packetLossRate = l.receivePacketsLost / (l.receivePackets + l.receivePacketsLost), l.totalDuration = e ? e.totalDuration + 1 : 1, l.totalFreezeTime = e ? e.totalFreezeTime : 0, l.receiveDelay = z.jitterBufferMs || 0, e = a.connection.user.videoTrack, a.connection.subscribeOptions.video && u && kd.isRemoteVideoFreeze(e, z, k) && (l.totalFreezeTime += 1), l.freezeRate = l.totalFreezeTime / l.totalDuration);\n          v && (t.end2EndDelay = v.B_ad, l.end2EndDelay = v.B_vd, t.transportDelay = v.B_ed, l.transportDelay = v.B_ed, m.uplinkNetworkQuality = v.B_punq ? v.B_punq : 0, m.downlinkNetworkQuality = v.B_pdnq ? v.B_punq : 0);\n          a.audioStats = t;\n          a.videoStats = l;\n          a.pcStats = n;\n          a.networkStats = m;\n          a.connection.user.audioTrack && this.exceptionMonitor.setRemoteAudioStats(a.connection.user.audioTrack, t);\n          a.connection.user.videoTrack && this.exceptionMonitor.setRemoteVideoStats(a.connection.user.videoTrack, l);\n        });\n        q(c = this.localConnectionsMap).call(c, a => {\n          let b = a.audioStats,\n              c = a.videoStats,\n              e = vb({}, ke),\n              k = vb({}, le);\n          var t = a.connection.pc.getStats();\n          let l = t.audioSend[0];\n          t = t.videoSend[0];\n          let m = a.connection.getUserId();\n          l && (\"opus\" !== l.codec && \"aac\" !== l.codec || (e.codecType = l.codec), l.inputLevel ? e.sendVolumeLevel = Math.round(32767 * l.inputLevel) : a.connection.audioTrack && (e.sendVolumeLevel = Math.round(32767 * a.connection.audioTrack.getVolumeLevel())), e.sendBytes = l.bytes, e.sendPackets = l.packets, e.sendPacketsLost = l.packetsLost, e.sendBitrate = b ? 8 * Math.max(0, e.sendBytes - b.sendBytes) : 0);\n          t && (\"H264\" !== t.codec && \"VP8\" !== t.codec && \"VP9\" !== t.codec && \"AV1X\" !== t.codec || (k.codecType = t.codec), k.sendBytes = t.bytes, k.sendBitrate = c ? 8 * Math.max(0, k.sendBytes - c.sendBytes) : 0, t.inputFrame ? (k.captureFrameRate = t.inputFrame.frameRate, k.captureResolutionHeight = t.inputFrame.height, k.captureResolutionWidth = t.inputFrame.width) : a.connection.videoTrack && (k.captureResolutionWidth = a.connection.videoTrack._videoWidth || 0, k.captureResolutionHeight = a.connection.videoTrack._videoHeight || 0), t.sentFrame ? (k.sendFrameRate = t.sentFrame.frameRate, k.sendResolutionHeight = t.sentFrame.height, k.sendResolutionWidth = t.sentFrame.width) : a.connection.videoTrack && (k.sendResolutionWidth = a.connection.videoTrack._videoWidth || 0, k.sendResolutionHeight = a.connection.videoTrack._videoHeight || 0), t.avgEncodeMs && (k.encodeDelay = t.avgEncodeMs), a.connection.videoTrack && a.connection.videoTrack._encoderConfig && a.connection.videoTrack._encoderConfig.bitrateMax && (k.targetSendBitrate = 1E3 * a.connection.videoTrack._encoderConfig.bitrateMax), k.sendPackets = t.packets, k.sendPacketsLost = t.packetsLost, k.totalDuration = c ? c.totalDuration + 1 : 1, k.totalFreezeTime = c ? c.totalFreezeTime : 0, this.isLocalVideoFreeze(t) && (k.totalFreezeTime += 1));\n          a.audioStats = e;\n          a.videoStats = k;\n          a.audioStats && a.connection.audioTrack && this.exceptionMonitor.setLocalAudioStats(m, a.connection.audioTrack, a.audioStats);\n          a.videoStats && a.connection.videoTrack && this.exceptionMonitor.setLocalVideoStats(m, a.connection.videoTrack, a.videoStats);\n        });\n      };\n\n      this.clientId = a;\n      this.updateStatsInterval = window.setInterval(this.updateStats, 1E3);\n      this.exceptionMonitor = new ho();\n      this.exceptionMonitor.on(\"exception\", (a, c, e) => {\n        this.onStatsException && this.onStatsException(a, c, e);\n      });\n    }\n\n    reset() {\n      this.localConnectionsMap = new aa();\n      this.remoteConnectionsMap = new aa();\n      this.trafficStats = void 0;\n      this.trafficStatsPeerList = [];\n      this.uplinkStats = void 0;\n    }\n\n    getLocalAudioTrackStats(a) {\n      return (a = this.localConnectionsMap.get(a)) && a.audioStats ? a.audioStats : vb({}, ke);\n    }\n\n    getLocalVideoTrackStats(a) {\n      return (a = this.localConnectionsMap.get(a)) && a.videoStats ? a.videoStats : vb({}, le);\n    }\n\n    getRemoteAudioTrackStats(a) {\n      var b;\n      let c = this.remoteConnectionsMap.get(a);\n      if (!c || !c.audioStats) return vb({}, Qf);\n      if (!this.trafficStats) return c.audioStats;\n      a = R(b = this.trafficStats.peer_delay).call(b, a => a.peer_uid === c.connection.user.uid);\n      return a && (c.audioStats.publishDuration = a.B_ppad + (x() - this.trafficStats.timestamp)), c.audioStats;\n    }\n\n    getRemoteNetworkQualityStats(a) {\n      return (a = this.remoteConnectionsMap.get(a)) && a.networkStats ? a.networkStats : vb({}, fk);\n    }\n\n    getRemoteVideoTrackStats(a) {\n      var b;\n      let c = this.remoteConnectionsMap.get(a);\n      if (!c || !c.videoStats) return vb({}, Rf);\n      if (!this.trafficStats) return c.videoStats;\n      a = R(b = this.trafficStats.peer_delay).call(b, a => a.peer_uid === c.connection.user.uid);\n      return a && (c.videoStats.publishDuration = a.B_ppvd + (x() - this.trafficStats.timestamp)), c.videoStats;\n    }\n\n    getRTCStats() {\n      var a, b;\n      let c = 0,\n          e = 0,\n          g = 0,\n          h = 0;\n      q(a = this.localConnectionsMap).call(a, a => {\n        a.audioStats && (c += a.audioStats.sendBytes, e += a.audioStats.sendBitrate);\n        a.videoStats && (c += a.videoStats.sendBytes, e += a.videoStats.sendBitrate);\n      });\n      q(b = this.remoteConnectionsMap).call(b, a => {\n        a.audioStats && (g += a.audioStats.receiveBytes, h += a.audioStats.receiveBitrate);\n        a.videoStats && (g += a.videoStats.receiveBytes, h += a.videoStats.receiveBitrate);\n      });\n      a = 1;\n      return this.trafficStats && (a += this.trafficStats.peer_delay.length), {\n        Duration: 0,\n        UserCount: a,\n        SendBitrate: e,\n        SendBytes: c,\n        RecvBytes: g,\n        RecvBitrate: h,\n        OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1E3 : 0,\n        RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0\n      };\n    }\n\n    removeConnection(a) {\n      this.localConnectionsMap.delete(a);\n      this.remoteConnectionsMap.delete(a);\n    }\n\n    addLocalConnection(a) {\n      let b = a.connectionId;\n      this.localConnectionsMap.has(b) || this.localConnectionsMap.set(b, {\n        connection: a\n      });\n    }\n\n    addRemoteConnection(a) {\n      let b = a.connectionId;\n      this.remoteConnectionsMap.has(b) || this.remoteConnectionsMap.set(b, {\n        connection: a\n      });\n    }\n\n    updateTrafficStats(a) {\n      var b;\n      let c = I(b = a.peer_delay).call(b, a => {\n        var b;\n        return -1 === J(b = this.trafficStatsPeerList).call(b, a.peer_uid);\n      });\n      q(c).call(c, a => {\n        var b, c;\n        let e = R(b = Gb(ic(c = this.remoteConnectionsMap).call(c))).call(b, b => b.connection._userId === a.peer_uid);\n        void 0 !== a.B_ppad && void 0 !== a.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(a.peer_uid, a.B_ppad, a.B_ppvd, e ? x() - e.connection.startTime : 0), this.trafficStatsPeerList.push(a.peer_uid));\n      });\n      this.trafficStats = a;\n    }\n\n    updateUplinkStats(a) {\n      var b;\n      this.uplinkStats && this.uplinkStats.B_fir !== a.B_fir && k.debug(m(b = \"[\".concat(this.clientId, \"]: Period fir changes to \")).call(b, a.B_fir));\n      this.uplinkStats = a;\n    }\n\n    static isRemoteVideoFreeze(a, b, c) {\n      if (!a) return !1;\n      a = !c || b.framesDecodeCount > c.framesDecodeCount;\n      return !!c && b.framesDecodeFreezeTime > c.framesDecodeFreezeTime || !a;\n    }\n\n    static isRemoteAudioFreeze(a) {\n      return !!a && a._isFreeze();\n    }\n\n    isLocalVideoFreeze(a) {\n      return !(!a.inputFrame || !a.sentFrame) && 5 < a.inputFrame.frameRate && 3 > a.sentFrame.frameRate;\n    }\n\n  }\n\n  var xk;\n\n  let bg = () => {},\n      rh = {},\n      yk = new class {\n    constructor() {\n      this.fnMap = new aa();\n    }\n\n    throttleByKey(a, b, c, e, ...g) {\n      if (this.fnMap.has(b)) {\n        var h = this.fnMap.get(b);\n        h.threshold !== c ? (h.fn(...h.args), clearTimeout(h.timer), h = window.setTimeout(() => {\n          const a = this.fnMap.get(b);\n          a && a.fn(...a.args);\n          this.fnMap.delete(b);\n        }, c), this.fnMap.set(b, {\n          fn: a,\n          threshold: c,\n          timer: h,\n          args: g,\n          skipFn: e\n        })) : (h.skipFn && h.skipFn(...h.args), this.fnMap.set(b, Fe({}, h, {\n          fn: a,\n          args: g,\n          skipFn: e\n        })));\n      } else h = window.setTimeout(() => {\n        const a = this.fnMap.get(b);\n        a && a.fn(...a.args);\n        this.fnMap.delete(b);\n      }, c), this.fnMap.set(b, {\n        fn: a,\n        threshold: c,\n        timer: h,\n        args: g,\n        skipFn: e\n      });\n    }\n\n  }(),\n      zk = ra(xk = yk.throttleByKey).call(xk, yk),\n      Hd = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator(function* ({\n      fragementLength: a,\n      referenceList: b,\n      asyncMapHandler: c,\n      allFailedhandler: e\n    }) {\n      let g = 0,\n          h,\n          p = 0;\n\n      const k = /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* () {\n          const r = (() => {\n            var e = g * a;\n            const h = e + a;\n            e = Ha(b).call(b, e, h);\n            return E(e).call(e, c);\n          })();\n\n          try {\n            h = yield Lc(r);\n          } catch (y) {\n            if (p += a, g++, !(p >= b.length)) return void (yield k());\n            e(y);\n          }\n\n          q(r).call(r, a => a.cancel());\n        });\n\n        return function k() {\n          return _ref6.apply(this, arguments);\n        };\n      }();\n\n      return yield k(), h;\n    });\n\n    return function Hd(_x36) {\n      return _ref5.apply(this, arguments);\n    };\n  }(),\n      Ed = null,\n      io = 1;\n\n  class Mb {\n    constructor(a) {\n      var b;\n      this.lockingPromise = A.resolve();\n      this.locks = 0;\n      this.name = \"\";\n      this.lockId = io++;\n      a && (this.name = a);\n      k.debug(m(b = \"[lock-\".concat(this.name, \"-\")).call(b, this.lockId, \"] is created.\"));\n    }\n\n    get isLocked() {\n      return 0 < this.locks;\n    }\n\n    lock() {\n      var a, b;\n      let c;\n      this.locks += 1;\n      k.debug(m(a = m(b = \"[lock-\".concat(this.name, \"-\")).call(b, this.lockId, \"] is locked, current queue \")).call(a, this.locks, \".\"));\n      let e = new A(a => {\n        c = () => {\n          var b, c;\n          --this.locks;\n          k.debug(m(b = m(c = \"[lock-\".concat(this.name, \"-\")).call(c, this.lockId, \"] is not locked, current queue \")).call(b, this.locks, \".\"));\n          a();\n        };\n      });\n      a = this.lockingPromise.then(() => c);\n      return this.lockingPromise = this.lockingPromise.then(() => e), a;\n    }\n\n  }\n\n  let He = new Mb(\"safari\"),\n      vh = !1,\n      wh = !1,\n      cb = new class extends Sa {\n    constructor() {\n      super();\n      this._state = hc.IDLE;\n      this.lastAccessCameraPermission = this.lastAccessMicrophonePermission = this.isAccessCameraPermission = this.isAccessMicrophonePermission = !1;\n      this.deviceInfoMap = new aa();\n      this.init().then(() => {\n        var a, b;\n        navigator.mediaDevices && navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener(\"devicechange\", ra(b = this.updateDevicesInfo).call(b, this));\n        window.setInterval(ra(a = this.updateDevicesInfo).call(a, this), 2500);\n      }).catch(a => k.error(a.toString()));\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    set state(a) {\n      a !== this._state && (this.emit(Kb.STATE_CHANGE, a), this._state = a);\n    }\n\n    enumerateDevices(a, b, c = !1) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return new n(l.NOT_SUPPORTED, \"enumerateDevices() not supported.\").throw();\n        var e = yield navigator.mediaDevices.enumerateDevices();\n        e = _this2.checkMediaDeviceInfoIsOk(e);\n        let g = !_this2.isAccessMicrophonePermission && a,\n            h = !_this2.isAccessCameraPermission && b;\n        e.audio && (g = !1);\n        e.video && (h = !1);\n        let p = e = null,\n            r = null;\n\n        if (!c && (g || h)) {\n          He.isLocked && (k.debug(\"[device manager] wait GUM lock\"), (yield He.lock())(), k.debug(\"[device manager] GUM unlock\"));\n\n          if (vh && (g = !1, _this2.isAccessMicrophonePermission = !0), wh && (h = !1, _this2.isAccessCameraPermission = !0), k.debug(\"[device manager] check media device permissions\", a, b, g, h), g && h) {\n            try {\n              r = yield navigator.mediaDevices.getUserMedia({\n                audio: !0,\n                video: !0\n              });\n            } catch (ka) {\n              c = Fd(ka.name || ka.code || ka, ka.message);\n              if (c.code === l.PERMISSION_DENIED) throw c;\n              k.warning(\"getUserMedia failed in getDevices\", c);\n            }\n\n            _this2.isAccessMicrophonePermission = _this2.isAccessCameraPermission = !0;\n          } else if (g) {\n            try {\n              e = yield navigator.mediaDevices.getUserMedia({\n                audio: a\n              });\n            } catch (ka) {\n              c = Fd(ka.name || ka.code || ka, ka.message);\n              if (c.code === l.PERMISSION_DENIED) throw c;\n              k.warning(\"getUserMedia failed in getDevices\", c);\n            }\n\n            _this2.isAccessMicrophonePermission = !0;\n          } else if (h) {\n            try {\n              p = yield navigator.mediaDevices.getUserMedia({\n                video: b\n              });\n            } catch (ka) {\n              c = Fd(ka.name || ka.code || ka, ka.message);\n              if (c.code === l.PERMISSION_DENIED) throw c;\n              k.warning(\"getUserMedia failed in getDevices\", c);\n            }\n\n            _this2.isAccessCameraPermission = !0;\n          }\n\n          k.debug(\"[device manager] mic permission\", a, \"cam permission\", b);\n        }\n\n        try {\n          var t, m, ua;\n          const a = yield navigator.mediaDevices.enumerateDevices();\n          return e && q(t = e.getTracks()).call(t, a => a.stop()), p && q(m = p.getTracks()).call(m, a => a.stop()), r && q(ua = r.getTracks()).call(ua, a => a.stop()), e = null, p = null, r = null, a;\n        } catch (ka) {\n          var D, u, z;\n          e && q(D = e.getTracks()).call(D, a => a.stop());\n          p && q(u = p.getTracks()).call(u, a => a.stop());\n          r && q(z = r.getTracks()).call(z, a => a.stop());\n          r = p = e = null;\n          return new n(l.ENUMERATE_DEVICES_FAILED, ka.toString()).throw();\n        }\n      })();\n    }\n\n    getRecordingDevices(a = !1) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        a = yield _this3.enumerateDevices(!0, !1, a);\n        return I(a).call(a, a => \"audioinput\" === a.kind);\n      })();\n    }\n\n    getCamerasDevices(a = !1) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        a = yield _this4.enumerateDevices(!1, !0, a);\n        return I(a).call(a, a => \"videoinput\" === a.kind);\n      })();\n    }\n\n    getSpeakers(a = !1) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        a = yield _this5.enumerateDevices(!0, !1, a);\n        return I(a).call(a, a => \"audiooutput\" === a.kind);\n      })();\n    }\n\n    searchDeviceNameById(a) {\n      return (a = this.deviceInfoMap.get(a)) ? a.device.label || a.device.deviceId : null;\n    }\n\n    searchDeviceIdByName(a) {\n      var b;\n      let c = null;\n      return q(b = this.deviceInfoMap).call(b, b => {\n        b.device.label === a && (c = b.device.deviceId);\n      }), c;\n    }\n\n    getDeviceById(a) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        var b = yield _this6.enumerateDevices(!0, !0, !0);\n        b = R(b).call(b, b => b.deviceId === a);\n        if (!b) throw new n(l.DEVICE_NOT_FOUND, \"deviceId: \".concat(a));\n        return b;\n      })();\n    }\n\n    init() {\n      var _this7 = this;\n\n      return _asyncToGenerator(function* () {\n        _this7.state = hc.INITING;\n\n        try {\n          yield _this7.updateDevicesInfo(), _this7.state = hc.INITEND;\n        } catch (a) {\n          throw (k.warning(\"Device Detection functionality cannot start properly.\", a.toString()), _this7.state = hc.IDLE, \"boolean\" == typeof isSecureContext ? isSecureContext : \"https:\" === location.protocol || \"file:\" === location.protocol || \"localhost\" === location.hostname || \"127.0.0.1\" === location.hostname || \"::1\" === location.hostname) || new n(l.WEB_SECURITY_RESTRICT, \"Your context is limited by web security, please try using https protocol or localhost.\").throw(), a;\n        }\n      })();\n    }\n\n    updateDevicesInfo() {\n      var _this8 = this;\n\n      return _asyncToGenerator(function* () {\n        var a;\n\n        const b = yield _this8.enumerateDevices(!0, !0, !0),\n              c = x(),\n              e = [],\n              g = _this8.checkMediaDeviceInfoIsOk(b);\n\n        if (q(b).call(b, a => {\n          if (a.deviceId) {\n            var b = _this8.deviceInfoMap.get(a.deviceId);\n\n            if (\"ACTIVE\" !== (b ? b.state : \"INACTIVE\")) {\n              const b = {\n                initAt: c,\n                updateAt: c,\n                device: a,\n                state: \"ACTIVE\"\n              };\n\n              _this8.deviceInfoMap.set(a.deviceId, b);\n\n              e.push(b);\n            }\n\n            b && (b.updateAt = c);\n          }\n        }), q(a = _this8.deviceInfoMap).call(a, (a, b) => {\n          \"ACTIVE\" === a.state && a.updateAt !== c && (a.state = \"INACTIVE\", e.push(a));\n        }), _this8.state !== hc.INITEND) return g.audio && (_this8.lastAccessMicrophonePermission = !0, _this8.isAccessMicrophonePermission = !0), void (g.video && (_this8.lastAccessCameraPermission = !0, _this8.isAccessCameraPermission = !0));\n        q(e).call(e, a => {\n          switch (a.device.kind) {\n            case \"audioinput\":\n              _this8.lastAccessMicrophonePermission && _this8.isAccessMicrophonePermission && _this8.emit(Kb.RECORDING_DEVICE_CHANGED, a);\n              break;\n\n            case \"videoinput\":\n              _this8.lastAccessCameraPermission && _this8.isAccessCameraPermission && _this8.emit(Kb.CAMERA_DEVICE_CHANGED, a);\n              break;\n\n            case \"audiooutput\":\n              _this8.lastAccessMicrophonePermission && _this8.isAccessMicrophonePermission && _this8.emit(Kb.PLAYOUT_DEVICE_CHANGED, a);\n          }\n        });\n        g.audio && (_this8.lastAccessMicrophonePermission = !0, _this8.isAccessMicrophonePermission = !0);\n        g.video && (_this8.lastAccessCameraPermission = !0, _this8.isAccessCameraPermission = !0);\n      })();\n    }\n\n    checkMediaDeviceInfoIsOk(a) {\n      const b = I(a).call(a, a => \"audioinput\" === a.kind);\n      a = I(a).call(a, a => \"videoinput\" === a.kind);\n      const c = {\n        audio: !1,\n        video: !1\n      };\n\n      for (const a of b) if (a.label && a.deviceId) {\n        c.audio = !0;\n        break;\n      }\n\n      for (const b of a) if (b.label && b.deviceId) {\n        c.video = !0;\n        break;\n      }\n\n      return c;\n    }\n\n  }();\n\n  var jo = [].slice,\n      ko = /MSIE .\\./.test(Yc),\n      Ak = function (a) {\n    return function (b, c) {\n      var e = 2 < arguments.length,\n          g = e ? jo.call(arguments, 2) : void 0;\n      return a(e ? function () {\n        (\"function\" == typeof b ? b : Function(b)).apply(this, g);\n      } : b, c);\n    };\n  };\n\n  O({\n    global: !0,\n    bind: !0,\n    forced: ko\n  }, {\n    setTimeout: Ak(N.setTimeout),\n    setInterval: Ak(N.setInterval)\n  });\n  var Ub = ia.setTimeout;\n  let yh = 0,\n      Ie = 0,\n      u = new class {\n    constructor() {\n      var a, b;\n      this.baseInfoMap = new aa();\n      this.clientList = Wj;\n      this.keyEventUploadPendingItems = [];\n      this.normalEventUploadPendingItems = [];\n      this.apiInvokeUploadPendingItems = [];\n      this.apiInvokeCount = 0;\n      this.ltsList = [];\n      this.lastSendNormalEventTime = x();\n      this.customReportCount = 0;\n      this.eventUploadTimer = window.setInterval(ra(a = this.doSend).call(a, this), v.EVENT_REPORT_SEND_INTERVAL);\n      this.setSessionIdTimer = window.setInterval(ra(b = this.appendSessionId).call(b, this), v.EVENT_REPORT_SEND_INTERVAL);\n    }\n\n    reportApiInvoke(a, b, c) {\n      b.timeout = b.timeout || 6E4;\n      b.reportResult = void 0 === b.reportResult || b.reportResult;\n\n      const e = x(),\n            g = this.apiInvokeCount += 1,\n            h = () => ({\n        tag: b.tag,\n        invokeId: g,\n        sid: a,\n        name: b.name,\n        apiInvokeTime: e,\n        options: b.options\n      }),\n            p = !!v.SHOW_REPORT_INVOKER_LOG;\n\n      p && k.info(\"\".concat(b.name, \" start\"), b.options);\n      let r = !1;\n      wb(b.timeout).then(() => {\n        r || (this.sendApiInvoke(va({}, h(), {\n          error: l.API_INVOKE_TIMEOUT,\n          success: !1\n        })), k.debug(\"\".concat(b.name, \" timeout\")));\n      });\n      const t = new n(l.UNEXPECTED_ERROR, \"\".concat(b.name, \": this api invoke is end\"));\n      return {\n        onSuccess: a => {\n          const e = () => {\n            if (r) throw t;\n            return r = !0, this.sendApiInvoke(va({}, h(), {\n              success: !0\n            }, b.reportResult && {\n              result: a\n            })), p && k.info(\"\".concat(b.name, \" onSuccess\")), a;\n          };\n\n          return c ? zk(e, b.name + \"Success\", c, () => r = !0) : e();\n        },\n        onError: a => {\n          const e = () => {\n            if (r) throw a;\n            r = !0;\n            this.sendApiInvoke(va({}, h(), {\n              success: !1,\n              error: a.toString()\n            }));\n            p && k.info(\"\".concat(b.name, \" onFailure\"), a.toString());\n          };\n\n          return c ? zk(e, b.name + \"Error\", c, () => r = !0) : e();\n        }\n      };\n    }\n\n    sessionInit(a, b) {\n      if (!this.baseInfoMap.has(a)) {\n        var c = x();\n        a = this.createBaseInfo(a, c);\n        a.cname = b.cname;\n        var e = Ga({}, {\n          willUploadConsoleLog: v.UPLOAD_LOG,\n          maxTouchPoints: navigator.maxTouchPoints,\n          areaVersion: Mf ? \"global\" : \"oversea\",\n          areas: v.AREAS && v.AREAS.join(\",\")\n        }, b.extend),\n            g = x();\n        b = va({}, a, {\n          eventType: Ca.SESSION_INIT,\n          appid: b.appid,\n          browser: navigator.userAgent,\n          build: \"v4.5.0-0-g87245ad6(5/25/2021, 3:25:26 PM)\",\n          lts: g,\n          elapse: g - c,\n          extend: w(e),\n          mode: b.mode,\n          process: v.PROCESS_ID,\n          success: !0,\n          version: Ta\n        });\n        this.send({\n          type: ma.SESSION,\n          data: b\n        }, !0);\n      }\n    }\n\n    joinChooseServer(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {\n          eventType: Ca.JOIN_CHOOSE_SERVER,\n          lts: e,\n          eventElapse: e - b.lts,\n          chooseServerAddr: b.csAddr,\n          errorCode: b.ec,\n          elapse: e - a.startTime,\n          success: b.succ,\n          chooseServerAddrList: w(b.serverList),\n          uid: b.uid ? pa(b.uid) : null,\n          cid: b.cid ? pa(b.cid) : null,\n          chooseServerIp: b.csIp || \"\"\n        });\n        this.send({\n          type: ma.JOIN_CHOOSE_SERVER,\n          data: b\n        }, !0);\n      }\n    }\n\n    reqUserAccount(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {\n          eventType: Ca.REQ_USER_ACCOUNT,\n          lts: e,\n          success: b.success,\n          serverAddress: b.serverAddr,\n          stringUid: b.stringUid,\n          uid: b.uid,\n          errorCode: b.errorCode,\n          elapse: e - a.startTime,\n          eventElapse: e - b.lts,\n          extend: w(b.extend)\n        });\n        this.send({\n          type: ma.REQ_USER_ACCOUNT,\n          data: b\n        }, !0);\n      }\n    }\n\n    joinGateway(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info;\n        b.vid && (c.vid = b.vid);\n        c.uid = b.uid;\n        c.cid = b.cid;\n        var e = x();\n        c = va({}, c, {\n          eventType: Ca.JOIN_GATEWAY,\n          lts: e,\n          gatewayAddr: b.addr,\n          success: b.succ,\n          errorCode: b.ec,\n          elapse: e - a.startTime,\n          eventElapse: e - b.lts\n        });\n        b.succ && (a.lastJoinSuccessTime = e);\n        this.send({\n          type: ma.JOIN_GATEWAT,\n          data: c\n        }, !0);\n      }\n    }\n\n    joinChannelTimeout(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = x();\n        b = va({}, a.info, {\n          lts: c,\n          timeout: b,\n          elapse: c - a.startTime\n        });\n        this.send({\n          type: ma.JOIN_CHANNEL_TIMEOUT,\n          data: b\n        }, !0);\n      }\n    }\n\n    publish(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {\n          eventType: Ca.PUBLISH,\n          lts: e,\n          eventElapse: e - b.lts,\n          elapse: e - a.startTime,\n          success: b.succ,\n          errorCode: b.ec,\n          videoName: b.videoName,\n          audioName: b.audioName,\n          screenName: b.screenName,\n          screenshare: b.screenshare,\n          audio: b.audio,\n          video: b.video,\n          p2pid: b.p2pid,\n          publishRequestid: b.publishRequestid\n        });\n        this.send({\n          type: ma.PUBLISH,\n          data: b\n        }, !0);\n      }\n    }\n\n    subscribe(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        a = va({}, c, {\n          eventType: Ca.SUBSCRIBE,\n          lts: e,\n          eventElapse: e - b.lts,\n          elapse: e - a.startTime,\n          success: b.succ,\n          errorCode: b.ec,\n          video: b.video,\n          audio: b.audio,\n          subscribeRequestid: b.subscribeRequestid,\n          p2pid: b.p2pid\n        });\n        \"string\" == typeof b.peerid ? a.peerSuid = b.peerid : a.peer = b.peerid;\n        this.send({\n          type: ma.SUBSCRIBE,\n          data: a\n        }, !0);\n      }\n    }\n\n    firstRemoteFrame(a, b, c, e) {\n      if (a = this.baseInfoMap.get(a)) {\n        var g = a.info,\n            h = x();\n        b = va({}, g, {}, e, {\n          elapse: h - a.startTime,\n          eventType: b,\n          lts: h\n        });\n        this.send({\n          type: c,\n          data: b\n        }, !0);\n      }\n    }\n\n    onGatewayStream(a, b, c, e) {\n      if (a = this.baseInfoMap.get(a)) b = va({}, a.info, {}, e, {\n        eventType: b,\n        lts: x()\n      }), this.send({\n        type: c,\n        data: b\n      }, !0);\n    }\n\n    streamSwitch(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {\n          eventType: Ca.STREAM_SWITCH,\n          lts: e,\n          isDual: b.isdual,\n          elapse: e - a.startTime,\n          success: b.succ\n        });\n        this.send({\n          type: ma.STREAM_SWITCH,\n          data: b\n        }, !0);\n      }\n    }\n\n    requestProxyAppCenter(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {\n          eventType: Ca.REQUEST_PROXY_APPCENTER,\n          lts: e,\n          eventElapse: e - b.lts,\n          elapse: e - a.startTime,\n          APAddr: b.APAddr,\n          workerManagerList: b.workerManagerList,\n          response: b.response,\n          errorCode: b.ec,\n          success: b.succ\n        });\n        this.send({\n          type: ma.REQUEST_PROXY_APPCENTER,\n          data: b\n        }, !0);\n      }\n    }\n\n    requestProxyWorkerManager(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {\n          eventType: Ca.REQUEST_PROXY_WORKER_MANAGER,\n          lts: e,\n          eventElapse: e - b.lts,\n          elapse: e - a.startTime,\n          workerManagerAddr: b.workerManagerAddr,\n          response: b.response,\n          errorCode: b.ec,\n          success: b.succ\n        });\n        this.send({\n          type: ma.REQUEST_PROXY_WORKER_MANAGER,\n          data: b\n        }, !0);\n      }\n    }\n\n    setProxyServer(a) {\n      (this.proxyServer = a) ? k.debug(\"reportProxyServerurl: \".concat(a)) : k.debug(\"disable reportProxyServerurl: \".concat(a));\n    }\n\n    peerPublishStatus(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {\n          subscribeElapse: b.subscribeElapse,\n          peer: b.peer,\n          peerPublishDuration: Math.max(b.audioPublishDuration, b.videoPublishDuration),\n          audiotag: 0 < b.audioPublishDuration ? 1 : -1,\n          videotag: 0 < b.videoPublishDuration ? 1 : -1,\n          lts: e,\n          elapse: e - a.startTime,\n          joinChannelSuccessElapse: e - (a.lastJoinSuccessTime || e)\n        });\n        this.send({\n          type: ma.PEER_PUBLISH_STATUS,\n          data: b\n        }, !0);\n      }\n    }\n\n    workerEvent(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n\n        b = function (a, b, c) {\n          const e = a[b];\n          if (!e || \"string\" != typeof e) return [a];\n          a[b] = \"\";\n          const g = Cd(w(a));\n          let h = 0;\n          const p = [];\n          let k = 0;\n\n          for (let r = 0; r < e.length; r++) k += 127 >= e.charCodeAt(r) ? 1 : 3, k <= c - g || (p[p.length] = Fe({}, a, {\n            [b]: e.substring(h, r)\n          }), h = r, k = 127 >= e.charCodeAt(r) ? 1 : 3);\n\n          return h !== e.length - 1 && (p[p.length] = Fe({}, a, {\n            [b]: e.substring(h)\n          })), p;\n        }(va({}, c, {}, b, {\n          elapse: e - a.startTime,\n          lts: e,\n          productType: \"WebRTC\"\n        }), \"payload\", 1300);\n\n        q(b).call(b, a => this.send({\n          type: ma.WORKER_EVENT,\n          data: a\n        }, !0));\n      }\n    }\n\n    apworkerEvent(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {}, b, {\n          elapse: e - a.startTime,\n          lts: e\n        });\n        this.send({\n          type: ma.AP_WORKER_EVENT,\n          data: b\n        }, !0);\n      }\n    }\n\n    joinWebProxyAP(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {}, b, {\n          elapse: e - a.startTime,\n          lts: e\n        });\n        this.send({\n          type: ma.JOIN_WEB_PROXY_AP,\n          data: b\n        }, !0);\n      }\n    }\n\n    WebSocketQuit(a, b) {\n      if (a = this.baseInfoMap.get(a)) {\n        var c = a.info,\n            e = x();\n        b = va({}, c, {}, b, {\n          elapse: e - a.startTime,\n          lts: e\n        });\n        this.send({\n          type: ma.WEBSOCKET_QUIT,\n          data: b\n        }, !0);\n      }\n    }\n\n    sendCustomReportMessage(a, b) {\n      var _this9 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this9.customReportCount += b.length, _this9.customReportCount > v.CUSTOM_REPORT_LIMIT) throw new n(l.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);\n        _this9.customReportCounterTimer || (_this9.customReportCounterTimer = window.setInterval(() => {\n          _this9.customReportCount = 0;\n        }, 5E3));\n        b = E(b).call(b, b => ({\n          type: ma.USER_ANALYTICS,\n          data: va({\n            sid: a\n          }, b)\n        }));\n        b = {\n          msgType: \"EventMessages\",\n          sentTs: Math.round(x() / 1E3),\n          payloads: E(b).call(b, a => w(a))\n        };\n\n        try {\n          yield _this9.postDataToStatsCollector(b);\n        } catch (c) {\n          throw k.error(\"send custom report message failed\", c.toString()), new n(l.CUSTOM_REPORT_SEND_FAILED, c.message);\n        }\n      })();\n    }\n\n    sendApiInvoke(a) {\n      var b = v.NOT_REPORT_EVENT;\n      if (a.tag && ba(b) && ba(b).call(b, a.tag)) return !1;\n      if (null === a.sid) return this.apiInvokeUploadPendingItems.push(a), !1;\n      b = this.baseInfoMap.get(a.sid);\n      if (!b) return this.apiInvokeUploadPendingItems.push(a), !1;\n      const {\n        cname: c,\n        uid: e,\n        cid: g\n      } = b.info;\n      a.lts = a.lts || x();\n      a = {\n        invokeId: a.invokeId,\n        sid: a.sid,\n        cname: c,\n        cid: g,\n        uid: e,\n        lts: a.lts,\n        success: a.success,\n        elapse: a.lts - b.startTime,\n        execElapse: a.lts - a.apiInvokeTime,\n        apiName: a.name,\n        options: a.options ? w(a.options) : void 0,\n        execStates: a.states ? w(a.states) : void 0,\n        execResult: a.result ? w(a.result) : void 0,\n        errorCode: a.error ? w(a.error) : void 0\n      };\n      return this.send({\n        type: ma.API_INVOKE,\n        data: a\n      }, !1), !0;\n    }\n\n    appendSessionId() {\n      var a;\n      q(a = this.clientList).call(a, a => {\n        if (a._sessionId) {\n          const b = this.apiInvokeUploadPendingItems.length;\n\n          for (let c = 0; c < b; c++) {\n            const b = this.apiInvokeUploadPendingItems.shift();\n            b && (b.sid = a._sessionId, this.sendApiInvoke(Ga({}, b)));\n          }\n        }\n      });\n    }\n\n    send(a, b) {\n      if (b) return this.keyEventUploadPendingItems.push(a), void this.sendItems(this.keyEventUploadPendingItems, !0);\n      var c;\n      (this.normalEventUploadPendingItems.push(a), this.normalEventUploadPendingItems.length > v.NORMAL_EVENT_QUEUE_CAPACITY) && Ia(c = this.normalEventUploadPendingItems).call(c, 0, 1);\n      10 <= this.normalEventUploadPendingItems.length && this.sendItems(this.normalEventUploadPendingItems, !1);\n    }\n\n    doSend() {\n      0 < this.keyEventUploadPendingItems.length && this.sendItems(this.keyEventUploadPendingItems, !0);\n      0 < this.normalEventUploadPendingItems.length && 5E3 <= x() - this.lastSendNormalEventTime && this.sendItems(this.normalEventUploadPendingItems, !1);\n    }\n\n    sendItems(a, b) {\n      const c = [];\n\n      for (var e = []; a.length;) {\n        const b = a.shift();\n        20 > c.length ? c.push(b) : e.push(b);\n      }\n\n      a.push(...e);\n\n      for (const a of [...c]) {\n        var g, h;\n        -1 !== J(g = this.ltsList).call(g, a.data.lts) ? (a.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(a.data.lts)) : (this.ltsList.push(a.data.lts), dd(h = this.ltsList).call(h, (a, b) => a - b));\n      }\n\n      b || (this.lastSendNormalEventTime = x());\n      e = {\n        msgType: \"EventMessages\",\n        sentTs: Math.round(x() / 1E3),\n        payloads: E(c).call(c, a => w(a)),\n        vid: (a => (a = a && a.data.sid && this.baseInfoMap.get(a.data.sid)) && a.info.vid && +a.info.vid || 0)(c[0])\n      };\n      return c.length && this.postDataToStatsCollector(e).catch((a => c => {\n        var e, g, h;\n        b ? this.keyEventUploadPendingItems = m(e = this.keyEventUploadPendingItems).call(e, a) : (this.normalEventUploadPendingItems = m(g = this.normalEventUploadPendingItems).call(g, a), this.normalEventUploadPendingItems.length > v.NORMAL_EVENT_QUEUE_CAPACITY && (Ia(h = this.normalEventUploadPendingItems).call(h, 0, this.normalEventUploadPendingItems.length - v.NORMAL_EVENT_QUEUE_CAPACITY), k.warning(\"report: drop normal events\")));\n      })(c)), a;\n    }\n\n    postDataToStatsCollector(a, b = !1) {\n      var _this10 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e, g;\n        const h = b ? \"/events/proto-raws\" : \"/events/messages\";\n        let p = _this10.url || (_this10.proxyServer ? m(c = m(e = \"https://\".concat(_this10.proxyServer, \"/rs/?h=\")).call(e, v.EVENT_REPORT_DOMAIN, \"&p=6443&d=\")).call(c, h) : m(g = \"https://\".concat(v.EVENT_REPORT_DOMAIN, \":6443\")).call(g, h));\n\n        for (c = 0; 2 > c; c += 1) {\n          var k, l, n;\n          1 === c && (p = _this10.backupUrl || (_this10.proxyServer ? m(k = m(l = \"https://\".concat(_this10.proxyServer, \"/rs/?h=\")).call(l, v.EVENT_REPORT_BACKUP_DOMAIN, \"&p=6443&d=\")).call(k, h) : m(n = \"https://\".concat(v.EVENT_REPORT_BACKUP_DOMAIN, \":6443\")).call(n, h)));\n\n          try {\n            b ? yield ql(p, {\n              timeout: 1E4,\n              data: a\n            }) : yield yb(p, {\n              timeout: 1E4,\n              data: a\n            });\n          } catch (ua) {\n            if (1 === c) throw ua;\n            continue;\n          }\n\n          break;\n        }\n      })();\n    }\n\n    createBaseInfo(a, b) {\n      const c = Ga({}, Sn);\n      return c.sid = a, this.baseInfoMap.set(a, {\n        info: c,\n        startTime: b\n      }), c;\n    }\n\n  }(),\n      rl = {\n    [oc.ACCESS_POINT]: {\n      [Da.NO_FLAG_SET]: {\n        desc: \"flag is zero\",\n        retry: !1\n      },\n      [Da.FLAG_SET_BUT_EMPTY]: {\n        desc: \"flag is empty\",\n        retry: !1\n      },\n      [Da.INVALID_FALG_SET]: {\n        desc: \"invalid flag\",\n        retry: !1\n      },\n      [Da.NO_SERVICE_AVAILABLE]: {\n        desc: \"no service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_P2P]: {\n        desc: \"no unilbs p2p service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_VOET]: {\n        desc: \"no unilbs voice service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_WEBRTC]: {\n        desc: \"no unilbs webrtc service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_CDS]: {\n        desc: \"no cds service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_CDN]: {\n        desc: \"no cdn dispatcher service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_TDS]: {\n        desc: \"no tds service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_REPORT]: {\n        desc: \"no unilbs report service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_APP_CENTER]: {\n        desc: \"no app center service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_ENV0]: {\n        desc: \"no unilbs sig env0 service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_VOET]: {\n        desc: \"no unilbs voet service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_STRING_UID]: {\n        desc: \"no string uid service available\",\n        retry: !0\n      },\n      [Da.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: {\n        desc: \"no webrtc unilbs service available\",\n        retry: !0\n      }\n    },\n    [oc.UNILBS]: {\n      [Wa.INVALID_VENDOR_KEY]: {\n        desc: \"invalid vendor key, can not find appid\",\n        retry: !1\n      },\n      [Wa.INVALID_CHANNEL_NAME]: {\n        desc: \"invalid channel name\",\n        retry: !1\n      },\n      [Wa.INTERNAL_ERROR]: {\n        desc: \"unilbs internal error\",\n        retry: !1\n      },\n      [Wa.NO_AUTHORIZED]: {\n        desc: \"invalid token, authorized failed\",\n        retry: !1\n      },\n      [Wa.DYNAMIC_KEY_TIMEOUT]: {\n        desc: \"dynamic key or token timeout\",\n        retry: !1\n      },\n      [Wa.NO_ACTIVE_STATUS]: {\n        desc: \"no active status\",\n        retry: !1\n      },\n      [Wa.DYNAMIC_KEY_EXPIRED]: {\n        desc: \"dynamic key expired\",\n        retry: !1\n      },\n      [Wa.STATIC_USE_DYNAMIC_KEY]: {\n        desc: \"static use dynamic key\",\n        retry: !1\n      },\n      [Wa.DYNAMIC_USE_STATIC_KEY]: {\n        desc: \"dynamic use static key\",\n        retry: !1\n      },\n      [Wa.USER_OVERLOAD]: {\n        desc: \"amount of users over load\",\n        retry: !1\n      },\n      [Wa.FORBIDDEN_REGION]: {\n        desc: \"the request is forbidden in this area\",\n        retry: !1\n      },\n      [Wa.CANNOT_MEET_AREA_DEMAND]: {\n        desc: \"unable to allocate services in this area\",\n        retry: !1\n      }\n    },\n    [oc.STRING_UID_ALLOCATOR]: {\n      [ed.IIIEGAL_APPID]: {\n        desc: \"invalid appid\",\n        retry: !1\n      },\n      [ed.IIIEGAL_UID]: {\n        desc: \"invalid string uid\",\n        retry: !1\n      },\n      [ed.INTERNAL_ERROR]: {\n        desc: \"string uid allocator internal error\",\n        retry: !0\n      }\n    }\n  },\n      sl = {\n    [F.K_TIMESTAMP_EXPIRED]: {\n      desc: \"K_TIMESTAMP_EXPIRED\",\n      action: \"failed\"\n    },\n    [F.K_CHANNEL_PERMISSION_INVALID]: {\n      desc: \"K_CHANNEL_PERMISSION_INVALID\",\n      action: \"failed\"\n    },\n    [F.K_CERTIFICATE_INVALID]: {\n      desc: \"K_CERTIFICATE_INVALID\",\n      action: \"failed\"\n    },\n    [F.K_CHANNEL_NAME_EMPTY]: {\n      desc: \"K_CHANNEL_NAME_EMPTY\",\n      action: \"failed\"\n    },\n    [F.K_CHANNEL_NOT_FOUND]: {\n      desc: \"K_CHANNEL_NOT_FOUND\",\n      action: \"failed\"\n    },\n    [F.K_TICKET_INVALID]: {\n      desc: \"K_TICKET_INVALID\",\n      action: \"failed\"\n    },\n    [F.K_CHANNEL_CONFLICTED]: {\n      desc: \"K_CHANNEL_CONFLICTED\",\n      action: \"failed\"\n    },\n    [F.K_SERVICE_NOT_READY]: {\n      desc: \"K_SERVICE_NOT_READY\",\n      action: \"tryNext\"\n    },\n    [F.K_SERVICE_TOO_HEAVY]: {\n      desc: \"K_SERVICE_TOO_HEAVY\",\n      action: \"tryNext\"\n    },\n    [F.K_UID_BANNED]: {\n      desc: \"K_UID_BANNED\",\n      action: \"failed\"\n    },\n    [F.K_IP_BANNED]: {\n      desc: \"K_IP_BANNED\",\n      action: \"failed\"\n    },\n    [F.ERR_INVALID_VENDOR_KEY]: {\n      desc: \"ERR_INVALID_VENDOR_KEY\",\n      action: \"failed\"\n    },\n    [F.ERR_INVALID_CHANNEL_NAME]: {\n      desc: \"ERR_INVALID_CHANNEL_NAME\",\n      action: \"failed\"\n    },\n    [F.WARN_NO_AVAILABLE_CHANNEL]: {\n      desc: \"WARN_NO_AVAILABLE_CHANNEL\",\n      action: \"failed\"\n    },\n    [F.WARN_LOOKUP_CHANNEL_TIMEOUT]: {\n      desc: \"WARN_LOOKUP_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [F.WARN_LOOKUP_CHANNEL_REJECTED]: {\n      desc: \"WARN_LOOKUP_CHANNEL_REJECTED\",\n      action: \"failed\"\n    },\n    [F.WARN_OPEN_CHANNEL_TIMEOUT]: {\n      desc: \"WARN_OPEN_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [F.WARN_OPEN_CHANNEL_REJECTED]: {\n      desc: \"WARN_OPEN_CHANNEL_REJECTED\",\n      action: \"failed\"\n    },\n    [F.WARN_REQUEST_DEFERRED]: {\n      desc: \"WARN_REQUEST_DEFERRED\",\n      action: \"failed\"\n    },\n    [F.ERR_DYNAMIC_KEY_TIMEOUT]: {\n      desc: \"ERR_DYNAMIC_KEY_TIMEOUT\",\n      action: \"failed\"\n    },\n    [F.ERR_NO_AUTHORIZED]: {\n      desc: \"ERR_NO_AUTHORIZED\",\n      action: \"failed\"\n    },\n    [F.ERR_VOM_SERVICE_UNAVAILABLE]: {\n      desc: \"ERR_VOM_SERVICE_UNAVAILABLE\",\n      action: \"tryNext\"\n    },\n    [F.ERR_NO_CHANNEL_AVAILABLE_CODE]: {\n      desc: \"ERR_NO_CHANNEL_AVAILABLE_CODE\",\n      action: \"failed\"\n    },\n    [F.ERR_MASTER_VOCS_UNAVAILABLE]: {\n      desc: \"ERR_MASTER_VOCS_UNAVAILABLE\",\n      action: \"tryNext\"\n    },\n    [F.ERR_INTERNAL_ERROR]: {\n      desc: \"ERR_INTERNAL_ERROR\",\n      action: \"tryNext\"\n    },\n    [F.ERR_NO_ACTIVE_STATUS]: {\n      desc: \"ERR_NO_ACTIVE_STATUS\",\n      action: \"failed\"\n    },\n    [F.ERR_INVALID_UID]: {\n      desc: \"ERR_INVALID_UID\",\n      action: \"failed\"\n    },\n    [F.ERR_DYNAMIC_KEY_EXPIRED]: {\n      desc: \"ERR_DYNAMIC_KEY_EXPIRED\",\n      action: \"failed\"\n    },\n    [F.ERR_STATIC_USE_DYANMIC_KE]: {\n      desc: \"ERR_STATIC_USE_DYANMIC_KE\",\n      action: \"failed\"\n    },\n    [F.ERR_DYNAMIC_USE_STATIC_KE]: {\n      desc: \"ERR_DYNAMIC_USE_STATIC_KE\",\n      action: \"failed\"\n    },\n    [F.ERR_NO_VOCS_AVAILABLE]: {\n      desc: \"ERR_NO_VOCS_AVAILABLE\",\n      action: \"tryNext\"\n    },\n    [F.ERR_NO_VOS_AVAILABLE]: {\n      desc: \"ERR_NO_VOS_AVAILABLE\",\n      action: \"tryNext\"\n    },\n    [F.ERR_JOIN_CHANNEL_TIMEOUT]: {\n      desc: \"ERR_JOIN_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [F.ERR_JOIN_BY_MULTI_IP]: {\n      desc: \"ERR_JOIN_BY_MULTI_IP\",\n      action: \"recover\"\n    },\n    [F.ERR_NOT_JOINED]: {\n      desc: \"ERR_NOT_JOINED\",\n      action: \"failed\"\n    },\n    [F.ERR_REPEAT_JOIN_REQUEST]: {\n      desc: \"ERR_REPEAT_JOIN_REQUEST\",\n      action: \"quit\"\n    },\n    [F.ERR_REPEAT_JOIN_CHANNEL]: {\n      desc: \"ERR_REPEAT_JOIN_CHANNEL\",\n      action: \"quit\"\n    },\n    [F.ERR_INVALID_VENDOR_KEY]: {\n      desc: \"ERR_INVALID_VENDOR_KEY\",\n      action: \"failed\"\n    },\n    [F.ERR_INVALID_CHANNEL_NAME]: {\n      desc: \"ERR_INVALID_CHANNEL_NAME\",\n      action: \"failed\"\n    },\n    [F.ERR_INVALID_STRINGUID]: {\n      desc: \"ERR_INVALID_STRINGUID\",\n      action: \"failed\"\n    },\n    [F.ERR_TOO_MANY_USERS]: {\n      desc: \"ERR_TOO_MANY_USERS\",\n      action: \"tryNext\"\n    },\n    [F.ERR_SET_CLIENT_ROLE_TIMEOUT]: {\n      desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n      action: \"failed\"\n    },\n    [F.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: {\n      desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n      action: \"failed\"\n    },\n    [F.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: {\n      desc: \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\",\n      action: \"success\"\n    },\n    [F.ERR_PUBLISH_REQUEST_INVALID]: {\n      desc: \"ERR_PUBLISH_REQUEST_INVALID\",\n      action: \"failed\"\n    },\n    [F.ERR_SUBSCRIBE_REQUEST_INVALID]: {\n      desc: \"ERR_SUBSCRIBE_REQUEST_INVALID\",\n      action: \"failed\"\n    },\n    [F.ERR_NOT_SUPPORTED_MESSAGE]: {\n      desc: \"ERR_NOT_SUPPORTED_MESSAGE\",\n      action: \"failed\"\n    },\n    [F.ERR_ILLEAGAL_PLUGIN]: {\n      desc: \"ERR_ILLEAGAL_PLUGIN\",\n      action: \"failed\"\n    },\n    [F.ILLEGAL_CLIENT_ROLE_LEVEL]: {\n      desc: \"ILLEGAL_CLIENT_ROLE_LEVEL\",\n      action: \"failed\"\n    },\n    [F.ERR_REJOIN_TOKEN_INVALID]: {\n      desc: \"ERR_REJOIN_TOKEN_INVALID\",\n      action: \"failed\"\n    },\n    [F.ERR_REJOIN_USER_NOT_JOINED]: {\n      desc: \"ERR_REJOIN_NOT_JOINED\",\n      action: \"failed\"\n    },\n    [F.ERR_INVALID_OPTIONAL_INFO]: {\n      desc: \"ERR_INVALID_OPTIONAL_INFO\",\n      action: \"quit\"\n    },\n    [F.ERR_TEST_RECOVER]: {\n      desc: \"ERR_TEST_RECOVER\",\n      action: \"recover\"\n    },\n    [F.ERR_TEST_TRYNEXT]: {\n      desc: \"ERR_TEST_TRYNEXT\",\n      action: \"recover\"\n    },\n    [F.ERR_TEST_RETRY]: {\n      desc: \"ERR_TEST_RETRY\",\n      action: \"recover\"\n    },\n    [F.ILLEGAL_AES_PASSWORD]: {\n      desc: \"ERR_TEST_RETRY\",\n      action: \"failed\"\n    }\n  },\n      Qa = {\n    timeout: 500,\n    timeoutFactor: 1.5,\n    maxRetryCount: 1 / 0,\n    maxRetryTimeout: 1E4\n  };\n\n  class cg extends Sa {\n    constructor(a, b) {\n      super();\n      this.currentURLIndex = this.connectionID = 0;\n      this.reconnectMode = \"tryNext\";\n      this._state = \"closed\";\n      this.reconnectCount = 0;\n      this.name = a;\n      this.retryConfig = b;\n    }\n\n    get url() {\n      return this.websocket ? this.websocket.url : null;\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    set state(a) {\n      a !== this._state && (this._state = a, \"reconnecting\" === this._state ? this.emit(S.RECONNECTING, this.reconnectReason) : \"connected\" === this._state ? this.emit(S.CONNECTED) : \"closed\" === this._state ? this.emit(S.CLOSED) : \"failed\" === this._state && this.emit(S.FAILED));\n    }\n\n    init(a) {\n      return new A((b, c) => {\n        this.urls = a;\n        let e = this.urls[this.currentURLIndex];\n        this.state = \"connecting\";\n        this.createWebSocketConnection(e).then(b).catch(c);\n        this.once(S.CLOSED, () => c(new n(l.WS_DISCONNECT)));\n        this.once(S.CONNECTED, () => b());\n      });\n    }\n\n    close(a, b) {\n      if (this.currentURLIndex = 0, this.reconnectCount = 0, this.websocket) {\n        this.websocket.onclose = null;\n        this.websocket.onopen = null;\n        this.websocket.onmessage = null;\n        let a = this.websocket;\n        b ? Ub(() => a.close(), 500) : a.close();\n        this.websocket = void 0;\n      }\n\n      this.state = a ? \"failed\" : \"closed\";\n    }\n\n    reconnect(a, b) {\n      if (!this.websocket) return void k.warning(\"[\".concat(this.name, \"] can not reconnect, no websocket\"));\n      void 0 !== a && (this.reconnectMode = a);\n      k.debug(\"[\".concat(this.name, \"] reconnect is triggered initiative\"));\n      a = this.websocket.onclose;\n      this.websocket.onclose = null;\n      this.websocket.close();\n      a && ra(a).call(a, this.websocket)({\n        code: 9999,\n        reason: b\n      });\n    }\n\n    sendMessage(a) {\n      if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new n(l.WS_ABORT, \"websocket is not ready\");\n      a = w(a);\n\n      try {\n        this.websocket.send(a);\n      } catch (b) {\n        throw new n(l.WS_ERR, \"send websocket message error\" + b.toString());\n      }\n    }\n\n    createWebSocketConnection(a) {\n      var _this11 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = _this11.connectionID += 1;\n        return new A((c, e) => {\n          var g, h;\n          _this11.websocket && (_this11.websocket.onclose = null, _this11.websocket.close());\n          v.GATEWAY_WSS_ADDRESS && sd(g = _this11.name).call(g, \"gateway\") && (a = v.GATEWAY_WSS_ADDRESS);\n          k.debug(m(h = \"[\".concat(_this11.name, \"] start connect, url: \")).call(h, a));\n\n          try {\n            _this11.websocket = new WebSocket(a), _this11.websocket.binaryType = \"arraybuffer\";\n          } catch (r) {\n            var p;\n            g = new n(l.WS_ERR, \"init websocket failed! Error: \".concat(r.toString()));\n            return k.error(m(p = \"[\".concat(_this11.name, \"]\")).call(p, g)), void e(g);\n          }\n\n          wb(5E3).then(() => {\n            b === _this11.connectionID && _this11.websocket && _this11.websocket.readyState !== WebSocket.OPEN && _this11.websocket && _this11.websocket.close();\n          });\n\n          _this11.websocket.onopen = () => {\n            k.debug(\"[\".concat(_this11.name, \"] websocket opened:\"), a);\n            _this11.reconnectMode = \"retry\";\n            _this11.state = \"connected\";\n            _this11.reconnectCount = 0;\n            c();\n          };\n\n          _this11.websocket.onclose = /*#__PURE__*/function () {\n            var _ref7 = _asyncToGenerator(function* (a) {\n              var b, g, h, p;\n\n              if (k.debug(m(b = m(g = m(h = m(p = \"[\".concat(_this11.name, \"] websocket close \")).call(p, _this11.websocket && _this11.websocket.url, \", code: \")).call(h, a.code, \", reason: \")).call(g, a.reason, \", current mode: \")).call(b, _this11.reconnectMode)), _this11.reconnectCount < _this11.retryConfig.maxRetryCount) {\n                \"connected\" === _this11.state && (_this11.reconnectReason = a.reason, _this11.state = \"reconnecting\");\n                b = Zb(_this11, S.WILL_RECONNECT, _this11.reconnectMode) || _this11.reconnectMode;\n                b = yield _this11.reconnectWithAction(b);\n                if (\"closed\" === _this11.state) return void k.debug(\"[\".concat(_this11.connectionID, \"] ws is closed, no need to reconnect\"));\n                if (!b) return e(new n(l.WS_DISCONNECT, \"websocket reconnect failed: \".concat(a.code))), void _this11.close(!0);\n                c();\n              } else e(new n(l.WS_DISCONNECT, \"websocket close: \".concat(a.code))), _this11.close();\n            });\n\n            return function (_x37) {\n              return _ref7.apply(this, arguments);\n            };\n          }();\n\n          _this11.websocket.onmessage = a => {\n            _this11.emit(S.ON_MESSAGE, a);\n          };\n        });\n      })();\n    }\n\n    reconnectWithAction(a, b) {\n      var _this12 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e;\n        if (!b && _this12.reconnectCount >= _this12.retryConfig.maxRetryCount || !_this12.urls || \"closed\" === _this12.state) return !1;\n        _this12.onlineReconnectListener || !navigator || void 0 === navigator.onLine || navigator.onLine || (_this12.onlineReconnectListener = new A(a => {\n          let b = () => {\n            _this12.onlineReconnectListener = void 0;\n            window.removeEventListener(\"online\", b);\n            a();\n          };\n\n          window.addEventListener(\"online\", b);\n        }));\n\n        b = function (a, b) {\n          return Math.min(b.maxRetryTimeout, b.timeout * Math.pow(b.timeoutFactor, a));\n        }(_this12.reconnectCount, _this12.retryConfig);\n\n        if (k.debug(m(c = m(e = \"[\".concat(_this12.name, \"] wait \")).call(e, b, \"ms to reconnect websocket, mode: \")).call(c, a)), yield A.race([wb(b), _this12.onlineReconnectListener || new A(() => {})]), \"closed\" === _this12.state) return !1;\n        _this12.reconnectCount += 1;\n\n        try {\n          if (\"retry\" === a) yield _this12.createWebSocketConnection(_this12.urls[_this12.currentURLIndex]);else if (\"tryNext\" === a) {\n            var g, h;\n            if (_this12.currentURLIndex += 1, _this12.currentURLIndex >= _this12.urls.length) return yield _this12.reconnectWithAction(\"recover\");\n            k.debug(m(g = m(h = \"[\".concat(_this12.name, \"] websocket url length: \")).call(h, _this12.urls.length, \" current index: \")).call(g, _this12.currentURLIndex));\n            yield _this12.createWebSocketConnection(_this12.urls[_this12.currentURLIndex]);\n          } else \"recover\" === a && (k.debug(\"[\".concat(_this12.name, \"] request new urls\")), _this12.urls = yield La(_this12, S.REQUEST_NEW_URLS), _this12.currentURLIndex = 0, yield _this12.createWebSocketConnection(_this12.urls[_this12.currentURLIndex]));\n          return !0;\n        } catch (p) {\n          return k.error(\"[\".concat(_this12.name, \"] reconnect failed\"), p.toString()), yield _this12.reconnectWithAction(a);\n        }\n      })();\n    }\n\n  }\n\n  class lo {\n    constructor(a) {\n      this.input = [];\n      this.size = a;\n    }\n\n    add(a) {\n      var b;\n      (this.input.push(a), this.input.length > this.size) && Ia(b = this.input).call(b, 0, 1);\n    }\n\n    mean() {\n      var a;\n      return 0 === this.input.length ? 0 : qd(a = this.input).call(a, (a, c) => a + c) / this.input.length;\n    }\n\n  }\n\n  class mo extends Sa {\n    constructor(a) {\n      super();\n      this._connectionState = ta.CLOSED;\n      this.openConnectionTime = x();\n      this.lastMsgTime = x();\n      this.uploadCache = [];\n      this.rttRolling = new lo(5);\n      this.pingpongTimeoutCount = 0;\n\n      this.onWebsocketMessage = a => {\n        if (a.data instanceof ArrayBuffer) return void this.emit(Q.ON_BINARY_DATA, a.data);\n        a = JSON.parse(a.data);\n\n        if (this.lastMsgTime = x(), Object.prototype.hasOwnProperty.call(a, \"_id\")) {\n          let b = \"res-@\".concat(a._id);\n          this.emit(b, a._result, a._message);\n        } else if (Object.prototype.hasOwnProperty.call(a, \"_type\") && (this.emit(a._type, a._message), a._type === U.ON_NOTIFICATION && this.handleNotification(a._message), a._type === U.ON_USER_BANNED)) switch (a._message.error_code) {\n          case 14:\n            this.close(\"UID_BANNED\");\n            break;\n\n          case 15:\n            this.close(\"IP_BANNED\");\n            break;\n\n          case 16:\n            this.close(\"CHANNEL_BANNED\");\n        }\n      };\n\n      this.clientId = a.clientId;\n      this.spec = a;\n      this.websocket = new cg(\"gateway-\".concat(this.clientId), this.spec.retryConfig);\n      this.handleWebsocketEvents();\n      window.addEventListener(\"offline\", () => {\n        this.connectionState === ta.CONNECTED && this.reconnect(\"retry\", Ra.OFFLINE);\n      });\n    }\n\n    get connectionState() {\n      return this._connectionState;\n    }\n\n    set connectionState(a) {\n      a !== this._connectionState && (this._connectionState = a, a === ta.CONNECTED ? this.emit(Q.WS_CONNECTED) : a === ta.RECONNECTING ? this.emit(Q.WS_RECONNECTING, this._websocketReconnectReason) : a === ta.CLOSED && this.emit(Q.WS_CLOSED, this._disconnectedReason));\n    }\n\n    get currentURLIndex() {\n      return this.websocket.currentURLIndex;\n    }\n\n    get url() {\n      return this.websocket ? this.websocket.url : null;\n    }\n\n    get rtt() {\n      return this.rttRolling.mean();\n    }\n\n    request(a, b, c) {\n      var _this13 = this;\n\n      return _asyncToGenerator(function* () {\n        var e, g, h, p, r;\n        let t = qa(6, \"\");\n        var y = {\n          _id: t,\n          _type: a,\n          _message: b\n        };\n        let q = _this13.websocket.connectionID;\n\n        var D = () => new A((a, b) => {\n          if (_this13.connectionState === ta.CONNECTED) return a();\n\n          const c = () => {\n            _this13.off(Q.WS_CLOSED, e);\n\n            a();\n          },\n                e = () => {\n            _this13.off(Q.WS_CONNECTED, c);\n\n            b(new n(l.WS_ABORT));\n          };\n\n          _this13.once(Q.WS_CONNECTED, c);\n\n          _this13.once(Q.WS_CLOSED, e);\n        });\n\n        _this13.connectionState !== ta.CONNECTING && _this13.connectionState !== ta.RECONNECTING || a === da.JOIN || a === da.REJOIN || (yield D());\n        var u = new A((c, e) => {\n          let g = !1;\n\n          const h = (e, h) => {\n            g = !0;\n            c({\n              isSuccess: \"success\" === e,\n              message: h || {}\n            });\n\n            _this13.off(Q.WS_CLOSED, p);\n\n            _this13.off(Q.WS_RECONNECTING, p);\n\n            _this13.emit(Q.REQUEST_SUCCESS, a, b);\n          };\n\n          _this13.once(\"res-@\".concat(t), h);\n\n          const p = () => {\n            e(new n(l.WS_ABORT, \"type: \".concat(a)));\n\n            _this13.off(Q.WS_CLOSED, p);\n\n            _this13.off(Q.WS_RECONNECTING, p);\n\n            _this13.off(\"res-@\".concat(t), h);\n          };\n\n          _this13.once(Q.WS_CLOSED, p);\n\n          _this13.once(Q.WS_RECONNECTING, p);\n\n          wb(v.SIGNAL_REQUEST_TIMEOUT).then(() => {\n            _this13.websocket.connectionID !== q || g || (k.warning(\"ws request timeout, type: \".concat(a)), _this13.emit(Q.REQUEST_TIMEOUT, a, b));\n          });\n        });\n\n        _this13.websocket.sendMessage(y);\n\n        y = null;\n\n        try {\n          y = yield u;\n        } catch (z) {\n          if (_this13.connectionState === ta.CLOSED || a === da.LEAVE) throw new n(l.WS_ABORT);\n          return !_this13.spec.forceWaitGatewayResponse || c ? z.throw() : a === da.JOIN || a === da.REJOIN ? null : (yield D(), yield _this13.request(a, b));\n        }\n\n        if (y.isSuccess) return y.message;\n        c = Number(y.message.error_code || y.message.code);\n        D = Ah(c);\n        u = new n(l.UNEXPECTED_RESPONSE, m(e = \"\".concat(D.desc, \": \")).call(e, y.message.error_str), {\n          code: c,\n          data: y.message\n        });\n        return \"success\" === D.action ? y.message : (k.warning(m(g = m(h = m(p = m(r = \"[\".concat(_this13.websocket.connectionID, \"] unexpected response from type \")).call(r, a, \", error_code: \")).call(p, c, \", message: \")).call(h, D.desc, \", action: \")).call(g, D.action)), \"failed\" === D.action ? u.throw() : \"quit\" === D.action ? (_this13.initError = u, _this13.close(), u.throw()) : (c === F.ERR_JOIN_BY_MULTI_IP ? (_this13.multiIpOption = y.message.option, k.warning(\"[\".concat(_this13.clientId, \"] detect multi ip, recover\")), _this13.reconnect(\"recover\", Ra.MULTI_IP)) : _this13.reconnect(D.action, Ra.SERVER_ERROR), a === da.JOIN || a === da.REJOIN ? null : yield _this13.request(a, b)));\n      })();\n    }\n\n    waitMessage(a, b) {\n      return new A(c => {\n        let e = g => {\n          b && !b(g) || (this.off(a, e), c(g));\n        };\n\n        this.on(a, e);\n      });\n    }\n\n    upload(a, b) {\n      a = {\n        _type: a,\n        _message: b\n      };\n\n      try {\n        this.websocket.sendMessage(a);\n      } catch (e) {\n        k.info(\"[\".concat(this.clientId, \"] upload failed, cache message\"), e);\n        b = v.MAX_UPLOAD_CACHE || 50;\n        var c;\n        (this.uploadCache.push(a), this.uploadCache.length > b) && Ia(c = this.uploadCache).call(c, 0, 1);\n        0 < this.uploadCache.length && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {\n          var a;\n\n          if (this.connectionState === ta.CONNECTED) {\n            var b = Ia(a = this.uploadCache).call(a, 0, 1)[0];\n            0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0);\n            this.upload(b._type, b._message);\n          }\n        }, v.UPLOAD_CACHE_INTERVAL || 2E3));\n      }\n    }\n\n    send(a, b) {\n      this.websocket.sendMessage({\n        _type: a,\n        _message: b\n      });\n    }\n\n    init(a) {\n      return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, new A((b, c) => {\n        this.once(Q.WS_CONNECTED, () => b(this.joinResponse));\n        this.once(Q.WS_CLOSED, () => c(this.initError || new n(l.WS_ABORT)));\n        this.connectionState = ta.CONNECTING;\n        this.websocket.init(a).catch(c);\n      });\n    }\n\n    close(a) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);\n      this.joinResponse = this.reconnectToken = void 0;\n      this._disconnectedReason = a || \"LEAVE\";\n      this.connectionState = ta.CLOSED;\n      this.websocket.close();\n    }\n\n    join() {\n      var _this14 = this;\n\n      return _asyncToGenerator(function* () {\n        var a;\n\n        if (!_this14.joinResponse) {\n          var b = Mc(_this14, Q.REQUEST_JOIN_INFO);\n          b = yield _this14.request(da.JOIN, b);\n          if (!b) return _this14.emit(Q.REPORT_JOIN_GATEWAY, l.TIMEOUT, _this14.url || \"\"), !1;\n          _this14.joinResponse = b;\n          _this14.reconnectToken = _this14.joinResponse.rejoin_token;\n        }\n\n        return _this14.connectionState = ta.CONNECTED, _this14.pingpongTimer && window.clearInterval(_this14.pingpongTimer), _this14.pingpongTimer = window.setInterval(ra(a = _this14.handlePingPong).call(a, _this14), 3E3), !0;\n      })();\n    }\n\n    rejoin() {\n      var _this15 = this;\n\n      return _asyncToGenerator(function* () {\n        var a, b;\n        if (!_this15.reconnectToken) throw new n(l.UNEXPECTED_ERROR, \"can not rejoin, no rejoin token\");\n        var c = Mc(_this15, Q.REQUEST_REJOIN_INFO);\n        c.token = _this15.reconnectToken;\n        c = yield _this15.request(da.REJOIN, c);\n        return !!c && (_this15.connectionState = ta.CONNECTED, _this15.pingpongTimer && window.clearInterval(_this15.pingpongTimer), _this15.pingpongTimer = window.setInterval(ra(a = _this15.handlePingPong).call(a, _this15), 3E3), c.peers && q(b = c.peers).call(b, a => {\n          _this15.emit(U.ON_USER_ONLINE, {\n            uid: a.uid\n          });\n\n          a.audio_mute ? _this15.emit(U.MUTE_AUDIO, {\n            uid: a.uid\n          }) : _this15.emit(U.UNMUTE_AUDIO, {\n            uid: a.uid\n          });\n          a.video_mute ? _this15.emit(U.MUTE_VIDEO, {\n            uid: a.uid\n          }) : _this15.emit(U.UNMUTE_VIDEO, {\n            uid: a.uid\n          });\n          a.audio_enable_local ? _this15.emit(U.ENABLE_LOCAL_AUDIO, {\n            uid: a.uid\n          }) : _this15.emit(U.DISABLE_LOCAL_AUDIO, {\n            uid: a.uid\n          });\n          a.video_enable_local ? _this15.emit(U.ENABLE_LOCAL_VIDEO, {\n            uid: a.uid\n          }) : _this15.emit(U.DISABLE_LOCAL_VIDEO, {\n            uid: a.uid\n          });\n          a.audio || a.video || _this15.emit(U.ON_REMOVE_STREAM, {\n            uid: a.uid,\n            uint_id: a.uint_id\n          });\n          a.audio && _this15.emit(U.ON_ADD_AUDIO_STREAM, {\n            uid: a.uid,\n            uint_id: a.uint_id,\n            audio: !0\n          });\n          a.video && _this15.emit(U.ON_ADD_VIDEO_STREAM, {\n            uid: a.uid,\n            uint_id: a.uint_id,\n            video: !0\n          });\n        }), !0);\n      })();\n    }\n\n    reconnect(a, b) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);\n      this.websocket.reconnect(a, b);\n    }\n\n    handleNotification(a) {\n      k.debug(\"[\".concat(this.clientId, \"] receive notification: \"), a);\n      a = Ah(a.code);\n\n      if (\"success\" !== a.action) {\n        if (\"failed\" !== a.action) return \"quit\" === a.action ? (\"ERR_REPEAT_JOIN_CHANNEL\" === a.desc && this.close(\"UID_BANNED\"), void this.close()) : void this.reconnect(a.action, Ra.SERVER_ERROR);\n        k.error(\"[\".concat(this.clientId, \"] ignore error: \"), a.desc);\n      }\n    }\n\n    handlePingPong() {\n      if (this.websocket && \"connected\" === this.websocket.state) {\n        0 < this.pingpongTimeoutCount && this.rttRolling.add(3E3);\n        this.pingpongTimeoutCount += 1;\n        var a = v.PING_PONG_TIME_OUT,\n            b = x();\n        this.pingpongTimeoutCount >= a && (k.warning(\"PINGPONG Timeout. Last Socket Message: \".concat(b - this.lastMsgTime, \"ms\")), b - this.lastMsgTime > v.WEBSOCKET_TIMEOUT_MIN) ? this.reconnect(\"retry\", Ra.TIMEOUT) : this.request(da.PING, void 0, !0).then(() => {\n          this.pingpongTimeoutCount = 0;\n          let a = x() - b;\n          this.rttRolling.add(a);\n          v.REPORT_STATS && this.send(da.PING_BACK, {\n            pingpongElapse: a\n          });\n        }).catch(a => {});\n      }\n    }\n\n    handleWebsocketEvents() {\n      this.websocket.on(S.ON_MESSAGE, this.onWebsocketMessage);\n      this.websocket.on(S.CLOSED, () => {\n        this.connectionState = ta.CLOSED;\n      });\n      this.websocket.on(S.FAILED, () => {\n        this._disconnectedReason = \"NETWORK_ERROR\";\n        this.connectionState = ta.CLOSED;\n      });\n      this.websocket.on(S.RECONNECTING, a => {\n        this._websocketReconnectReason = a;\n        this.joinResponse = void 0;\n        this.connectionState === ta.CONNECTED ? this.connectionState = ta.RECONNECTING : this.connectionState = ta.CONNECTING;\n      });\n      this.websocket.on(S.WILL_RECONNECT, (a, b) => {\n        if (Mc(this, Q.IS_P2P_DISCONNECTED) && \"retry\" === a) return this.reconnectToken = void 0, this.emit(Q.NEED_RENEW_SESSION), this.emit(Q.DISCONNECT_P2P), b(\"tryNext\");\n        \"retry\" !== a && (this.reconnectToken = void 0, this.emit(Q.NEED_RENEW_SESSION), this.emit(Q.DISCONNECT_P2P));\n        b(a);\n      });\n      this.websocket.on(S.CONNECTED, () => {\n        this.openConnectionTime = x();\n        this.reconnectToken ? this.rejoin().catch(a => {\n          var b;\n          k.warning(m(b = \"[\".concat(this.clientId, \"] rejoin failed \")).call(b, a));\n          this.reconnect(\"tryNext\", Ra.SERVER_ERROR);\n        }) : this.join().catch(a => {\n          if (this.emit(Q.REPORT_JOIN_GATEWAY, a.message || a.code, this.url || \"\"), a instanceof n && a.code === l.UNEXPECTED_RESPONSE && a.data.code === F.ERR_NO_AUTHORIZED) return k.warning(\"[\".concat(this.clientId, \"] reconnect no authorized, recover\")), void this.reconnect(\"recover\", Ra.SERVER_ERROR);\n          k.error(\"[\".concat(this.clientId, \"] join gateway request failed\"), a.toString());\n          this.spec.forceWaitGatewayResponse ? this.reconnect(\"tryNext\", Ra.SERVER_ERROR) : (this.initError = a, this.close());\n        });\n      });\n      this.websocket.on(S.REQUEST_NEW_URLS, (a, b) => {\n        La(this, Q.REQUEST_RECOVER, this.multiIpOption).then(a).catch(b);\n      });\n    }\n\n  }\n\n  class Bk extends Sa {\n    constructor(a, b) {\n      super();\n      this._hints = [];\n      this._ID = b || qa(8, \"track-\");\n      this._mediaStreamTrack = this._originMediaStreamTrack = a;\n    }\n\n    toString() {\n      return this._ID;\n    }\n\n    getTrackId() {\n      return this._ID;\n    }\n\n    getMediaStreamTrack(a) {\n      a || (a = u.reportApiInvoke(null, {\n        name: C.GET_MEDIA_STREAM_TRACK,\n        options: [],\n        tag: B.TRACER\n      }), this._mediaStreamTrack && \"string\" == typeof this._mediaStreamTrack.label ? a.onSuccess(this._mediaStreamTrack.label) : a.onSuccess(\"\"));\n      return this._mediaStreamTrack;\n    }\n\n  }\n\n  class ne extends Bk {\n    constructor(a, b) {\n      super(a, b);\n      this._enabled = !0;\n      this._isClosed = !1;\n      this._trackProcessors = [];\n\n      this._handleTrackEnded = () => {\n        k.debug(\"[\".concat(this.getTrackId, \"] track ended\"));\n        this.emit(fd.TRACK_ENDED);\n      };\n\n      this._enabledMutex = new Mb(\"\".concat(b));\n      a.addEventListener(\"ended\", this._handleTrackEnded);\n    }\n\n    getTrackLabel() {\n      return this._originMediaStreamTrack.label;\n    }\n\n    close() {\n      var a;\n      this._isClosed || (this.stop(), q(a = this._trackProcessors).call(a, a => a.destroy()), this._trackProcessors = [], this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, k.debug(\"[\".concat(this.getTrackId(), \"] close\")), this.emit(M.NEED_CLOSE), this._isClosed = !0);\n    }\n\n    _registerTrackProcessor(a) {\n      var _this16 = this;\n\n      return _asyncToGenerator(function* () {\n        var b;\n\n        if (-1 === J(b = _this16._trackProcessors).call(b, a)) {\n          var c = _this16._trackProcessors[_this16._trackProcessors.length - 1];\n\n          _this16._trackProcessors.push(a);\n\n          a.onOutputChange = /*#__PURE__*/_asyncToGenerator(function* () {\n            _this16._mediaStreamTrack = a.output || _this16._originMediaStreamTrack;\n\n            _this16._updatePlayerSource();\n\n            yield Pa(_this16, M.NEED_REPLACE_TRACK, _this16._mediaStreamTrack);\n          });\n          c ? (c.onOutputChange = /*#__PURE__*/_asyncToGenerator(function* () {\n            c.output && (yield a.setInput(c.output));\n          }), yield a.setInput(c.output || c.input || _this16._originMediaStreamTrack)) : yield a.setInput(_this16._originMediaStreamTrack);\n        }\n      })();\n    }\n\n    _getOutputFromProcessors() {\n      if (0 === this._trackProcessors.length) return this._originMediaStreamTrack;\n      let a = this._trackProcessors[this._trackProcessors.length - 1];\n      return a.output || a.input || this._originMediaStreamTrack;\n    }\n\n    _updateOriginMediaStreamTrack(a, b) {\n      var _this17 = this;\n\n      return _asyncToGenerator(function* () {\n        a !== _this17._originMediaStreamTrack && ((_this17._originMediaStreamTrack.removeEventListener(\"ended\", _this17._handleTrackEnded), b && _this17._originMediaStreamTrack.stop(), a.addEventListener(\"ended\", _this17._handleTrackEnded), _this17._originMediaStreamTrack = a, 0 < _this17._trackProcessors.length) ? (yield _this17._trackProcessors[0].setInput(a), _this17._mediaStreamTrack = _this17._getOutputFromProcessors()) : _this17._mediaStreamTrack = _this17._originMediaStreamTrack, _this17._updatePlayerSource(), yield Pa(_this17, M.NEED_REPLACE_TRACK, _this17._mediaStreamTrack));\n      })();\n    }\n\n    _getDefaultPlayerConfig() {\n      return {};\n    }\n\n  }\n\n  let Bh = window.AudioContext || window.webkitAudioContext,\n      pc = null,\n      Pc = new Sa(),\n      Ke = null;\n\n  class Ck extends Sa {\n    constructor() {\n      super();\n      this.isPlayed = !1;\n      this.audioOutputLevel = this.audioLevelBase = 0;\n      this.audioOutputLevelCache = null;\n      this.audioOutputLevelCacheMaxLength = v.AUDIO_SOURCE_AVG_VOLUME_DURATION / v.AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL || 15;\n      this.isDestroyed = !1;\n      this._noAudioInputCount = 0;\n      this.context = Qc();\n      this.playNode = this.context.destination;\n      this.outputNode = this.context.createGain();\n      Rc(this.outputNode);\n      this.analyserNode = this.context.createAnalyser();\n    }\n\n    get isNoAudioInput() {\n      return 3 <= this.noAudioInputCount;\n    }\n\n    get noAudioInputCount() {\n      return this._noAudioInputCount;\n    }\n\n    set noAudioInputCount(a) {\n      3 > this._noAudioInputCount && 3 <= a ? this.onNoAudioInput && this.onNoAudioInput() : 3 <= this._noAudioInputCount && 0 == this._noAudioInputCount % 10 && this.onNoAudioInput && this.onNoAudioInput();\n      this._noAudioInputCount = a;\n    }\n\n    startGetAudioBuffer(a) {\n      this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(a), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = a => {\n        this.emit(ib.ON_AUDIO_BUFFER, function (a) {\n          for (let b = 0; b < a.outputBuffer.numberOfChannels; b += 1) {\n            let c = a.outputBuffer.getChannelData(b);\n\n            for (let a = 0; a < c.length; a += 1) c[a] = 0;\n          }\n\n          return a.inputBuffer;\n        }(a));\n      });\n    }\n\n    stopGetAudioBuffer() {\n      this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);\n    }\n\n    createOutputTrack() {\n      if (!ha.webAudioMediaStreamDest) throw new n(l.NOT_SUPPORTED, \"your browser is not support audio processor\");\n      return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;\n    }\n\n    play(a) {\n      \"running\" !== this.context.state && Za(() => {\n        Pc.emit(\"autoplay-failed\");\n      });\n      this.isPlayed = !0;\n      this.playNode = a || this.context.destination;\n      this.outputNode.connect(this.playNode);\n    }\n\n    stop() {\n      if (this.isPlayed) try {\n        this.outputNode.disconnect(this.playNode);\n      } catch (a) {}\n      this.isPlayed = !1;\n    }\n\n    getAudioLevel() {\n      return this.audioOutputLevel;\n    }\n\n    getAccurateVolumeLevel() {\n      let a = new Uint8Array(this.analyserNode.frequencyBinCount);\n      this.analyserNode.getByteFrequencyData(a);\n      let b = 0;\n\n      for (let c = 0; c < a.length; c++) b += a[c];\n\n      return b / a.length;\n    }\n\n    getAudioAvgLevel() {\n      var a;\n      null === this.audioOutputLevelCache && (this.audioOutputLevelCache = [this.audioOutputLevel]);\n      return qd(a = this.audioOutputLevelCache).call(a, (a, c) => a + c) / this.audioOutputLevelCache.length;\n    }\n\n    getAudioVolume() {\n      return this.outputNode.gain.value;\n    }\n\n    setVolume(a) {\n      this.outputNode.gain.setValueAtTime(a, this.context.currentTime);\n    }\n\n    setMute(a) {\n      a ? (this.disconnect(), this.audioLevelBase = 0, this.audioOutputLevel = 0) : this.connect();\n    }\n\n    destroy() {\n      this.disconnect();\n      this.stop();\n      this.isDestroyed = !0;\n      this.onNoAudioInput = void 0;\n    }\n\n    disconnect() {\n      this.sourceNode && this.sourceNode.disconnect();\n      this.outputNode && this.outputNode.disconnect();\n      window.clearInterval(this.updateAudioOutputLevelInterval);\n    }\n\n    connect() {\n      var a;\n      this.sourceNode && this.sourceNode.connect(this.outputNode);\n      this.outputNode.connect(this.analyserNode);\n      this.updateAudioOutputLevelInterval = window.setInterval(ra(a = this.updateAudioOutputLevel).call(a, this), v.AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL || 400);\n    }\n\n    updateAudioOutputLevel() {\n      if (this.context && \"running\" !== this.context.state && this.context.resume(), this.analyserNode) {\n        if (this.analyserNode.getFloatTimeDomainData) {\n          var a = new Float32Array(this.analyserNode.frequencyBinCount);\n          this.analyserNode.getFloatTimeDomainData(a);\n        } else {\n          var b;\n          a = new Uint8Array(this.analyserNode.frequencyBinCount);\n          this.analyserNode.getByteTimeDomainData(a);\n          let c = !0;\n          a = new Float32Array(E(b = Gb(a)).call(b, a => (128 !== a && (c = !1), .0078125 * (a - 128))));\n          c ? this.noAudioInputCount += 1 : this.noAudioInputCount = 0;\n        }\n\n        for (b = 0; b < a.length; b += 1) Math.abs(a[b]) > this.audioLevelBase && (this.audioLevelBase = Math.abs(a[b]), 1 < this.audioLevelBase && (this.audioLevelBase = 1));\n\n        this.audioOutputLevel = this.audioLevelBase;\n        this.audioLevelBase /= 4;\n        null !== this.audioOutputLevelCache && (this.audioOutputLevelCache.push(this.audioOutputLevel), this.audioOutputLevelCache.length > this.audioOutputLevelCacheMaxLength && this.audioOutputLevelCache.shift());\n      }\n    }\n\n  }\n\n  class Dk extends Ck {\n    constructor(a, b) {\n      if (super(), this.isCurrentTrackCloned = !1, this.isRemoteTrack = !1, this.rebuildWebAudio = () => {\n        if (k.debug(\"ready to rebuild web audio, state:\", this.context.state), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener(\"click\", this.rebuildWebAudio, !0), void k.debug(\"rebuild web audio success, current volume\", this.getAudioLevel());\n        this.context.resume().then(() => k.info(\"resume success\"));\n        k.debug(\"rebuild web audio because of ios 12 bugs\");\n        this.disconnect();\n        var a = this.track;\n        this.track = this.track.clone();\n        this.isCurrentTrackCloned ? a.stop() : this.isCurrentTrackCloned = !0;\n        a = new MediaStream([this.track]);\n        this.sourceNode = this.context.createMediaStreamSource(a);\n        Rc(this.sourceNode);\n        this.analyserNode = this.context.createAnalyser();\n        let b = this.outputNode.gain.value;\n        this.outputNode = this.context.createGain();\n        this.outputNode.gain.setValueAtTime(b, this.context.currentTime);\n        Rc(this.outputNode);\n        this.connect();\n        this.audioElement.srcObject = a;\n        this.isPlayed && this.play(this.playNode);\n      }, \"audio\" !== a.kind) throw new n(l.UNEXPECTED_ERROR);\n      this.track = a;\n      a = new MediaStream([this.track]);\n      this.isRemoteTrack = !!b;\n      this.sourceNode = this.context.createMediaStreamSource(a);\n      Rc(this.sourceNode);\n      this.connect();\n      this.audioElement = document.createElement(\"audio\");\n      this.audioElement.srcObject = a;\n      a = na();\n      b && a.os === X.IOS && (Pc.on(\"state-change\", this.rebuildWebAudio), this.onNoAudioInput = () => {\n        document.body.addEventListener(\"click\", this.rebuildWebAudio, !0);\n      });\n    }\n\n    get isFreeze() {\n      return !1;\n    }\n\n    updateTrack(a) {\n      this.sourceNode.disconnect();\n      this.track = a;\n      this.isCurrentTrackCloned = !1;\n      a = new MediaStream([a]);\n      this.sourceNode = this.context.createMediaStreamSource(a);\n      Rc(this.sourceNode);\n      this.sourceNode.connect(this.outputNode);\n      this.audioElement.srcObject = a;\n    }\n\n    destroy() {\n      this.audioElement.remove();\n      Pc.off(\"state-change\", this.rebuildWebAudio);\n      super.destroy();\n    }\n\n  }\n\n  let db = new class {\n    constructor() {\n      this.elementMap = new aa();\n      this.elementsNeedToResume = [];\n      this.sinkIdMap = new aa();\n      this.autoResumeAudioElement();\n    }\n\n    setSinkID(a, b) {\n      var _this18 = this;\n\n      return _asyncToGenerator(function* () {\n        const c = _this18.elementMap.get(a);\n\n        if (_this18.sinkIdMap.set(a, b), c) try {\n          yield c.setSinkId(b);\n        } catch (e) {\n          throw new n(l.PERMISSION_DENIED, \"can not set sink id: \" + e.toString());\n        }\n      })();\n    }\n\n    play(a, b, c) {\n      if (!this.elementMap.has(b)) {\n        var e = document.createElement(\"audio\");\n        e.autoplay = !0;\n        e.srcObject = new MediaStream([a]);\n        this.elementMap.set(b, e);\n        this.setVolume(b, c);\n        (a = this.sinkIdMap.get(b)) && e.setSinkId(a).catch(a => {\n          k.warning(\"[\".concat(b, \"] set sink id failed\"), a.toString());\n        });\n        (a = e.play()) && a.then && a.catch(a => {\n          k.warning(\"audio element play warning\", a.toString());\n          this.elementMap.has(b) && \"NotAllowedError\" === a.name && (k.warning(\"detected audio element autoplay failed\"), this.elementsNeedToResume.push(e), Za(() => {\n            this.onAutoplayFailed && this.onAutoplayFailed();\n          }));\n        });\n      }\n    }\n\n    updateTrack(a, b) {\n      (a = this.elementMap.get(a)) && (a.srcObject = new MediaStream([b]));\n    }\n\n    isPlaying(a) {\n      return this.elementMap.has(a);\n    }\n\n    setVolume(a, b) {\n      (a = this.elementMap.get(a)) && (b = Math.max(0, Math.min(100, b)), a.volume = b / 100);\n    }\n\n    stop(a) {\n      var b, c;\n      const e = this.elementMap.get(a);\n\n      if (this.sinkIdMap.delete(a), e) {\n        var g = J(b = this.elementsNeedToResume).call(b, e);\n        Ia(c = this.elementsNeedToResume).call(c, g, 1);\n        e.srcObject = null;\n        e.remove();\n        this.elementMap.delete(a);\n      }\n    }\n\n    autoResumeAudioElement() {\n      const a = () => {\n        var a;\n        q(a = this.elementsNeedToResume).call(a, a => {\n          a.play().then(a => {\n            k.debug(\"Auto resume audio element success\");\n          }).catch(a => {\n            k.warning(\"Auto resume audio element failed!\", a);\n          });\n        });\n        this.elementsNeedToResume = [];\n      };\n\n      new A(a => {\n        document.body ? a() : window.addEventListener(\"load\", () => a());\n      }).then(() => {\n        document.body.addEventListener(\"touchstart\", a, !0);\n        document.body.addEventListener(\"mousedown\", a, !0);\n      });\n    }\n\n  }();\n\n  class Ya extends ne {\n    constructor(a, b, c) {\n      super(a, c);\n      this.trackMediaType = \"audio\";\n      this._enabled = !0;\n      this._volume = 100;\n      this._useAudioElement = !0;\n      this._encoderConfig = b;\n      this._source = new Dk(a);\n    }\n\n    get isPlaying() {\n      return this._useAudioElement ? db.isPlaying(this.getTrackId()) : this._source.isPlayed;\n    }\n\n    setVolume(a) {\n      W(a, \"volume\", 0, 1E3);\n      let b = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.LOCAL_AUDIO_TRACK_SET_VOLUME,\n        options: [this.getTrackId(), a]\n      }, 300);\n      this._volume = a;\n\n      this._source.setVolume(a / 100);\n\n      this._useAudioElement && db.setVolume(this.getTrackId(), a);\n\n      try {\n        let a = this._source.createOutputTrack();\n\n        this._mediaStreamTrack !== a && (this._mediaStreamTrack = a, Pa(this, M.NEED_REPLACE_TRACK, this._mediaStreamTrack).then(() => {\n          k.debug(\"[\".concat(this.getTrackId(), \"] replace web audio track success\"));\n        }).catch(a => {\n          k.warning(\"[\".concat(this.getTrackId(), \"] replace web audio track failed\"), a);\n        }));\n      } catch (c) {}\n\n      b.onSuccess();\n    }\n\n    getVolumeLevel() {\n      return this._source.getAudioLevel();\n    }\n\n    setPlaybackDevice(a) {\n      var _this19 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.REMOTE_AUDIO_SET_OUTPUT_DEVICE,\n          options: [_this19.getTrackId(), a]\n        });\n        if (!_this19._useAudioElement) throw new n(l.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n\n        try {\n          yield db.setSinkID(_this19.getTrackId(), a);\n        } catch (c) {\n          throw b.onError(c), c;\n        }\n\n        b.onSuccess();\n      })();\n    }\n\n    setEnabled(a) {\n      var _this20 = this;\n\n      return _asyncToGenerator(function* () {\n        var b;\n\n        if (a !== _this20._enabled) {\n          k.info(\"[\".concat(_this20.getTrackId(), \"] start setEnabled\"), a);\n          var c = yield _this20._enabledMutex.lock();\n\n          if (!a) {\n            _this20._originMediaStreamTrack.enabled = !1;\n\n            try {\n              yield Pa(_this20, M.NEED_REMOVE_TRACK, _this20);\n            } catch (e) {\n              throw k.error(\"[\".concat(_this20.getTrackId(), \"] setEnabled to false error\"), e.toString()), c(), e;\n            }\n\n            return _this20._enabled = !1, c();\n          }\n\n          _this20._originMediaStreamTrack.enabled = !0;\n\n          try {\n            yield Pa(_this20, M.NEED_ADD_TRACK, _this20);\n          } catch (e) {\n            throw k.error(\"[\".concat(_this20.getTrackId(), \"] setEnabled to true error\"), e.toString()), c(), e;\n          }\n\n          k.info(m(b = \"[\".concat(_this20.getTrackId(), \"] setEnabled to \")).call(b, a, \" success\"));\n          _this20._enabled = !0;\n          c();\n        }\n      })();\n    }\n\n    getStats() {\n      Oc(() => {\n        k.warning(\"[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead\");\n      }, \"localAudioTrackGetStatsWarning\");\n      return Zb(this, M.GET_STATS) || Me({}, ke);\n    }\n\n    setAudioFrameCallback(a, b = 4096) {\n      if (!a) return this._source.removeAllListeners(ib.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n\n      this._source.startGetAudioBuffer(b);\n\n      this._source.removeAllListeners(ib.ON_AUDIO_BUFFER);\n\n      this._source.on(ib.ON_AUDIO_BUFFER, b => a(b));\n    }\n\n    play() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.LOCAL_AUDIO_TRACK_PLAY,\n        options: [this.getTrackId()]\n      });\n      k.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\"));\n      this._useAudioElement ? (k.debug(\"[\".concat(this.getTrackId(), \"] start audio playback in element\")), db.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();\n      a.onSuccess();\n    }\n\n    stop() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.LOCAL_AUDIO_TRACK_STOP,\n        options: [this.getTrackId()]\n      });\n      k.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\"));\n      this._useAudioElement ? db.stop(this.getTrackId()) : this._source.stop();\n      a.onSuccess();\n    }\n\n    close() {\n      super.close();\n\n      this._source.destroy();\n    }\n\n    _updatePlayerSource() {\n      k.debug(\"[track-\".concat(this.getTrackId(), \"] update player source track\"));\n\n      this._source.updateTrack(this._mediaStreamTrack);\n\n      this._useAudioElement && db.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n    }\n\n    _updateOriginMediaStreamTrack(a, b) {\n      var _this21 = this;\n\n      return _asyncToGenerator(function* () {\n        _this21._originMediaStreamTrack !== a && (_this21._originMediaStreamTrack.removeEventListener(\"ended\", _this21._handleTrackEnded), a.addEventListener(\"ended\", _this21._handleTrackEnded), b && _this21._originMediaStreamTrack.stop(), _this21._originMediaStreamTrack = a, _this21._source.updateTrack(_this21._originMediaStreamTrack), _this21._mediaStreamTrack !== _this21._source.outputTrack && (_this21._mediaStreamTrack = _this21._originMediaStreamTrack, _this21._updatePlayerSource(), yield Pa(_this21, M.NEED_REPLACE_TRACK, _this21._mediaStreamTrack)));\n      })();\n    }\n\n  }\n\n  class dg extends Ya {\n    constructor(a, b, c, e) {\n      super(a, b.encoderConfig ? vd(b.encoderConfig) : {}, e);\n      this._deviceName = \"default\";\n      this._enabled = !0;\n      this._config = b;\n      this._constraints = c;\n      this._deviceName = a.label;\n    }\n\n    setDevice(a) {\n      var _this22 = this;\n\n      return _asyncToGenerator(function* () {\n        var b, c;\n        let e = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.MIC_AUDIO_TRACK_SET_DEVICE,\n          options: [_this22.getTrackId(), a]\n        });\n        if (k.info(m(b = \"[\".concat(_this22.getTrackId, \"] start set device to \")).call(b, a)), _this22._enabled) try {\n          let c = yield cb.getDeviceById(a);\n          b = {};\n          b.audio = Me({}, _this22._constraints);\n          b.audio.deviceId = {\n            exact: a\n          };\n\n          _this22._originMediaStreamTrack.stop();\n\n          let e = null;\n\n          try {\n            e = yield xb(b, _this22.getTrackId());\n          } catch (p) {\n            throw k.error(\"[track-\".concat(_this22.getTrackId(), \"] setDevice failed\"), p.toString()), e = yield xb({\n              video: _this22._constraints\n            }, _this22.getTrackId()), yield _this22._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !1), p;\n          }\n\n          yield _this22._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !1);\n          _this22._deviceName = c.label;\n          _this22._config.microphoneId = a;\n          _this22._constraints.deviceId = {\n            exact: a\n          };\n        } catch (g) {\n          throw e.onError(g), k.error(\"[track-\".concat(_this22.getTrackId(), \"] setDevice error\"), g.toString()), g;\n        } else try {\n          _this22._deviceName = (yield cb.getDeviceById(a)).label, _this22._config.microphoneId = a, _this22._constraints.deviceId = {\n            exact: a\n          };\n        } catch (g) {\n          throw e.onError(g), k.error(\"[track-\".concat(_this22.getTrackId(), \"] setDevice error\"), g.toString()), g;\n        }\n        e.onSuccess();\n        k.info(m(c = \"[\".concat(_this22.getTrackId, \"] set device to \")).call(c, a, \" success\"));\n      })();\n    }\n\n    setEnabled(a, b) {\n      var _superprop_getSetEnabled = () => super.setEnabled,\n          _this23 = this;\n\n      return _asyncToGenerator(function* () {\n        if (b) return k.debug(\"[\".concat(_this23.getTrackId, \"] setEnabled false (do not close microphone)\")), yield _superprop_getSetEnabled().call(_this23, a);\n\n        if (a !== _this23._enabled) {\n          k.info(\"[\".concat(_this23.getTrackId(), \"] start setEnabled\"), a);\n          b = yield _this23._enabledMutex.lock();\n\n          if (!a) {\n            _this23._originMediaStreamTrack.onended = null;\n\n            _this23._originMediaStreamTrack.stop();\n\n            _this23._enabled = !1;\n\n            try {\n              yield Pa(_this23, M.NEED_REMOVE_TRACK, _this23);\n            } catch (e) {\n              throw k.error(\"[\".concat(_this23.getTrackId(), \"] setEnabled false failed\"), e.toString()), b(), e;\n            }\n\n            return void b();\n          }\n\n          a = Me({}, _this23._constraints);\n          var c = cb.searchDeviceIdByName(_this23._deviceName);\n          c && !a.deviceId && (a.deviceId = c);\n\n          try {\n            let a = yield xb({\n              audio: _this23._constraints\n            }, _this23.getTrackId());\n            yield _this23._updateOriginMediaStreamTrack(a.getAudioTracks()[0], !1);\n            yield Pa(_this23, M.NEED_ADD_TRACK, _this23);\n          } catch (e) {\n            throw b(), k.error(\"[\".concat(_this23.getTrackId(), \"] setEnabled true failed\"), e.toString()), e;\n          }\n\n          _this23._enabled = !0;\n          k.info(\"[\".concat(_this23.getTrackId(), \"] setEnabled success\"));\n          b();\n        }\n      })();\n    }\n\n  }\n\n  class no extends Ya {\n    constructor(a, b, c, e) {\n      super(b.createOutputTrack(), c, e);\n      this.source = a;\n      this._bufferSource = b;\n\n      this._bufferSource.on(ib.AUDIO_SOURCE_STATE_CHANGE, a => {\n        this.emit(fd.SOURCE_STATE_CHANGE, a);\n      });\n\n      try {\n        this._mediaStreamTrack = this._source.createOutputTrack();\n      } catch (g) {}\n    }\n\n    get currentState() {\n      return this._bufferSource.currentState;\n    }\n\n    get duration() {\n      return this._bufferSource.duration;\n    }\n\n    getCurrentTime() {\n      return this._bufferSource.currentTime;\n    }\n\n    startProcessAudioBuffer(a) {\n      let b = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.BUFFER_AUDIO_TRACK_START,\n        options: [this.getTrackId(), a, this.duration]\n      });\n      a && this._bufferSource.updateOptions(a);\n\n      this._bufferSource.startProcessAudioBuffer();\n\n      b.onSuccess();\n    }\n\n    pauseProcessAudioBuffer() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.BUFFER_AUDIO_TRACK_PAUSE,\n        options: [this.getTrackId()]\n      });\n\n      this._bufferSource.pauseProcessAudioBuffer();\n\n      a.onSuccess();\n    }\n\n    seekAudioBuffer(a) {\n      let b = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.BUFFER_AUDIO_TRACK_SEEK,\n        options: [this.getTrackId()]\n      });\n\n      this._bufferSource.seekAudioBuffer(a);\n\n      b.onSuccess();\n    }\n\n    resumeProcessAudioBuffer() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.BUFFER_AUDIO_TRACK_RESUME,\n        options: [this.getTrackId()]\n      });\n\n      this._bufferSource.resumeProcessAudioBuffer();\n\n      a.onSuccess();\n    }\n\n    stopProcessAudioBuffer() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.BUFFER_AUDIO_TRACK_STOP,\n        options: [this.getTrackId()]\n      });\n\n      this._bufferSource.stopProcessAudioBuffer();\n\n      a.onSuccess();\n    }\n\n  }\n\n  class Fc extends Ya {\n    constructor() {\n      let a = Qc().createMediaStreamDestination();\n      super(a.stream.getAudioTracks()[0]);\n\n      try {\n        this._mediaStreamTrack = this._source.createOutputTrack();\n      } catch (b) {}\n\n      this.destNode = a;\n      this.trackList = [];\n    }\n\n    hasAudioTrack(a) {\n      var b;\n      return -1 !== J(b = this.trackList).call(b, a);\n    }\n\n    addAudioTrack(a) {\n      var b;\n      -1 === J(b = this.trackList).call(b, a) ? (k.debug(\"add \".concat(a.getTrackId(), \" to mixing track\")), a._source.outputNode.connect(this.destNode), this.trackList.push(a), this.updateEncoderConfig()) : k.warning(\"track is already added\");\n    }\n\n    removeAudioTrack(a) {\n      var b;\n\n      if (-1 !== J(b = this.trackList).call(b, a)) {\n        k.debug(\"remove \".concat(a.getTrackId(), \" from mixing track\"));\n\n        try {\n          a._source.outputNode.disconnect(this.destNode);\n        } catch (c) {}\n\n        Nc(this.trackList, a);\n        this.updateEncoderConfig();\n      }\n    }\n\n    updateEncoderConfig() {\n      var a;\n      let b = {};\n      q(a = this.trackList).call(a, a => {\n        a._encoderConfig && ((a._encoderConfig.bitrate || 0) > (b.bitrate || 0) && (b.bitrate = a._encoderConfig.bitrate), (a._encoderConfig.sampleRate || 0) > (b.sampleRate || 0) && (b.sampleRate = a._encoderConfig.sampleRate), (a._encoderConfig.sampleSize || 0) > (b.sampleSize || 0) && (b.sampleSize = a._encoderConfig.sampleSize), a._encoderConfig.stereo && (b.stereo = !0));\n      });\n      this._encoderConfig = b;\n    }\n\n  }\n\n  let eg = new aa();\n\n  class oo extends Sa {\n    constructor(a) {\n      super();\n      this.inChannelInfo = {\n        joinAt: null,\n        duration: 0\n      };\n      this._state = \"DISCONNECTED\";\n      this.needToSendUnpubUnsub = new aa();\n      this.hasChangeBGPAddress = this.isSignalRecover = !1;\n      this.joinGatewayStartTime = 0;\n      this._signalTimeout = !1;\n      this.clientId = a.clientId;\n      this.spec = a;\n      this.signal = new mo(Ne({}, a, {\n        retryConfig: a.websocketRetryConfig\n      }));\n      this._statsCollector = a.statsCollector;\n      this.role = a.role || \"audience\";\n      this._clientRoleOptions = a.clientRoleOptions;\n      this.handleSignalEvents();\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    set state(a) {\n      if (a !== this._state) {\n        var b = this._state;\n        this._state = a;\n        \"DISCONNECTED\" === a && this._disconnectedReason ? this.emit(xa.CONNECTION_STATE_CHANGE, a, b, this._disconnectedReason) : this.emit(xa.CONNECTION_STATE_CHANGE, a, b);\n      }\n    }\n\n    join(a, b) {\n      var _this24 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e;\n        \"disabled\" !== a.cloudProxyServer && (_this24.hasChangeBGPAddress = !0);\n        let g = x();\n        var h = eg.get(a.cname);\n        if (h || (h = new aa(), eg.set(a.cname, h)), h.has(a.uid)) throw h = new n(l.UID_CONFLICT), u.joinGateway(a.sid, {\n          lts: g,\n          succ: !1,\n          ec: h.message,\n          addr: null,\n          uid: a.uid,\n          cid: a.cid\n        }), h;\n        h.set(a.uid, !0);\n        _this24.joinInfo = a;\n        _this24.key = b;\n        b = a.proxyServer ? E(c = a.gatewayAddrs).call(c, b => {\n          var c, e;\n          b = b.split(\":\");\n          return m(c = m(e = \"wss://\".concat(a.proxyServer, \"/ws/?h=\")).call(e, b[0], \"&p=\")).call(c, b[1]);\n        }) : E(e = a.gatewayAddrs).call(e, a => \"wss://\".concat(a));\n        c = 0;\n        _this24.joinGatewayStartTime = g;\n\n        try {\n          c = (yield _this24.signal.init(b)).uid;\n        } catch (p) {\n          throw k.error(\"[\".concat(_this24.clientId, \"] User join failed\"), p.toString()), u.joinGateway(a.sid, {\n            lts: g,\n            succ: !1,\n            ec: p.message,\n            addr: _this24.signal.url,\n            uid: a.uid,\n            cid: a.cid\n          }), h.delete(a.uid), _this24.signal.close(), p;\n        }\n\n        return _this24.state = \"CONNECTED\", _this24.inChannelInfo.joinAt = x(), k.debug(\"[\".concat(_this24.clientId, \"] Connected to gateway server\")), _this24.trafficStatsInterval = window.setInterval(() => {\n          _this24.updateTrafficStats().catch(a => {\n            k.warning(\"[\".concat(_this24.clientId, \"] get traffic stats error\"), a.toString());\n          });\n        }, 3E3), _this24.networkQualityInterval = window.setInterval(() => {\n          navigator && void 0 !== navigator.onLine && !navigator.onLine ? _this24.emit(xa.NETWORK_QUALITY, {\n            downlinkNetworkQuality: 6,\n            uplinkNetworkQuality: 6\n          }) : _this24._signalTimeout ? _this24.emit(xa.NETWORK_QUALITY, {\n            downlinkNetworkQuality: 5,\n            uplinkNetworkQuality: 5\n          }) : \"CONNECTED\" === _this24.state && _this24._statsCollector.trafficStats ? _this24.emit(xa.NETWORK_QUALITY, {\n            uplinkNetworkQuality: nh(_this24._statsCollector.trafficStats.B_unq),\n            downlinkNetworkQuality: nh(_this24._statsCollector.trafficStats.B_dnq)\n          }) : _this24.emit(xa.NETWORK_QUALITY, {\n            uplinkNetworkQuality: 0,\n            downlinkNetworkQuality: 0\n          });\n        }, 2E3), c;\n      })();\n    }\n\n    leave(a = !1) {\n      var _this25 = this;\n\n      return _asyncToGenerator(function* () {\n        if (\"DISCONNECTED\" !== _this25.state) {\n          _this25.state = \"DISCONNECTING\";\n\n          try {\n            if (!a && _this25.signal.connectionState === ta.CONNECTED) {\n              var b = _this25.signal.request(da.LEAVE, void 0, !0);\n\n              yield 3E3 === 1 / 0 ? b : A.race([b, nl(3E3)]);\n            }\n          } catch (c) {\n            k.warning(\"[\".concat(_this25.clientId, \"] leave request failed, ignore\"), c);\n          }\n\n          _this25.signal.close();\n\n          _this25.reset();\n\n          _this25.state = \"DISCONNECTED\";\n        }\n      })();\n    }\n\n    publish(a, b) {\n      var _this26 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this26.joinInfo) throw new n(l.UNEXPECTED_ERROR, \"publish no joinInfo\");\n        let c = a.getUserId(),\n            e = a.videoTrack ? function (a) {\n          var b;\n          a = a._encoderConfig;\n          if (!a) return {};\n          const c = {\n            resolution: a.width && a.height ? m(b = \"\".concat(Qb(a.width), \"x\")).call(b, Qb(a.height)) : void 0,\n            maxVideoBW: a.bitrateMax,\n            minVideoBW: a.bitrateMin\n          };\n          return \"number\" == typeof a.frameRate ? (c.maxFrameRate = a.frameRate, c.minFrameRate = a.frameRate) : a.frameRate && (c.maxFrameRate = a.frameRate.max || a.frameRate.ideal || a.frameRate.exact || a.frameRate.min, c.minFrameRate = a.frameRate.min || a.frameRate.ideal || a.frameRate.exact || a.frameRate.max), c;\n        }(a.videoTrack) : {};\n\n        if (a.on(H.NEED_ANSWER, (g, h, p) => {\n          var r;\n          let t = {\n            state: \"offer\",\n            stream_type: b,\n            p2p_id: a.pc.ID,\n            sdp: w(g),\n            audio: !!a.audioTrack,\n            video: !!a.videoTrack,\n            screen: a.videoTrack && -1 !== J(r = a.videoTrack._hints).call(r, rb.SCREEN_TRACK),\n            attributes: e,\n            dtx: a.audioTrack instanceof dg && a.audioTrack._config.DTX,\n            hq: !1,\n            lq: !1,\n            stereo: !1,\n            speech: !1,\n            mode: _this26.spec.mode,\n            codec: _this26.spec.codec,\n            extend: v.PUB_EXTEND\n          };\n\n          _this26.signal.request(da.PUBLISH, t, !0).then(a => {\n            c && _this26.needToSendUnpubUnsub.set(c, !0);\n            h(JSON.parse(a.sdp));\n          }).catch(b => {\n            if (g.retry && b.data && b.data.code === F.ERR_PUBLISH_REQUEST_INVALID) return k.warning(\"[\".concat(_this26.clientId, \"] receiver publish error code, retry\"), b.toString()), La(a, H.NEED_UNPUB).then(() => {\n              g.retry = !1;\n              La(a, H.NEED_ANSWER, g).then(h).catch(p);\n            });\n            b.code !== l.WS_ABORT && p(b);\n          });\n        }), a.on(H.NEED_RENEGOTIATE, (c, e, p) => {\n          _this26.signal.request(da.PUBLISH, {\n            state: \"negotiation\",\n            stream_type: b,\n            p2p_id: a.pc.ID,\n            sdp: c\n          }, !0).then(a => {\n            e(JSON.parse(a.sdp));\n          }).catch(a => {\n            a.code !== l.WS_ABORT && p(a);\n          });\n        }), a.on(H.NEED_UNPUB, e => c && !_this26.needToSendUnpubUnsub.has(c) ? e(!1) : \"RECONNECTING\" === _this26.state ? e(!0) : void _this26.signal.request(da.UNPUBLISH, {\n          stream_id: a.getUserId(),\n          stream_type: b\n        }, !0).then(() => e(!1)).catch(a => {\n          k.warning(\"unpublish warning: \", a);\n          e(!0);\n        })), a.on(H.NEED_UPLOAD, (a, c) => {\n          _this26.signal.upload(a, {\n            stream_type: b,\n            stats: c\n          });\n        }), a.on(H.NEED_SIGNAL_RTT, a => {\n          a(_this26.signal.rtt);\n        }), \"RECONNECTING\" !== _this26.state) {\n          if (\"CONNECTED\" !== _this26.state) return new n(l.INVALID_OPERATION, \"can not publish when connection state is \".concat(_this26.state)).throw();\n          yield a.startP2PConnection();\n        } else a.readyToReconnectPC();\n      })();\n    }\n\n    subscribe(a) {\n      var _this27 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this27.joinInfo) throw new n(l.UNEXPECTED_ERROR, \"subscribe no joinInfo\");\n        let b = a.getUserId();\n\n        if (a.on(H.NEED_ANSWER, (c, e, g) => {\n          var h = a.subscribeOptions;\n          h = {\n            stream_id: a.getUserId(),\n            audio: !!h.audio,\n            video: !!h.video,\n            mode: _this27.spec.mode,\n            codec: _this27.spec.codec,\n            p2p_id: a.pc.ID,\n            sdp: w(c),\n            tcc: !!v.SUBSCRIBE_TCC,\n            extend: v.SUB_EXTEND\n          };\n\n          _this27.signal.request(da.SUBSCRIBE, h, !0).then(a => {\n            _this27.needToSendUnpubUnsub.set(b, !0);\n\n            e(JSON.parse(a.sdp));\n          }).catch(b => {\n            if (c.retry && b.data && b.data.code === F.ERR_SUBSCRIBE_REQUEST_INVALID) return k.warning(\"[\".concat(_this27.clientId, \"] receiver subscribe error code, retry\"), b.toString()), La(a, H.NEED_UNSUB).then(() => {\n              c.retry = !1;\n              La(a, H.NEED_ANSWER, c).then(e).catch(g);\n            });\n            b.code !== l.WS_ABORT && g(b);\n          });\n        }), a.on(H.NEED_UNSUB, c => _this27.needToSendUnpubUnsub.has(b) ? \"RECONNECTING\" === _this27.state ? c(!0) : void _this27.signal.request(da.UNSUBSCRIBE, {\n          stream_id: a.getUserId()\n        }, !0).then(() => c(!1)).catch(a => {\n          k.warning(\"unsubscribe warning\", a);\n          c(!0);\n        }) : c(!1)), a.on(H.NEED_UPLOAD, (b, e) => {\n          _this27.signal.upload(b, {\n            stream_id: a.getUserId(),\n            stats: e\n          });\n        }), a.on(H.NEED_SIGNAL_RTT, a => {\n          a(_this27.signal.rtt);\n        }), \"RECONNECTING\" !== _this27.state) {\n          if (\"CONNECTED\" !== _this27.state) return new n(l.INVALID_OPERATION, \"can not subscribe when connection state is \".concat(_this27.state)).throw();\n          yield a.startP2PConnection();\n        } else a.readyToReconnectPC();\n      })();\n    }\n\n    subscribeChange(a, b) {\n      var _this28 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e;\n        if (!_this28.joinInfo) throw new n(l.UNEXPECTED_ERROR, \"subscribe no joinInfo\");\n\n        if (yield a.setSubscribeOptions(b), \"RECONNECTING\" !== _this28.state) {\n          if (\"CONNECTED\" !== _this28.state) return new n(l.INVALID_OPERATION, \"can not subscribe change when connection state is \".concat(_this28.state)).throw();\n          k.debug(m(c = m(e = \"[\".concat(_this28.clientId, \"] send subscribe change, audio: \")).call(e, b.audio, \", video: \")).call(c, b.video));\n          yield _this28.signal.request(da.SUBSCRIBE_CHANGE, {\n            stream_id: a.getUserId(),\n            audio: !!b.audio,\n            video: !!b.video\n          }, !0);\n        }\n      })();\n    }\n\n    unsubscribe(a) {\n      return _asyncToGenerator(function* () {\n        yield a.closeP2PConnection();\n      })();\n    }\n\n    getGatewayInfo() {\n      return this.signal.request(da.GATEWAY_INFO);\n    }\n\n    renewToken(a) {\n      return this.signal.request(da.RENEW_TOKEN, {\n        token: a\n      });\n    }\n\n    setClientRole(a, b) {\n      var _this29 = this;\n\n      return _asyncToGenerator(function* () {\n        if (b && (_this29._clientRoleOptions = Ga({}, b)), \"CONNECTED\" !== _this29.state) return void (_this29.role = a);\n        yield _this29.signal.request(da.SET_CLIENT_ROLE, {\n          role: a,\n          level: \"audience\" === a ? _this29._clientRoleOptions && _this29._clientRoleOptions.level ? _this29._clientRoleOptions.level : 2 : 0\n        });\n        _this29.role = a;\n      })();\n    }\n\n    setRemoteVideoStreamType(a, b) {\n      var _this30 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this30.signal.request(da.SWITCH_VIDEO_STREAM, {\n          stream_id: a,\n          stream_type: b\n        });\n      })();\n    }\n\n    setStreamFallbackOption(a, b) {\n      var _this31 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this31.signal.request(da.SET_FALLBACK_OPTION, {\n          stream_id: a,\n          fallback_type: b\n        });\n      })();\n    }\n\n    pickSVCLayer(a, b) {\n      var _this32 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this32.signal.request(da.PICK_SVC_LAYER, {\n          stream_id: a,\n          spatial_layer: b.spatialLayer,\n          temporal_layer: b.temporalLayer\n        });\n      })();\n    }\n\n    getInChannelInfo() {\n      return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = x() - this.inChannelInfo.joinAt), Ne({}, this.inChannelInfo);\n    }\n\n    getGatewayVersion() {\n      var _this33 = this;\n\n      return _asyncToGenerator(function* () {\n        return (yield _this33.signal.request(da.GATEWAY_INFO)).version;\n      })();\n    }\n\n    reset() {\n      if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = x() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {\n        let a = eg.get(this.joinInfo.cname);\n        a && a.delete(this.joinInfo.uid);\n      }\n\n      this.needToSendUnpubUnsub = new aa();\n      this.key = this.joinInfo = void 0;\n      this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);\n    }\n\n    updateTurnConfigFromSignal() {\n      if (this.joinInfo) {\n        var a = (a = ((\"disabled\" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex]) || \"\").match(/(wss:\\/\\/)?([^:]+):(\\d+)/)) ? {\n          username: $a.username,\n          password: $a.password,\n          turnServerURL: a[2],\n          tcpport: pa(a[3]) + 30,\n          udpport: pa(a[3]) + 30,\n          forceturn: !1\n        } : null;\n        this.joinInfo.turnServer.serversFromGateway = [];\n        a && \"off\" !== this.joinInfo.turnServer.mode && \"disabled\" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(Ne({}, $a, {\n          turnServerURL: a.turnServerURL,\n          tcpport: a.tcpport,\n          udpport: a.udpport,\n          username: this.joinInfo.uid.toString(),\n          password: this.joinInfo.token\n        }));\n      }\n    }\n\n    updateTrafficStats() {\n      var _this34 = this;\n\n      return _asyncToGenerator(function* () {\n        var a;\n\n        if (\"CONNECTED\" === _this34.state) {\n          var b = yield _this34.signal.request(da.TRAFFIC_STATS, void 0, !0);\n          b.timestamp = x();\n          q(a = b.peer_delay).call(a, a => {\n            var b;\n            let c = _this34._statsCollector.trafficStats && R(b = _this34._statsCollector.trafficStats.peer_delay).call(b, b => b.peer_uid === a.peer_uid);\n            c && c.B_st !== a.B_st && Za(() => {\n              _this34.emit(xa.STREAM_TYPE_CHANGE, a.peer_uid, a.B_st);\n            });\n          });\n\n          _this34._statsCollector.updateTrafficStats(b);\n        }\n      })();\n    }\n\n    getJoinMessage() {\n      if (!this.joinInfo || !this.key) throw new n(l.UNEXPECTED_ERROR, \"can not generate join message, no join info\");\n      let a = Ga({}, this.joinInfo.apResponse);\n      var b = v.REPORT_APP_SCENARIO;\n      if (\"string\" != typeof b) try {\n        b = w(b);\n      } catch (c) {\n        b = void 0;\n      }\n      b && 128 < b.length && (b = void 0);\n      b = {\n        session_id: this.joinInfo.sid,\n        app_id: this.joinInfo.appId,\n        channel_key: this.key,\n        channel_name: this.joinInfo.cname,\n        sdk_version: Ta,\n        browser: navigator.userAgent,\n        process_id: v.PROCESS_ID,\n        mode: this.spec.mode,\n        codec: this.spec.codec,\n        role: this.role,\n        has_changed_gateway: this.hasChangeBGPAddress,\n        ap_response: a,\n        extends: v.JOIN_EXTEND,\n        details: {\n          6: this.joinInfo.stringUid\n        },\n        features: {\n          rejoin: !0\n        },\n        optionalInfo: this.joinInfo.optionalInfo,\n        appScenario: b\n      };\n      return this.joinInfo.stringUid && (b.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (b.aes_mode = this.joinInfo.aesmode, v.ENCRYPT_AES ? (b.aes_secret = this.joinInfo.aespassword, b.aes_encrypt = !0) : b.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (b.aes_salt = this.joinInfo.aessalt)), a.addresses[this.signal.websocket.currentURLIndex] && (b.ap_response.ticket = a.addresses[this.signal.websocket.currentURLIndex].ticket, delete a.addresses), b;\n    }\n\n    getRejoinMessage() {\n      if (!this.joinInfo) throw new n(l.UNEXPECTED_ERROR, \"can not generate rejoin message, no join info\");\n      return {\n        session_id: this.joinInfo.sid,\n        channel_name: this.joinInfo.cname,\n        cid: this.joinInfo.cid,\n        uid: this.joinInfo.uid,\n        vid: Number(this.joinInfo.vid)\n      };\n    }\n\n    handleSignalEvents() {\n      this.signal.on(Q.WS_RECONNECTING, a => {\n        this.joinInfo && u.WebSocketQuit(this.joinInfo.sid, {\n          lts: x(),\n          succ: -1,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          errorCode: a || Ra.NETWORK_ERROR\n        });\n        this.joinInfo && (this.state = \"RECONNECTING\", u.sessionInit(this.joinInfo.sid, {\n          lts: new Date().getTime(),\n          extend: this.isSignalRecover ? {\n            recover: !0\n          } : {\n            rejoin: !0\n          },\n          cname: this.joinInfo.cname,\n          appid: this.joinInfo.appId,\n          mode: this.spec.mode\n        }), this.isSignalRecover = !1, this.joinGatewayStartTime = x());\n      });\n      this.signal.on(Q.WS_CLOSED, a => {\n        let b;\n\n        switch (a) {\n          case \"LEAVE\":\n            b = Ra.LEAVE;\n            break;\n\n          case \"UID_BANNED\":\n          case \"IP_BANNED\":\n          case \"CHANNEL_BANNED\":\n          case \"SERVER_ERROR\":\n            b = Ra.SERVER_ERROR;\n            break;\n\n          default:\n            b = Ra.NETWORK_ERROR;\n        }\n\n        k.debug(\"[signal] websocket closed, reason: \".concat(b || \"undefined -> \" + Ra.NETWORK_ERROR));\n        this.joinInfo && u.WebSocketQuit(this.joinInfo.sid, {\n          lts: x(),\n          succ: \"LEAVE\" === a ? 1 : -1,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          errorCode: b\n        });\n        this.reset();\n        this._disconnectedReason = a;\n        this.state = \"DISCONNECTED\";\n      });\n      this.signal.on(Q.WS_CONNECTED, () => {\n        if (this.updateTurnConfigFromSignal(), this.state = \"CONNECTED\", this.joinInfo) {\n          var a, b;\n          \"audience\" === this.role && this._clientRoleOptions && this._clientRoleOptions.level && (k.debug(m(a = m(b = \"[\".concat(this.clientId, \"] patch to send set client role, role: \")).call(b, this.role, \", type: \")).call(a, this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions));\n          u.joinGateway(this.joinInfo.sid, {\n            lts: this.joinGatewayStartTime,\n            succ: !0,\n            ec: null,\n            vid: this.joinInfo.vid,\n            addr: this.signal.url,\n            uid: this.joinInfo.uid,\n            cid: this.joinInfo.cid\n          });\n        }\n      });\n      this.signal.on(U.ON_UPLINK_STATS, a => {\n        this._statsCollector.updateUplinkStats(a);\n      });\n      this.signal.on(Q.REQUEST_RECOVER, (a, b, c) => {\n        if (!this.joinInfo) return c(new n(l.UNEXPECTED_ERROR, \"gateway: can not recover, no join info\"));\n        a && (this.joinInfo.multiIP = a, this.hasChangeBGPAddress = !0);\n        this.isSignalRecover = !0;\n        La(this, xa.REQUEST_NEW_GATEWAY_LIST).then(b).catch(c);\n      });\n      this.signal.on(Q.REQUEST_JOIN_INFO, a => {\n        a(this.getJoinMessage());\n      });\n      this.signal.on(Q.REQUEST_REJOIN_INFO, a => {\n        a(this.getRejoinMessage());\n      });\n      this.signal.on(Q.REPORT_JOIN_GATEWAY, (a, b) => {\n        this.joinInfo && u.joinGateway(this.joinInfo.sid, {\n          lts: this.joinGatewayStartTime,\n          succ: !1,\n          ec: a,\n          addr: b,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid\n        });\n      });\n      this.signal.on(Q.IS_P2P_DISCONNECTED, a => {\n        a(Mc(this, xa.IS_P2P_DISCONNECTED));\n      });\n      this.signal.on(Q.DISCONNECT_P2P, () => {\n        this.needToSendUnpubUnsub = new aa();\n        this.emit(xa.DISCONNECT_P2P);\n      });\n      this.signal.on(Q.NEED_RENEW_SESSION, () => {\n        this.emit(xa.NEED_RENEW_SESSION);\n      });\n      this.signal.on(Q.REQUEST_SUCCESS, () => {\n        this._signalTimeout = !1;\n      });\n      this.signal.on(Q.REQUEST_TIMEOUT, () => {\n        this._signalTimeout = !0;\n      });\n    }\n\n  }\n\n  let Oe = 1,\n      Re = 1,\n      Qe = () => {\n    const a = v.AREAS;\n    0 === a.length && a.push(\"GLOBAL\");\n    return qd(a).call(a, (a, c, e) => {\n      var b, h, p, k, l;\n      c = \"OVERSEA\" === c ? m(b = m(h = m(p = m(k = m(l = \"\".concat(ya.ASIA, \",\")).call(l, ya.EUROPE, \",\")).call(k, ya.AFRICA, \",\")).call(p, ya.NORTH_AMERICA, \",\")).call(h, ya.SOUTH_AMERICA, \",\")).call(b, ya.OCEANIA) : ya[c];\n      var n;\n      return c ? 0 === e ? c : m(n = \"\".concat(a, \",\")).call(n, c) : a;\n    }, \"\");\n  };\n\n  var oe = {\n    ASIA: [\"CHINA\", \"JAPAN\", \"INDIA\"],\n    EUROPE: [],\n    NORTH_AMERICA: [],\n    SOUTH_AMERICA: [],\n    OCEANIA: [],\n    AFRICA: []\n  };\n\n  let Gc = V(oe),\n      pe = \"CHINA NORTH_AMERICA EUROPE ASIA JAPAN INDIA OCEANIA SOUTH_AMERICA AFRICA\".split(\" \"),\n      po = function (a, b) {\n    var c = [];\n\n    if (ba(a).call(a, \"GLOBAL\")) {\n      c = [\"GLOBAL\", \"OVERSEA\"];\n      const g = V(Tf);\n      if (\"GLOBAL\" === b) throw new n(l.INVALID_PARAMS, \"GLOBAL is an invalid excludedArea value\");\n      if (\"CHINA\" === b) c = [\"OVERSEA\"];else if (e = b, ba(Gc).call(Gc, e)) {\n        a = oe[b] || [];\n        const e = [...c, b, ...a];\n        c = I(g).call(g, a => !ba(e).call(e, a));\n      } else if (function (a) {\n        let b = !1;\n        return q(Gc).call(Gc, c => {\n          var e;\n          ba(e = oe[c]).call(e, a) && (b = !0);\n        }), b;\n      }(b)) {\n        a = function (a) {\n          let b;\n          return q(Gc).call(Gc, c => {\n            var e;\n            ba(e = oe[c]).call(e, a) && (b = c);\n          }), b;\n        }(b);\n\n        const e = [...c, a, b];\n        c = I(g).call(g, a => !ba(e).call(e, a));\n      } else c = a;\n\n      c = function (a) {\n        const b = [];\n        return q(pe).call(pe, c => {\n          ba(a).call(a, c) && b.push(c);\n        }), m(b).call(b, I(a).call(a, a => !ba(pe).call(pe, a)));\n      }(c);\n    } else c = a;\n\n    var e;\n    return c;\n  },\n      qo = new class extends Sa {\n    constructor() {\n      super();\n      this.retryConfig = {\n        timeout: 3E3,\n        timeoutFactor: 1.5,\n        maxRetryCount: 1,\n        maxRetryTimeout: 1E4\n      };\n      this.mutex = new Mb(\"config-distribute\");\n    }\n\n    startGetConfigDistribute(a, b) {\n      this.joinInfo = a;\n      this.cancelToken = b;\n      this.interval && this.stopGetConfigDistribute();\n      this.updateConfigDistribute();\n      this.interval = window.setInterval(() => {\n        this.updateConfigDistribute();\n      }, v.CONFIG_DISTRIBUTE_INTERVAL);\n    }\n\n    stopGetConfigDistribute() {\n      this.interval && clearInterval(this.interval);\n      this.cancelToken = this.joinInfo = this.interval = void 0;\n    }\n\n    awaitConfigDistributeComplete() {\n      var _this35 = this;\n\n      return _asyncToGenerator(function* () {\n        _this35.mutex.isLocked && (yield _this35.mutex.lock())();\n      })();\n    }\n\n    updateConfigDistribute() {\n      var _this36 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this36.joinInfo || !_this36.cancelToken || !_this36.retryConfig) return void k.debug(\"[config-distribute] get config distribute interrupted have no joininfo\");\n        let a;\n        const b = yield _this36.mutex.lock();\n\n        try {\n          a = yield wl(_this36.joinInfo, _this36.cancelToken, _this36.retryConfig), k.debug(\"[config-distribute] get config distribute\", w(a)), a.limit_bitrate && _this36.handleBitrateLimit(a.limit_bitrate), _this36.configs = a;\n        } catch (c) {\n          const a = new n(l.NETWORK_RESPONSE_ERROR, c);\n          k.warning(\"[config-distribute] \".concat(a.toString()));\n        } finally {\n          b();\n        }\n      })();\n    }\n\n    getBitrateLimit() {\n      return this.configs ? this.configs.limit_bitrate : void 0;\n    }\n\n    handleBitrateLimit(a) {\n      a && a.uplink && a.id && void 0 !== a.uplink.max_bitrate && void 0 !== a.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== a.id && this.emit(hd.UPDATE_BITRATE_LIMIT, a) : this.emit(hd.UPDATE_BITRATE_LIMIT, a));\n    }\n\n    getLowStreamConfigDistribute() {\n      return this.configs && this.configs.limit_bitrate && function (a) {\n        for (var b = 1; b < arguments.length; b++) {\n          var c,\n              e = null != arguments[b] ? arguments[b] : {};\n          if (b % 2) q(c = Jh(Object(e), !0)).call(c, function (b) {\n            Na(a, b, e[b]);\n          });else if (fa) Oa(a, fa(e));else {\n            var g;\n            q(g = Jh(Object(e))).call(g, function (b) {\n              Y(a, b, Z(e, b));\n            });\n          }\n        }\n\n        return a;\n      }({}, this.configs.limit_bitrate.low_stream_uplink);\n    }\n\n  }();\n\n  var fg = function () {\n    function a(a) {\n      this.input = [];\n      this.size = a;\n    }\n\n    return a.prototype.add = function (a) {\n      this.input.push(a);\n      this.input.length > this.size && this.input.splice(0, 1);\n    }, a.prototype.diffMean = function () {\n      return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;\n    }, a;\n  }(),\n      Lh = function (a, b) {\n    return (Lh = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (a, b) {\n      a.__proto__ = b;\n    } || function (a, b) {\n      for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n    })(a, b);\n  },\n      gg = function () {\n    return (gg = Object.assign || function (a) {\n      for (var b, c = 1, e = arguments.length; c < e; c++) for (var g in b = arguments[c]) Object.prototype.hasOwnProperty.call(b, g) && (a[g] = b[g]);\n\n      return a;\n    }).apply(this, arguments);\n  },\n      Vb,\n      ld = {\n    timestamp: 0,\n    bitrate: {\n      actualEncoded: 0,\n      transmit: 0\n    },\n    sendPacketLossRate: 0,\n    recvPacketLossRate: 0,\n    videoRecv: [],\n    videoSend: [],\n    audioRecv: [],\n    audioSend: []\n  },\n      Ek = {\n    firsCount: 0,\n    nacksCount: 0,\n    plisCount: 0,\n    framesDecodeCount: 0,\n    framesDecodeInterval: 0,\n    framesDecodeFreezeTime: 0,\n    decodeFrameRate: 0,\n    bytes: 0,\n    packetsLost: 0,\n    packetLostRate: 0,\n    packets: 0,\n    ssrc: 0\n  },\n      Fk = {\n    firsCount: 0,\n    nacksCount: 0,\n    plisCount: 0,\n    frameCount: 0,\n    bytes: 0,\n    packets: 0,\n    packetsLost: 0,\n    packetLostRate: 0,\n    ssrc: 0,\n    rttMs: 0\n  },\n      Gk = {\n    bytes: 0,\n    packets: 0,\n    packetsLost: 0,\n    packetLostRate: 0,\n    ssrc: 0,\n    rttMs: 0\n  },\n      Hk = {\n    jitterBufferMs: 0,\n    jitterMs: 0,\n    bytes: 0,\n    packetsLost: 0,\n    packetLostRate: 0,\n    packets: 0,\n    ssrc: 0,\n    receivedFrames: 0,\n    droppedFrames: 0\n  },\n      hg = function () {\n    function a(a, c) {\n      var b = this;\n      this.videoIsReady = !1;\n      this.stats = fb(ld);\n      this.isFirstAudioDecoded = this.isFirstAudioReceived = this.isFirstVideoDecoded = this.isFirstVideoReceived = !1;\n      this.lossRateWindowStats = [];\n      this.pc = a;\n      this.options = c;\n      this.intervalTimer = window.setInterval(function () {\n        return Te(b, void 0, void 0, function () {\n          return Ue(this, function (a) {\n            return this.updateStats(), [2];\n          });\n        });\n      }, this.options.updateInterval);\n    }\n\n    return a.prototype.getStats = function () {\n      return this.stats;\n    }, a.prototype.setVideoIsReady = function (a) {\n      this.videoIsReady = a;\n    }, a.prototype.setIsFirstAudioDecoded = function (a) {\n      this.isFirstAudioDecoded = a;\n    }, a.prototype.destroy = function () {\n      window.clearInterval(this.intervalTimer);\n    }, a.prototype.calcLossRate = function (a) {\n      var b = this;\n      this.lossRateWindowStats.push(a);\n      this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);\n\n      for (var e = this.lossRateWindowStats.length, g = 0, h = 0, p = 0, k = 0, l = function (c) {\n        a[c].forEach(function (a, r) {\n          if (b.lossRateWindowStats[e - 1][c][r] && b.lossRateWindowStats[0][c][r]) {\n            var l = b.lossRateWindowStats[e - 1][c][r].packets - b.lossRateWindowStats[0][c][r].packets;\n            r = b.lossRateWindowStats[e - 1][c][r].packetsLost - b.lossRateWindowStats[0][c][r].packetsLost;\n            \"videoSend\" === c || \"audioSend\" === c ? (g += l, p += r) : (h += l, k += r);\n            Number.isNaN(l) || Number.isNaN(l) ? a.packetLostRate = 0 : a.packetLostRate = 0 >= l || 0 >= r ? 0 : r / (l + r);\n          }\n        });\n      }, m = 0, n = [\"videoSend\", \"audioSend\", \"videoRecv\", \"audioRecv\"]; m < n.length; m++) l(n[m]);\n\n      a.sendPacketLossRate = 0 >= g || 0 >= p ? 0 : p / (g + p);\n      a.recvPacketLossRate = 0 >= h || 0 >= k ? 0 : k / (h + k);\n    }, a;\n  }(),\n      ro = function (a) {\n    function b() {\n      var b = null !== a && a.apply(this, arguments) || this;\n      return b._stats = ld, b.lastDecodeVideoReceiverStats = new Map(), b;\n    }\n\n    return Se(b, a), b.prototype.updateStats = function () {\n      return Te(this, void 0, void 0, function () {\n        var a, b, g, h;\n        return Ue(this, function (c) {\n          switch (c.label) {\n            case 0:\n              return [4, this._getStats()];\n\n            case 1:\n              return a = c.sent(), b = this.statsResponsesToObjects(a), this._stats = fb(ld), g = b.filter(function (a) {\n                return \"ssrc\" === a.type;\n              }), this.processSSRCStats(g), (h = b.find(function (a) {\n                return \"VideoBwe\" === a.type;\n              })) && this.processBandwidthStats(h), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];\n          }\n        });\n      });\n    }, b.prototype.processBandwidthStats = function (a) {\n      this._stats.bitrate = {\n        actualEncoded: Number(a.googActualEncBitrate),\n        targetEncoded: Number(a.googTargetEncBitrate),\n        retransmit: Number(a.googRetransmitBitrate),\n        transmit: Number(a.googTransmitBitrate)\n      };\n      this._stats.sendBandwidth = Number(a.googAvailableSendBandwidth);\n    }, b.prototype.processSSRCStats = function (a) {\n      var b = this;\n      a.forEach(function (a) {\n        var c = a.id.includes(\"send\");\n\n        switch (a.mediaType + \"_\" + (c ? \"send\" : \"recv\")) {\n          case \"video_send\":\n            c = fb(Fk);\n            c.codec = a.googCodecName;\n            c.adaptionChangeReason = \"none\";\n            a.googCpuLimitedResolution && (c.adaptionChangeReason = \"cpu\");\n            a.googBandwidthLimitedResolution && (c.adaptionChangeReason = \"bandwidth\");\n            c.avgEncodeMs = Number(a.googAvgEncodeMs);\n            c.inputFrame = {\n              width: Number(a.googFrameWidthInput) || Number(a.googFrameWidthSent),\n              height: Number(a.googFrameHeightInput) || Number(a.googFrameHeightSent),\n              frameRate: Number(a.googFrameRateInput)\n            };\n            c.sentFrame = {\n              width: Number(a.googFrameWidthSent),\n              height: Number(a.googFrameHeightSent),\n              frameRate: Number(a.googFrameRateInput)\n            };\n            c.firsCount = Number(a.googFirReceived);\n            c.nacksCount = Number(a.googNacksReceived);\n            c.plisCount = Number(a.googPlisReceived);\n            c.frameCount = Number(a.framesEncoded);\n            c.bytes = Number(a.bytesSent);\n            c.packets = Number(a.packetsSent);\n            c.packetsLost = Number(a.packetsLost);\n            c.ssrc = Number(a.ssrc);\n            c.rttMs = Number(a.googRtt || 0);\n\n            b._stats.videoSend.push(c);\n\n            b._stats.rtt = c.rttMs;\n            break;\n\n          case \"video_recv\":\n            c = fb(Ek);\n            var e = b.lastDecodeVideoReceiverStats.get(Number(a.ssrc));\n\n            if (c.codec = a.googCodecName, c.targetDelayMs = Number(a.googTargetDelayMs), c.renderDelayMs = Number(a.googRenderDelayMs), c.currentDelayMs = Number(a.googCurrentDelayMs), c.minPlayoutDelayMs = Number(a.googMinPlayoutDelayMs), c.decodeMs = Number(a.googDecodeMs), c.maxDecodeMs = Number(a.googMaxDecodeMs), c.receivedFrame = {\n              width: Number(a.googFrameWidthReceived),\n              height: Number(a.googFrameHeightReceived),\n              frameRate: Number(a.googFrameRateReceived)\n            }, c.decodedFrame = {\n              width: Number(a.googFrameWidthReceived),\n              height: Number(a.googFrameHeightReceived),\n              frameRate: Number(a.googFrameRateDecoded)\n            }, c.outputFrame = {\n              width: Number(a.googFrameWidthReceived),\n              height: Number(a.googFrameHeightReceived),\n              frameRate: Number(a.googFrameRateOutput)\n            }, c.jitterBufferMs = Number(a.googJitterBufferMs), c.firsCount = Number(a.googFirsSent), c.nacksCount = Number(a.googNacksSent), c.plisCount = Number(a.googPlisSent), c.framesDecodeCount = Number(a.framesDecoded), c.bytes = Number(a.bytesReceived), c.packets = Number(a.packetsReceived), c.packetsLost = Number(a.packetsLost), c.ssrc = Number(a.ssrc), 0 < c.packets && !b.isFirstVideoReceived && (b.onFirstVideoReceived && b.onFirstVideoReceived(), b.isFirstVideoReceived = !0), 0 < c.framesDecodeCount && !b.isFirstVideoDecoded && (b.onFirstVideoDecoded && b.onFirstVideoDecoded(c.decodedFrame.width, c.decodedFrame.height), b.isFirstVideoDecoded = !0), e) {\n              a = e.stats;\n              var g = Date.now() - e.lts;\n              c.framesDecodeFreezeTime = a.framesDecodeFreezeTime;\n              c.framesDecodeInterval = a.framesDecodeInterval;\n              c.framesDecodeCount > a.framesDecodeCount && b.isFirstVideoDecoded ? (e.lts = Date.now(), c.framesDecodeInterval = g, c.framesDecodeInterval >= b.options.freezeRateLimit && (b.videoIsReady ? c.framesDecodeFreezeTime += c.framesDecodeInterval : b.setVideoIsReady(!0))) : c.framesDecodeCount < e.stats.framesDecodeCount && (c.framesDecodeInterval = 0);\n            }\n\n            b.lastDecodeVideoReceiverStats.set(c.ssrc, {\n              stats: gg({}, c),\n              lts: Date.now()\n            });\n\n            b._stats.videoRecv.push(c);\n\n            break;\n\n          case \"audio_recv\":\n            c = fb(Hk);\n            c.codec = a.googCodecName;\n            c.outputLevel = Math.abs(Number(a.audioOutputLevel)) / 32767;\n            c.decodingCNG = Number(a.googDecodingCNG);\n            c.decodingCTN = Number(a.googDecodingCTN);\n            c.decodingCTSG = Number(a.googDecodingCTSG);\n            c.decodingNormal = Number(a.googDecodingNormal);\n            c.decodingPLC = Number(a.googDecodingPLC);\n            c.decodingPLCCNG = Number(a.googDecodingPLCCNG);\n            c.expandRate = Number(a.googExpandRate);\n            c.accelerateRate = Number(a.googAccelerateRate);\n            c.preemptiveExpandRate = Number(a.googPreemptiveExpandRate);\n            c.secondaryDecodedRate = Number(a.googSecondaryDecodedRate);\n            c.speechExpandRate = Number(a.googSpeechExpandRate);\n            c.preferredJitterBufferMs = Number(a.googPreferredJitterBufferMs);\n            c.jitterBufferMs = Number(a.googJitterBufferMs);\n            c.jitterMs = Number(a.googJitterReceived);\n            c.bytes = Number(a.bytesReceived);\n            c.packets = Number(a.packetsReceived);\n            c.packetsLost = Number(a.packetsLost);\n            c.ssrc = Number(a.ssrc);\n            c.receivedFrames = Number(a.googDecodingCTN) || Number(a.packetsReceived);\n            c.droppedFrames = Number(a.googDecodingPLC) + Number(a.googDecodingPLCCNG) || Number(a.packetsLost);\n            0 < c.receivedFrames && !b.isFirstAudioReceived && (b.onFirstAudioReceived && b.onFirstAudioReceived(), b.isFirstAudioReceived = !0);\n            0 < c.decodingNormal && !b.isFirstAudioDecoded && (b.onFirstAudioDecoded && b.onFirstAudioDecoded(), b.isFirstAudioDecoded = !0);\n\n            b._stats.audioRecv.push(c);\n\n            break;\n\n          case \"audio_send\":\n            c = fb(Gk), c.codec = a.googCodecName, c.inputLevel = Math.abs(Number(a.audioInputLevel)) / 32767, c.aecReturnLoss = Number(a.googEchoCancellationReturnLoss || 0), c.aecReturnLossEnhancement = Number(a.googEchoCancellationReturnLossEnhancement || 0), c.residualEchoLikelihood = Number(a.googResidualEchoLikelihood || 0), c.residualEchoLikelihoodRecentMax = Number(a.googResidualEchoLikelihoodRecentMax || 0), c.bytes = Number(a.bytesSent), c.packets = Number(a.packetsSent), c.packetsLost = Number(a.packetsLost), c.ssrc = Number(a.ssrc), c.rttMs = Number(a.googRtt || 0), b._stats.rtt = c.rttMs, b._stats.audioSend.push(c);\n        }\n      });\n    }, b.prototype._getStats = function () {\n      var a = this;\n      return new Promise(function (b, c) {\n        a.pc.getStats(b, c);\n      });\n    }, b.prototype.statsResponsesToObjects = function (a) {\n      var b = [];\n      return a.result().forEach(function (a) {\n        var c = {\n          id: a.id,\n          timestamp: a.timestamp.valueOf().toString(),\n          type: a.type\n        };\n        a.names().forEach(function (b) {\n          c[b] = a.stat(b);\n        });\n        b.push(c);\n      }), b;\n    }, b;\n  }(hg);\n\n  !function (a) {\n    a.CERTIFICATE = \"certificate\";\n    a.CODEC = \"codec\";\n    a.CANDIDATE_PAIR = \"candidate-pair\";\n    a.LOCAL_CANDIDATE = \"local-candidate\";\n    a.REMOTE_CANDIDATE = \"remote-candidate\";\n    a.INBOUND = \"inbound-rtp\";\n    a.TRACK = \"track\";\n    a.OUTBOUND = \"outbound-rtp\";\n    a.PC = \"peer-connection\";\n    a.REMOTE_INBOUND = \"remote-inbound-rtp\";\n    a.REMOTE_OUTBOUND = \"remote-outbound-rtp\";\n    a.TRANSPORT = \"transport\";\n    a.CSRC = \"csrc\";\n    a.DATA_CHANNEL = \"data-channel\";\n    a.STREAM = \"stream\";\n    a.SENDER = \"sender\";\n    a.RECEIVER = \"receiver\";\n  }(Vb || (Vb = {}));\n\n  var Ik = function (a) {\n    function b() {\n      var b = null !== a && a.apply(this, arguments) || this;\n      return b._stats = ld, b.lastDecodeVideoReceiverStats = new Map(), b.lastVideoFramesRecv = new Map(), b.lastVideoFramesSent = new Map(), b.lastVideoFramesDecode = new Map(), b.lastVideoJBDelay = new Map(), b.lastAudioJBDelay = new Map(), b.mediaBytesSent = new Map(), b.mediaBytesRetransmit = new Map(), b.mediaBytesTargetEncode = new Map(), b.lastEncoderMs = new Map(), b;\n    }\n\n    return Se(b, a), b.prototype.updateStats = function () {\n      return Te(this, void 0, void 0, function () {\n        var a,\n            b = this;\n        return Ue(this, function (c) {\n          switch (c.label) {\n            case 0:\n              return a = this, [4, this.pc.getStats()];\n\n            case 1:\n              return a.report = c.sent(), this._stats = fb(ld), this.report.forEach(function (a) {\n                switch (a.type) {\n                  case Vb.OUTBOUND:\n                    \"audio\" === a.mediaType ? b.processAudioOutboundStats(a) : \"video\" === a.mediaType && b.processVideoOutboundStats(a);\n                    break;\n\n                  case Vb.INBOUND:\n                    \"audio\" === a.mediaType ? b.processAudioInboundStats(a) : \"video\" === a.mediaType && b.processVideoInboundStats(a);\n                    break;\n\n                  case Vb.TRANSPORT:\n                    (a = b.report.get(a.selectedCandidatePairId)) && b.processCandidatePairStats(a);\n                    break;\n\n                  case Vb.CANDIDATE_PAIR:\n                    a.selected && b.processCandidatePairStats(a);\n                }\n              }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];\n          }\n        });\n      });\n    }, b.prototype.processCandidatePairStats = function (a) {\n      this._stats.sendBandwidth = a.availableOutgoingBitrate || 0;\n      a.currentRoundTripTime && (this._stats.rtt = 1E3 * a.currentRoundTripTime);\n\n      this._stats.videoSend.forEach(function (b) {\n        !b.rttMs && a.currentRoundTripTime && (b.rttMs = 1E3 * a.currentRoundTripTime);\n      });\n\n      this._stats.audioSend.forEach(function (b) {\n        !b.rttMs && a.currentRoundTripTime && (b.rttMs = 1E3 * a.currentRoundTripTime);\n      });\n    }, b.prototype.processAudioInboundStats = function (a) {\n      var b = this._stats.audioRecv.find(function (b) {\n        return b.ssrc === a.ssrc;\n      });\n\n      b || (b = fb(Hk), this._stats.audioRecv.push(b));\n      b.ssrc = a.ssrc;\n      b.packets = a.packetsReceived;\n      b.packetsLost = a.packetsLost;\n      b.bytes = a.bytesReceived;\n      b.jitterMs = 1E3 * a.jitter;\n      a.trackId && this.processAudioTrackReceiverStats(a.trackId, b);\n      a.codecId && (b.codec = this.getCodecFromCodecStats(a.codecId));\n      b.receivedFrames || (b.receivedFrames = a.packetsReceived);\n      b.droppedFrames || (b.droppedFrames = a.packetsLost);\n      0 < b.receivedFrames && !this.isFirstAudioReceived && (this.onFirstAudioReceived && this.onFirstAudioReceived(), this.isFirstAudioReceived = !0);\n      b.outputLevel && 0 < b.outputLevel && !this.isFirstAudioDecoded && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(), this.isFirstAudioDecoded = !0);\n    }, b.prototype.processVideoInboundStats = function (a) {\n      var b = this._stats.videoRecv.find(function (b) {\n        return b.ssrc === a.ssrc;\n      });\n\n      b || (b = fb(Ek), this._stats.videoRecv.push(b));\n      b.ssrc = a.ssrc;\n      b.packets = a.packetsReceived;\n      b.packetsLost = a.packetsLost;\n      b.bytes = a.bytesReceived;\n      b.firsCount = a.firCount;\n      b.nacksCount = a.nackCount;\n      b.plisCount = a.pliCount;\n      b.framesDecodeCount = a.framesDecoded;\n      var c = this.lastDecodeVideoReceiverStats.get(b.ssrc),\n          h = this.lastVideoFramesDecode.get(b.ssrc),\n          k = Date.now();\n\n      if (0 < b.framesDecodeCount && !this.isFirstVideoDecoded) {\n        var r = b.decodedFrame ? b.decodedFrame.width : 0,\n            l = b.decodedFrame ? b.decodedFrame.height : 0;\n        this.onFirstVideoDecoded && this.onFirstVideoDecoded(r, l);\n        this.isFirstVideoDecoded = !0;\n      }\n\n      c && (r = c.stats, l = k - c.lts, b.framesDecodeFreezeTime = r.framesDecodeFreezeTime, b.framesDecodeInterval = r.framesDecodeInterval, b.framesDecodeCount > r.framesDecodeCount && this.isFirstVideoDecoded ? (c.lts = Date.now(), b.framesDecodeInterval = l, b.framesDecodeInterval >= this.options.freezeRateLimit && (this.videoIsReady ? b.framesDecodeFreezeTime += b.framesDecodeInterval : this.setVideoIsReady(!0))) : b.framesDecodeCount < r.framesDecodeCount && (b.framesDecodeInterval = 0));\n      h && 800 <= k - h.lts ? (b.decodeFrameRate = Math.round((b.framesDecodeCount - h.count) / ((k - h.lts) / 1E3)), this.lastVideoFramesDecode.set(b.ssrc, {\n        count: b.framesDecodeCount,\n        lts: k,\n        rate: b.decodeFrameRate\n      })) : h ? b.decodeFrameRate = h.rate : this.lastVideoFramesDecode.set(b.ssrc, {\n        count: b.framesDecodeCount,\n        lts: k,\n        rate: 0\n      });\n      a.totalDecodeTime && (b.decodeMs = 1E3 * a.totalDecodeTime);\n      a.trackId && this.processVideoTrackReceiverStats(a.trackId, b);\n      a.codecId && (b.codec = this.getCodecFromCodecStats(a.codecId));\n      a.framerateMean && (b.framesRateFirefox = a.framerateMean);\n      0 < b.packets && !this.isFirstVideoReceived && (this.onFirstVideoReceived && this.onFirstVideoReceived(), this.isFirstVideoReceived = !0);\n      this.lastDecodeVideoReceiverStats.set(b.ssrc, {\n        stats: gg({}, b),\n        lts: c ? c.lts : Date.now()\n      });\n    }, b.prototype.processVideoOutboundStats = function (a) {\n      var b = this._stats.videoSend.find(function (b) {\n        return b.ssrc === a.ssrc;\n      });\n\n      b || (b = fb(Fk), this._stats.videoSend.push(b));\n      var c = this.mediaBytesSent.get(a.ssrc);\n      c ? c.add(a.bytesSent) : ((h = new fg(10)).add(a.bytesSent), this.mediaBytesSent.set(a.ssrc, h));\n      void 0 !== a.retransmittedBytesSent && ((c = this.mediaBytesRetransmit.get(a.ssrc)) ? c.add(a.retransmittedBytesSent) : ((h = new fg(10)).add(a.retransmittedBytesSent), this.mediaBytesRetransmit.set(a.ssrc, h)));\n\n      if (a.totalEncodedBytesTarget) {\n        var h;\n        (c = this.mediaBytesTargetEncode.get(a.ssrc)) ? c.add(a.totalEncodedBytesTarget) : ((h = new fg(10)).add(a.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(a.ssrc, h));\n      }\n\n      if (b.ssrc = a.ssrc, b.bytes = a.bytesSent, b.packets = a.packetsSent, b.firsCount = a.firCount, b.nacksCount = a.nackCount, b.plisCount = a.pliCount, b.frameCount = a.framesEncoded, b.adaptionChangeReason = a.qualityLimitationReason, a.totalEncodeTime && a.framesEncoded) c = this.lastEncoderMs.get(a.ssrc), b.avgEncodeMs = !c || c.lastFrameCount > a.framesEncoded ? 1E3 * a.totalEncodeTime / a.framesEncoded : 1E3 * (a.totalEncodeTime - c.lastEncoderTime) / (a.framesEncoded - c.lastFrameCount), this.lastEncoderMs.set(a.ssrc, {\n        lastFrameCount: a.framesEncoded,\n        lastEncoderTime: a.totalEncodeTime,\n        lts: Date.now()\n      });\n      (a.codecId && (b.codec = this.getCodecFromCodecStats(a.codecId)), a.mediaSourceId && this.processVideoMediaSource(a.mediaSourceId, b), a.trackId && this.processVideoTrackSenderStats(a.trackId, b), a.remoteId) ? this.processRemoteInboundStats(a.remoteId, b) : (c = this.findRemoteStatsId(a.ssrc, Vb.REMOTE_INBOUND)) && this.processRemoteInboundStats(c, b);\n    }, b.prototype.processAudioOutboundStats = function (a) {\n      var b = this._stats.audioSend.find(function (b) {\n        return b.ssrc === a.ssrc;\n      });\n\n      if (b || (b = fb(Gk), this._stats.audioSend.push(b)), b.ssrc = a.ssrc, b.packets = a.packetsSent, b.bytes = a.bytesSent, a.mediaSourceId && this.processAudioMediaSource(a.mediaSourceId, b), a.codecId && (b.codec = this.getCodecFromCodecStats(a.codecId)), a.trackId && this.processAudioTrackSenderStats(a.trackId, b), a.remoteId) this.processRemoteInboundStats(a.remoteId, b);else {\n        var c = this.findRemoteStatsId(a.ssrc, Vb.REMOTE_INBOUND);\n        c && this.processRemoteInboundStats(c, b);\n      }\n    }, b.prototype.findRemoteStatsId = function (a, b) {\n      var c = Array.from(this.report.values()).find(function (c) {\n        return c.type === b && c.ssrc === a;\n      });\n      return c ? c.id : null;\n    }, b.prototype.processVideoMediaSource = function (a, b) {\n      (a = this.report.get(a)) && a.width && a.height && a.framesPerSecond && (b.inputFrame = {\n        width: a.width,\n        height: a.height,\n        frameRate: a.framesPerSecond\n      });\n    }, b.prototype.processAudioMediaSource = function (a, b) {\n      (a = this.report.get(a)) && (b.inputLevel = a.audioLevel);\n    }, b.prototype.processVideoTrackSenderStats = function (a, b) {\n      if (a = this.report.get(a)) {\n        var c = 0,\n            e = Date.now(),\n            k = this.lastVideoFramesSent.get(b.ssrc);\n        k && 800 <= e - k.lts ? (c = Math.round((a.framesSent - k.count) / ((e - k.lts) / 1E3)), this.lastVideoFramesSent.set(b.ssrc, {\n          count: a.framesSent,\n          lts: e,\n          rate: c\n        })) : k ? c = k.rate : this.lastVideoFramesSent.set(b.ssrc, {\n          count: a.framesSent,\n          lts: e,\n          rate: 0\n        });\n        b.sentFrame = {\n          width: a.frameWidth,\n          height: a.frameHeight,\n          frameRate: c\n        };\n      }\n    }, b.prototype.processVideoTrackReceiverStats = function (a, b) {\n      if (a = this.report.get(a)) {\n        var c = this.lastVideoFramesRecv.get(b.ssrc),\n            e = Date.now();\n        b.framesReceivedCount = a.framesReceived;\n        var k = 0;\n        if (c && 800 <= e - c.lts ? (k = Math.round((a.framesReceived - c.count) / ((e - c.lts) / 1E3)), this.lastVideoFramesRecv.set(b.ssrc, {\n          count: a.framesReceived,\n          lts: e,\n          rate: k\n        })) : c ? k = c.rate : this.lastVideoFramesRecv.set(b.ssrc, {\n          count: a.framesReceived,\n          lts: e,\n          rate: 0\n        }), b.receivedFrame = {\n          width: a.frameWidth || 0,\n          height: a.frameHeight || 0,\n          frameRate: k || 0\n        }, b.decodedFrame = {\n          width: a.frameWidth || 0,\n          height: a.frameHeight || 0,\n          frameRate: b.decodeFrameRate || 0\n        }, b.outputFrame = {\n          width: a.frameWidth || 0,\n          height: a.frameHeight || 0,\n          frameRate: b.decodeFrameRate || 0\n        }, a.jitterBufferDelay && a.jitterBufferEmittedCount) c = this.lastVideoJBDelay.get(b.ssrc), this.lastVideoJBDelay.set(b.ssrc, {\n          jitterBufferDelay: a.jitterBufferDelay,\n          jitterBufferEmittedCount: a.jitterBufferEmittedCount\n        }), c || (c = {\n          jitterBufferDelay: 0,\n          jitterBufferEmittedCount: 0\n        }), a = 1E3 * (a.jitterBufferDelay - c.jitterBufferDelay) / (a.jitterBufferEmittedCount - c.jitterBufferEmittedCount), b.jitterBufferMs = a, b.currentDelayMs = Math.round(a);\n      }\n    }, b.prototype.processAudioTrackSenderStats = function (a, b) {\n      (a = this.report.get(a)) && (b.aecReturnLoss = a.echoReturnLoss || 0, b.aecReturnLossEnhancement = a.echoReturnLossEnhancement || 0);\n    }, b.prototype.processAudioTrackReceiverStats = function (a, b) {\n      if (a = this.report.get(a)) {\n        if (a.removedSamplesForAcceleration && a.totalSamplesReceived && (b.accelerateRate = a.removedSamplesForAcceleration / a.totalSamplesReceived), a.jitterBufferDelay && a.jitterBufferEmittedCount) {\n          var c = this.lastAudioJBDelay.get(b.ssrc);\n          this.lastAudioJBDelay.set(b.ssrc, {\n            jitterBufferDelay: a.jitterBufferDelay,\n            jitterBufferEmittedCount: a.jitterBufferEmittedCount\n          });\n          c || (c = {\n            jitterBufferDelay: 0,\n            jitterBufferEmittedCount: 0\n          });\n          b.jitterBufferMs = Math.round(1E3 * (a.jitterBufferDelay - c.jitterBufferDelay) / (a.jitterBufferEmittedCount - c.jitterBufferEmittedCount));\n        }\n\n        b.outputLevel = a.audioLevel;\n        c = 1920;\n        a.totalSamplesDuration && a.totalSamplesReceived && (c = a.totalSamplesReceived / a.totalSamplesDuration / 50, b.receivedFrames = Math.round(a.totalSamplesReceived / c));\n        a.concealedSamples && (b.droppedFrames = Math.round(a.concealedSamples / c));\n      }\n    }, b.prototype.processRemoteInboundStats = function (a, b) {\n      (a = this.report.get(a)) && (b.packetsLost = a.packetsLost, a.roundTripTime && (b.rttMs = 1E3 * a.roundTripTime));\n    }, b.prototype.getCodecFromCodecStats = function (a) {\n      a = this.report.get(a);\n      return a ? (a = a.mimeType.match(/\\/(.*)$/)) && a[1] ? a[1] : \"\" : \"\";\n    }, b.prototype.updateSendBitrate = function () {\n      var a = 0,\n          b = null,\n          g = null;\n      this.mediaBytesSent.forEach(function (b) {\n        a += b.diffMean();\n      });\n      this.mediaBytesRetransmit.forEach(function (a) {\n        b = null === b ? a.diffMean() : b + a.diffMean();\n      });\n      this.mediaBytesTargetEncode.forEach(function (a) {\n        g = null === g ? a.diffMean() : g + a.diffMean();\n      });\n      this._stats.bitrate = {\n        actualEncoded: 8 * (null !== b ? a - b : a) / (this.options.updateInterval / 1E3),\n        transmit: 8 * a / (this.options.updateInterval / 1E3)\n      };\n      null !== b && (this._stats.bitrate.retransmit = 8 * b / (this.options.updateInterval / 1E3));\n      null !== g && (this._stats.bitrate.targetEncoded = 8 * g / (this.options.updateInterval / 1E3));\n    }, b;\n  }(hg),\n      so = function (a) {\n    function b() {\n      return null !== a && a.apply(this, arguments) || this;\n    }\n\n    return Se(b, a), b.prototype.updateStats = function () {\n      return Promise.resolve();\n    }, b;\n  }(hg);\n\n  class Jk {\n    constructor(a) {\n      this.localCandidateCount = 0;\n      this.allCandidateReceived = !1;\n      this.videoTrack = this.audioTrack = null;\n      this.mediaStream = new MediaStream();\n      this.ID = Kk;\n      Kk += 1;\n      this.spec = a;\n      this.createPeerConnection();\n      a = this.pc;\n      var b = void 0,\n          c = void 0,\n          e = Ad() ? 1200 : void 0;\n      void 0 === b && (b = 250);\n      void 0 === c && (c = 8);\n      void 0 === e && (e = 500);\n      var g,\n          h = (g = navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]./i)) && g[0] ? Number(g[0].split(\"/\")[1]) : null;\n      this.statsFilter = h ? 76 > h ? new ro(a, {\n        updateInterval: b,\n        lossRateInterval: c,\n        freezeRateLimit: e\n      }) : new Ik(a, {\n        updateInterval: b,\n        lossRateInterval: c,\n        freezeRateLimit: e\n      }) : window.RTCStatsReport && a.getStats() instanceof Promise ? new Ik(a, {\n        updateInterval: b,\n        lossRateInterval: c,\n        freezeRateLimit: e\n      }) : new so(a, {\n        updateInterval: b,\n        lossRateInterval: c,\n        freezeRateLimit: e\n      });\n    }\n\n    get _statsFilter() {\n      return this.statsFilter;\n    }\n\n    getStats() {\n      return this.statsFilter.getStats();\n    }\n\n    createOfferSDP() {\n      var _this37 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          let a = yield _this37.pc.createOffer(_this37.offerOptions);\n          if (!a.sdp) throw Error(\"offer sdp is empty\");\n          return a.sdp;\n        } catch (a) {\n          throw k.error(\"create offer error:\", a.toString()), new n(l.CREATE_OFFER_FAILED, a.toString());\n        }\n      })();\n    }\n\n    setOfferSDP(a) {\n      var _this38 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          yield _this38.pc.setLocalDescription({\n            type: \"offer\",\n            sdp: a\n          });\n        } catch (b) {\n          throw k.error(\"set local offer error\", b.toString()), new n(l.CREATE_OFFER_FAILED, b.toString());\n        }\n      })();\n    }\n\n    setAnswerSDP(a) {\n      var _this39 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          yield _this39.pc.setRemoteDescription({\n            type: \"answer\",\n            sdp: a\n          });\n        } catch (b) {\n          if (\"InvalidStateError\" !== b.name || \"stable\" !== _this39.pc.signalingState) throw k.error(\"set remote answer error\", b.toString()), new n(l.SET_ANSWER_FAILED, b.toString());\n          k.debug(\"[pc-\".concat(_this39.ID, \"] ignore invalidstate error\"));\n        }\n      })();\n    }\n\n    close() {\n      this.onConnectionStateChange = this.onICEConnectionStateChange = void 0;\n\n      try {\n        this.pc.oniceconnectionstatechange = null, this.pc.onconnectionstatechange = null, this.pc.onsignalingstatechange = null, this.pc.onicecandidateerror = null, this.pc.onicecandidate = null, this.pc.close(), this.pc = null;\n      } catch (a) {}\n\n      this.statsFilter.destroy();\n    }\n\n    createPeerConnection() {\n      let a = {\n        iceServers: [{\n          urls: \"stun:webcs.agora.io:3478\"\n        }]\n      },\n          b = a => {\n        const b = [];\n        return q(a).call(a, a => {\n          if (a.security) {\n            var c;\n            a.tcpport && b.push({\n              username: a.username,\n              credential: a.password,\n              credentialType: \"password\",\n              urls: m(c = \"turns:\".concat((h = a.turnServerURL, h.match(/^[\\.:\\d]+$/) ? \"\".concat(h.replace(/[^\\d]/g, \"-\"), \".edge.agora.io\") : (k.info(\"Cannot recognized as IP address \".concat(h, \". Used As Host instead\")), h)), \":\")).call(c, a.tcpport, \"?transport=tcp\")\n            });\n          } else {\n            var e, g;\n            a.udpport && b.push({\n              username: a.username,\n              credential: a.password,\n              credentialType: \"password\",\n              urls: m(e = \"turn:\".concat(a.turnServerURL, \":\")).call(e, a.udpport, \"?transport=udp\")\n            });\n            a.tcpport && b.push({\n              username: a.username,\n              credential: a.password,\n              credentialType: \"password\",\n              urls: m(g = \"turn:\".concat(a.turnServerURL, \":\")).call(g, a.tcpport, \"?transport=tcp\")\n            });\n          }\n\n          var h;\n        }), b;\n      };\n\n      var c, e;\n      this.spec.iceServers ? a.iceServers = this.spec.iceServers : this.spec.turnServer && \"off\" !== this.spec.turnServer.mode && (fh(this.spec.turnServer.servers) ? a.iceServers = this.spec.turnServer.servers : (a.iceServers && a.iceServers.push(...b(this.spec.turnServer.servers)), a.iceServers && this.spec.turnServer.serversFromGateway && a.iceServers.push(...b(this.spec.turnServer.serversFromGateway)), q(c = m(e = this.spec.turnServer.servers).call(e, this.spec.turnServer.serversFromGateway || [])).call(c, b => {\n        b.forceturn && (a.iceTransportPolicy = \"relay\");\n      })));\n      v.CHROME_FORCE_PLAN_B && Bd() && (a.sdpSemantics = \"plan-b\", ha.supportUnifiedPlan = !1);\n      this.pc = new RTCPeerConnection(a, {\n        optional: [{\n          googDscp: !0\n        }]\n      });\n\n      this.pc.oniceconnectionstatechange = () => {\n        this.onICEConnectionStateChange && this.onICEConnectionStateChange(this.pc.iceConnectionState);\n      };\n\n      this.pc.onconnectionstatechange = () => {\n        this.onConnectionStateChange && this.onConnectionStateChange(this.pc.connectionState);\n      };\n\n      this.pc.onsignalingstatechange = () => {\n        this.pc && \"closed\" === this.pc.connectionState && this.onConnectionStateChange && this.onConnectionStateChange(this.pc.connectionState);\n      };\n\n      this.pc.onicecandidate = a => {\n        if (!a.candidate) return this.pc.onicecandidate = null, this.allCandidateReceived = !0, void k.debug(\"[pc-\".concat(this.ID, \"] local candidate count\"), this.localCandidateCount);\n        this.localCandidateCount += 1;\n      };\n\n      Ub(() => {\n        this.allCandidateReceived || (this.allCandidateReceived = !0, k.debug(\"[pc-\".concat(this.ID, \"] onicecandidate timeout, local candidate count\"), this.localCandidateCount));\n      }, v.CANDIDATE_TIMEOUT);\n    }\n\n  }\n\n  class Lk extends Jk {\n    constructor(a) {\n      super(a);\n    }\n\n    setOfferSDP(a) {\n      var _superprop_getSetOfferSDP = () => super.setOfferSDP,\n          _this40 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = v.CUSTOM_PUB_OFFER_MODIFIER;\n        return b && (a = b(a)), yield _superprop_getSetOfferSDP().call(_this40, a);\n      })();\n    }\n\n    setAnswerSDP(a) {\n      var _superprop_getSetAnswerSDP = () => super.setAnswerSDP,\n          _this41 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = v.CUSTOM_PUB_ANSWER_MODIFIER;\n        return b && (a = b(a)), yield _superprop_getSetAnswerSDP().call(_this41, a);\n      })();\n    }\n\n    getAnswerSDP() {\n      return this.pc.remoteDescription;\n    }\n\n    getOfferSDP() {\n      return this.pc.localDescription;\n    }\n\n    addStream(a) {\n      var _this42 = this;\n\n      return _asyncToGenerator(function* () {\n        a = a.getTracks();\n\n        for (let b of a) yield _this42.addTrack(b);\n      })();\n    }\n\n    replaceTrack(a) {\n      var _this43 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!ha.supportReplaceTrack) {\n          var b = \"audio\" === a.kind ? _this43.audioTrack : _this43.videoTrack;\n          if (!b) throw new n(l.UNEXPECTED_ERROR, \"can not find replaced track\");\n          return _this43.removeTrack(b), yield _this43.addTrack(a), !0;\n        }\n\n        let c = _this43.getSender(a.kind),\n            e = R(b = _this43.mediaStream.getTracks()).call(b, b => b.kind === a.kind);\n\n        e && _this43.mediaStream.removeTrack(e);\n\n        _this43.mediaStream.addTrack(a);\n\n        try {\n          yield c.replaceTrack(a), \"audio\" === a.kind ? _this43.audioTrack = a : _this43.videoTrack = a;\n        } catch (g) {\n          throw new n(l.SENDER_REPLACE_FAILED, g.toString());\n        }\n\n        return !1;\n      })();\n    }\n\n    removeTrack(a) {\n      let b = this.getSender(a.kind);\n      this.mediaStream.removeTrack(a);\n\n      try {\n        this.pc.removeTrack(b);\n      } catch (c) {\n        k.warning(\"[pc-\".concat(this.ID, \"] remove track error, ignore\"), c);\n      }\n\n      \"audio\" === a.kind ? (this.audioTrack = null, this.audioSender = void 0, this.audioTransceiver && (this.audioTransceiver.direction = \"inactive\"), this.audioTransceiver = void 0) : (this.videoTrack = null, this.videoSender = void 0, this.videoTransceiver && (this.videoTransceiver.direction = \"inactive\"), this.videoTransceiver = void 0);\n    }\n\n    onOfferSettled() {\n      Bd() && (this.audioSender && v.DSCP_TYPE && this.setAudioRtpEncodingParameters({\n        networkPriority: v.DSCP_TYPE\n      }).catch(a => {\n        k.debug(\"set audio sender`s network priority failed\");\n      }), this.videoSender && v.DSCP_TYPE && this.setVideoRtpEncodingParameters({\n        networkPriority: v.DSCP_TYPE\n      }).catch(a => {\n        k.debug(\"set video sender`s network priority failed\");\n      }));\n    }\n\n    addTrack(a) {\n      var _this44 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = ha;\n        if (\"audio\" === a.kind && _this44.audioTrack || \"video\" === a.kind && _this44.videoTrack) throw new n(l.UNEXPECTED_ERROR, \"Can't add multiple stream\");\n        let c, e;\n\n        _this44.mediaStream.addTrack(a);\n\n        b.supportUnifiedPlan ? (c = yield function () {\n          var _ref10 = _asyncToGenerator(function* (a, b, c) {\n            var e;\n            let g = R(e = a.getTransceivers()).call(e, a => \"inactive\" === a.direction && a.receiver.track.kind === b.kind);\n            return g ? (g.direction = \"sendrecv\", yield g.sender.replaceTrack(b), g) : a.addTransceiver(b, {\n              direction: \"sendrecv\",\n              streams: [c]\n            });\n          });\n\n          return function (_x38, _x39, _x40) {\n            return _ref10.apply(this, arguments);\n          };\n        }()(_this44.pc, a, _this44.mediaStream), e = c.sender) : e = _this44.pc.addTrack(a, _this44.mediaStream);\n        \"audio\" === a.kind ? (_this44.audioTrack = a, _this44.audioSender = e, _this44.audioTransceiver = c) : (_this44.videoTrack = a, _this44.videoSender = e, _this44.videoTransceiver = c);\n      })();\n    }\n\n    setRtpSenderParameters(a, b) {\n      var _this45 = this;\n\n      return _asyncToGenerator(function* () {\n        if (a = _this45.videoSender || (_this45.videoTransceiver ? _this45.videoTransceiver.sender : void 0)) {\n          var c = a.getParameters();\n          c.degradationPreference = b;\n\n          try {\n            yield a.setParameters(c);\n          } catch (e) {\n            k.debug(\"[\".concat(_this45.ID, \"] ignore RtpSender.setParameters\"), e.toString());\n          }\n        }\n      })();\n    }\n\n    setVideoRtpEncodingParameters(a) {\n      var _this46 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = _this46.videoSender || (_this46.videoTransceiver ? _this46.videoTransceiver.sender : void 0);\n        if (!b) throw new n(l.LOW_STREAM_ENCODING_ERROR, \"Low stream has no video sender.\");\n        let c = b.getParameters();\n        if (!c.encodings || !c.encodings[0]) throw new n(l.LOW_STREAM_ENCODING_ERROR, \"Low stream RtpEncodingParameters is empty.\");\n        a.scaleResolutionDownBy && (c.encodings[0].scaleResolutionDownBy = a.scaleResolutionDownBy);\n        a.maxBitrate && (c.encodings[0].maxBitrate = a.maxBitrate);\n        a.maxFramerate && (c.encodings[0].maxFramerate = a.maxFramerate);\n        let e = [\"very-low\", \"low\", \"medium\", \"high\"];\n        return a.networkPriority && ba(e).call(e, a.networkPriority) && (k.debug(\"set video sender network quality:\", a.networkPriority), c.encodings[0].networkPriority = a.networkPriority), yield b.setParameters(c), b.getParameters();\n      })();\n    }\n\n    setAudioRtpEncodingParameters(a) {\n      var _this47 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = _this47.audioSender || (_this47.audioTransceiver ? _this47.audioTransceiver.sender : void 0);\n        if (!b) throw new n(l.SET_ENCODING_PARAMETER_ERROR, \"pc has no audio sender.\");\n        let c = b.getParameters();\n        if (!c.encodings || !c.encodings[0]) throw new n(l.SET_ENCODING_PARAMETER_ERROR, \"pc RtpEncodingParameters is empty.\");\n        let e = [\"very-low\", \"low\", \"medium\", \"high\"];\n        return a.networkPriority && ba(e).call(e, a.networkPriority) && (k.debug(\"set audio sender network quality:\", a.networkPriority), c.encodings[0].networkPriority = a.networkPriority), yield b.setParameters(c), b.getParameters();\n      })();\n    }\n\n    getSender(a) {\n      var b = null;\n\n      if (ha.supportUnifiedPlan) {\n        var c;\n        b = (b = R(c = this.pc.getTransceivers()).call(c, b => b.sender.track && b.sender.track.kind === a)) ? b.sender : null;\n      } else {\n        var e;\n        b = R(e = this.pc.getSenders()).call(e, b => b.track && b.track.kind === a) || null;\n      }\n\n      if (!b) throw new n(l.SENDER_NOT_FOUND);\n      return b;\n    }\n\n  }\n\n  class Mk extends Jk {\n    constructor(a) {\n      super(a);\n\n      this.statsFilter.onFirstAudioDecoded = () => this.onFirstAudioDecoded && this.onFirstAudioDecoded();\n\n      this.statsFilter.onFirstVideoDecoded = (a, c) => this.onFirstVideoDecoded && this.onFirstVideoDecoded(a, c);\n\n      this.statsFilter.onFirstAudioReceived = () => this.onFirstAudioReceived && this.onFirstAudioReceived();\n\n      this.statsFilter.onFirstVideoReceived = () => this.onFirstVideoReceived && this.onFirstVideoReceived();\n\n      ha.supportUnifiedPlan ? (this.audioTransceiver = this.pc.addTransceiver(\"audio\", {\n        direction: \"recvonly\"\n      }), this.videoTransceiver = this.pc.addTransceiver(\"video\", {\n        direction: \"recvonly\"\n      })) : this.offerOptions = {\n        offerToReceiveAudio: !0,\n        offerToReceiveVideo: !0\n      };\n\n      this.pc.ontrack = a => {\n        \"audio\" === a.track.kind ? this.audioTrack = a.track : this.videoTrack = a.track;\n        this.onTrack && this.onTrack(a.track, a.streams[0]);\n      };\n    }\n\n    setOfferSDP(a) {\n      var _superprop_getSetOfferSDP2 = () => super.setOfferSDP,\n          _this48 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = v.CUSTOM_SUB_OFFER_MODIFIER;\n        return b && (a = b(a)), yield _superprop_getSetOfferSDP2().call(_this48, a);\n      })();\n    }\n\n    setAnswerSDP(a) {\n      var _superprop_getSetAnswerSDP2 = () => super.setAnswerSDP,\n          _this49 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = v.CUSTOM_SUB_ANSWER_MODIFIER;\n        return b && (a = b(a)), yield _superprop_getSetAnswerSDP2().call(_this49, a);\n      })();\n    }\n\n  }\n\n  let Kk = 1,\n      Nk = 1;\n\n  class Ok extends Sa {\n    constructor(a, b) {\n      super();\n      this.startTime = x();\n      this.createTime = x();\n      this.readyToReconnect = !1;\n      this._connectionState = \"disconnected\";\n      this.currentReconnectCount = 0;\n      this.ID = Nk;\n      Nk += 1;\n      this.joinInfo = a;\n      this._userId = b;\n      this.createPC();\n    }\n\n    get connectionState() {\n      return this._connectionState;\n    }\n\n    set connectionState(a) {\n      a !== this._connectionState && (this.emit(H.CONNECTION_STATE_CHANGE, a, this._connectionState), this._connectionState = a);\n    }\n\n    get connectionId() {\n      var a, b;\n      return m(a = m(b = \"\".concat(this.joinInfo.clientId, \"-\")).call(b, this.type ? this.type : \"sub(\".concat(this._userId, \")\"), \"-\")).call(a, this.ID);\n    }\n\n    getUserId() {\n      return this._userId;\n    }\n\n    startUploadStats() {\n      this.statsUploadInterval = window.setInterval(() => {\n        let a = this.pc.getStats();\n        this.uploadStats(a, this.lastUploadPCStats);\n        this.lastUploadPCStats = a;\n      }, 3E3);\n      this.statsUploadSlowInterval = window.setInterval(() => {\n        let a = this.pc.getStats();\n        this.uploadSlowStats(a);\n      }, 6E4);\n      this.relatedStatsUploadInterval = window.setInterval(() => {\n        let a = this.pc.getStats();\n        this.uploadRelatedStats(a, this.lastRelatedPcStats);\n        this.lastRelatedPcStats = a;\n      }, 1E3);\n    }\n\n    stopUploadStats() {\n      this.statsUploadInterval && window.clearInterval(this.statsUploadInterval);\n      this.relatedStatsUploadInterval && window.clearInterval(this.relatedStatsUploadInterval);\n      this.relatedStatsUploadInterval = this.statsUploadInterval = void 0;\n    }\n\n    createWaitConnectionConnectedPromise() {\n      return new A((a, b) => {\n        \"disconnected\" === this.connectionState ? b() : \"connected\" === this.connectionState ? a() : this.once(H.CONNECTION_STATE_CHANGE, c => {\n          \"connected\" === c ? a() : b();\n        });\n      });\n    }\n\n    reconnectPC(a) {\n      var _this50 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this50.readyToReconnect = !1, a && _this50.onPCDisconnected(a), Infinity < _this50.currentReconnectCount) throw k.debug(\"[\".concat(_this50.connectionId, \"] cannot reconnect pc\")), a || new n(l.UNEXPECTED_ERROR);\n\n        _this50.stopUploadStats();\n\n        k.debug(\"[\".concat(_this50.connectionId, \"] start reconnect pc\"));\n        _this50.connectionState = \"connecting\";\n        _this50.currentReconnectCount += 1;\n        if (yield _this50.closePC()) return k.debug(\"[\".concat(_this50.connectionId, \"] abort reconnect pc, wait ws\")), void _this50.readyToReconnectPC();\n\n        _this50.createPC();\n\n        yield _this50.startP2PConnection();\n        _this50.currentReconnectCount = 0;\n      })();\n    }\n\n    readyToReconnectPC() {\n      this.stopUploadStats();\n      this.readyToReconnect = !0;\n      this.pc.onICEConnectionStateChange = void 0;\n      this.connectionState = \"connecting\";\n    }\n\n    updateICEPromise() {\n      this.removeAllListeners(H.GATEWAY_P2P_LOST);\n      this.icePromise = new A((a, b) => {\n        this.pc.onICEConnectionStateChange = c => {\n          var e, g;\n          k.info(m(e = m(g = \"[\".concat(this.connectionId, \"] ice-state: \")).call(g, this.type, \" p2p \")).call(e, c));\n          \"connected\" === c && a();\n          \"failed\" !== c && \"closed\" !== c || this.reconnectPC(new n(l.ICE_FAILED)).catch(a => {\n            this.emit(H.P2P_LOST);\n            b(a);\n          });\n        };\n\n        this.pc.onConnectionStateChange = a => {\n          var c, g;\n          k.info(m(c = m(g = \"[\".concat(this.connectionId, \"] connection-state: \")).call(g, this.type, \" p2p \")).call(c, a));\n          \"failed\" !== a && \"closed\" !== a || this.reconnectPC(new n(l.PC_CLOSED)).catch(a => {\n            this.emit(H.P2P_LOST);\n            b(a);\n          });\n        };\n\n        this.removeAllListeners(H.GATEWAY_P2P_LOST);\n        this.once(H.GATEWAY_P2P_LOST, a => {\n          var c;\n\n          if (this.pc.ID.toString() === a.toString()) {\n            if (k.info(m(c = \"[\".concat(this.connectionId, \"] \")).call(c, this.type, \" p2p gateway lost\")), this.pc.allCandidateReceived && 0 === this.pc.localCandidateCount) return this.disconnectedReason = new n(l.NO_ICE_CANDIDATE, \"can not get candidate in this pc\"), void this.closeP2PConnection(!0);\n            this.reconnectPC(new n(l.GATEWAY_P2P_LOST)).catch(a => {\n              this.emit(H.P2P_LOST);\n              b(a);\n            });\n          }\n        });\n      });\n    }\n\n  }\n\n  class Pk {\n    constructor(a) {\n      this.freezeTimeCounterList = [];\n      this.lastTimeUpdatedTime = this.playbackTime = this.freezeTime = this.timeUpdatedCount = 0;\n      this._videoElementStatus = Ba.NONE;\n      this.isGettingVideoDimensions = !1;\n\n      this.handleVideoEvents = a => {\n        switch (a.type) {\n          case \"play\":\n          case \"playing\":\n            this.startGetVideoDimensions();\n            this.videoElementStatus = Ba.PLAYING;\n            break;\n\n          case \"loadeddata\":\n            this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded();\n            break;\n\n          case \"canplay\":\n            this.videoElementStatus = Ba.CANPLAY;\n            break;\n\n          case \"stalled\":\n            this.videoElementStatus = Ba.STALLED;\n            break;\n\n          case \"suspend\":\n            this.videoElementStatus = Ba.SUSPEND;\n            break;\n\n          case \"pause\":\n            this.videoElementStatus = Ba.PAUSED;\n            this.videoElement && this.videoTrack && \"live\" === this.videoTrack.readyState && (k.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume\")), this.videoElement.play());\n            break;\n\n          case \"waiting\":\n            this.videoElementStatus = Ba.WAITING;\n            break;\n\n          case \"abort\":\n            this.videoElementStatus = Ba.ABORT;\n            break;\n\n          case \"ended\":\n            this.videoElementStatus = Ba.ENDED;\n            break;\n\n          case \"emptied\":\n            this.videoElementStatus = Ba.EMPTIED;\n            break;\n\n          case \"timeupdate\":\n            {\n              a = x();\n              if (this.timeUpdatedCount += 1, 10 > this.timeUpdatedCount) return void (this.lastTimeUpdatedTime = a);\n              let b = a - this.lastTimeUpdatedTime;\n              this.lastTimeUpdatedTime = a;\n              500 < b && (this.freezeTime += b);\n\n              for (this.playbackTime += b; 6E3 <= this.playbackTime;) this.playbackTime -= 6E3, this.freezeTimeCounterList.push(Math.min(6E3, this.freezeTime)), this.freezeTime = Math.max(0, this.freezeTime - 6E3);\n            }\n        }\n      };\n\n      this.startGetVideoDimensions = () => {\n        let a = () => {\n          if (this.isGettingVideoDimensions = !0, this.videoElement && 4 < this.videoElement.videoWidth * this.videoElement.videoHeight) return k.debug(\"[\".concat(this.trackId, \"] current video dimensions:\"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = !1);\n          Ub(a, 500);\n        };\n\n        !this.isGettingVideoDimensions && a();\n      };\n\n      this.slot = a.element;\n      this.trackId = a.trackId;\n      this.updateConfig(a);\n    }\n\n    get videoElementStatus() {\n      return this._videoElementStatus;\n    }\n\n    set videoElementStatus(a) {\n      var b, c;\n      a !== this._videoElementStatus && (k.debug(m(b = m(c = \"[\".concat(this.trackId, \"] video-element-status change \")).call(c, this._videoElementStatus, \" => \")).call(b, a)), this._videoElementStatus = a);\n    }\n\n    updateConfig(a) {\n      this.config = a;\n      this.trackId = a.trackId;\n      a = a.element;\n      a !== this.slot && (this.destroy(), this.slot = a);\n      this.createElements();\n    }\n\n    updateVideoTrack(a) {\n      this.videoTrack !== a && (this.videoTrack = a, this.createElements());\n    }\n\n    play() {\n      if (this.videoElement) {\n        let a = this.videoElement.play();\n        a && a.catch && a.catch(a => {\n          k.warning(\"[\".concat(this.trackId, \"] play warning: \"), a);\n        });\n      }\n    }\n\n    getCurrentFrame() {\n      if (!this.videoElement) return new ImageData(2, 2);\n      let a = document.createElement(\"canvas\");\n      a.width = this.videoElement.videoWidth;\n      a.height = this.videoElement.videoHeight;\n      var b = a.getContext(\"2d\");\n      if (!b) return k.error(\"create canvas context failed!\"), new ImageData(2, 2);\n      b.drawImage(this.videoElement, 0, 0, a.width, a.height);\n      b = b.getImageData(0, 0, a.width, a.height);\n      return a.remove(), b;\n    }\n\n    destroy() {\n      if (this.videoElement && (this.videoElement.srcObject = null, this.videoElement = void 0), this.container) {\n        try {\n          this.slot.removeChild(this.container);\n        } catch (a) {}\n\n        this.container = void 0;\n      }\n\n      this.freezeTimeCounterList = [];\n    }\n\n    createElements() {\n      this.container || (this.container = document.createElement(\"div\"));\n      this.container.id = \"agora-video-player-\".concat(this.trackId);\n      this.container.style.width = \"100%\";\n      this.container.style.height = \"100%\";\n      this.container.style.position = \"relative\";\n      this.container.style.overflow = \"hidden\";\n      this.videoTrack ? (this.container.style.backgroundColor = \"black\", this.createVideoElement(), this.container.appendChild(this.videoElement)) : this.removeVideoElement();\n      this.slot.appendChild(this.container);\n    }\n\n    createVideoElement() {\n      (this.videoElement || (this.videoElementStatus = Ba.INIT, this.videoElement = document.createElement(\"video\"), this.videoElement.onerror = () => this.videoElementStatus = Ba.ERROR, this.container && this.container.appendChild(this.videoElement), q(qe).call(qe, a => {\n        this.videoElement && this.videoElement.addEventListener(a, this.handleVideoEvents);\n      }), this.videoElementCheckInterval = window.setInterval(() => {\n        !document.getElementById(\"video_\".concat(this.trackId)) && this.videoElement && (this.videoElementStatus = Ba.DESTROYED);\n      }, 1E3)), this.videoElement.id = \"video_\".concat(this.trackId), this.videoElement.className = \"agora_video_player\", this.videoElement.style.width = \"100%\", this.videoElement.style.height = \"100%\", this.videoElement.style.position = \"absolute\", this.videoElement.controls = !1, this.videoElement.setAttribute(\"playsinline\", \"\"), this.videoElement.style.left = \"0\", this.videoElement.style.top = \"0\", this.config.mirror && (this.videoElement.style.transform = \"rotateY(180deg)\"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = \"cover\", this.videoElement.setAttribute(\"muted\", \"\"), this.videoElement.muted = !0, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, this.videoElement.load());\n      let a = this.videoElement.play();\n      void 0 !== a && a.catch(a => {\n        k.debug(\"[\".concat(this.trackId, \"] playback interrupted\"), a.toString());\n      });\n    }\n\n    removeVideoElement() {\n      if (this.videoElement) {\n        q(qe).call(qe, a => {\n          this.videoElement && this.videoElement.removeEventListener(a, this.handleVideoEvents);\n        });\n        this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0);\n\n        try {\n          this.container && this.container.removeChild(this.videoElement);\n        } catch (a) {}\n\n        this.videoElement = void 0;\n        this.videoElementStatus = Ba.NONE;\n      }\n    }\n\n  }\n\n  let qe = \"play playing loadeddata canplay pause stalled suspend waiting abort emptied ended timeupdate\".split(\" \");\n  var Qk;\n  !document.documentMode && window.StyleMedia && (HTMLCanvasElement.prototype.getContext = (Qk = HTMLCanvasElement.prototype.getContext, function () {\n    let a = arguments;\n    return \"webgl\" === a[0] && (a = Ha([]).call(arguments), a[0] = \"experimental-webgl\"), Qk.apply(null, a);\n  }));\n  let to = [31, 222, 239, 159, 192, 236, 164, 81, 54, 227, 176, 149, 2, 247, 75, 141, 183, 54, 213, 216, 158, 92, 111, 49, 228, 111, 150, 6, 135, 79, 35, 212, 4, 155, 200, 168, 37, 107, 243, 110, 144, 179, 51, 81, 55, 78, 223, 242, 191, 211, 74, 119, 203, 151, 142, 62, 31, 41, 132, 22, 35, 155, 87, 123, 119, 117, 216, 57, 201, 53, 228, 67, 201, 40, 106, 24, 80, 176, 187, 253, 60, 63, 136, 100, 20, 12, 177, 99, 64, 38, 101, 143, 111, 176, 251, 211, 145, 136, 34, 23, 79, 136, 202, 95, 105, 199, 125, 67, 180, 44, 210, 179, 228, 4, 85, 160, 188, 64, 26, 46, 6, 61, 201, 103, 248, 18, 97, 254, 140, 36, 115, 106, 48, 124, 102, 216, 155, 120, 36, 227, 165, 217, 7, 227, 191, 128, 212, 157, 80, 37, 117, 175, 24, 214, 47, 221, 183, 211, 51, 174, 251, 223, 159, 167, 152, 53, 36, 107, 199, 223, 91, 62, 46, 194, 11, 80, 121, 188, 219, 2, 99, 99, 232, 229, 173, 234, 21, 30, 236, 177, 243, 142, 97, 48, 108, 56, 62, 172, 56, 216, 3, 42, 79, 138, 23, 88, 182, 39, 5, 118, 68, 135, 178, 56, 9, 94, 189, 44, 104, 9, 238, 231, 174, 122, 85, 247, 231, 86, 74, 8, 189, 147, 218, 180, 58, 76, 227, 17, 46, 90, 194, 100, 51, 178, 72, 163, 151, 243, 166, 130, 85, 1, 223, 130, 152, 242, 85, 255, 28, 173, 97, 252, 119, 215, 177, 119, 86, 104, 136, 82, 40, 72, 53, 11, 18, 26, 240, 188, 76, 110, 39, 31, 189],\n      uo = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 152, 221, 191, 124, 116, 248, 106, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 134, 194, 240, 46, 9, 3, 141, 22, 35, 146, 76, 23, 109, 117, 208, 41, 201, 45, 218, 76, 203, 105, 51, 58, 97, 154, 145, 236, 49, 18, 183, 127, 27, 12, 210, 122, 73, 42, 37, 143, 36, 207, 251, 211, 145, 191, 56, 10, 88, 222, 181, 125, 22, 238, 123, 71, 177, 107, 218, 254, 173, 28, 34, 253, 249, 67, 83, 97, 73, 111, 219, 43, 181, 82, 38, 230, 136, 109, 22, 67];\n\n  class Rk {\n    constructor(a, b) {\n      this.gl = a;\n      this.kernel = b || uo;\n      a = this.gl;\n      b = Mh(this.kernel);\n      b = zl(a, [Mh(to), b]);\n      var c = a.getAttribLocation(b, \"a_position\"),\n          e = a.createBuffer();\n      a.bindBuffer(a.ARRAY_BUFFER, e);\n      a.bufferData(a.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), a.STATIC_DRAW);\n      a.enableVertexAttribArray(c);\n      a.vertexAttribPointer(c, 2, a.FLOAT, !1, 0, 0);\n      c = a.getAttribLocation(b, \"a_texCoord\");\n      e = a.createBuffer();\n      a.bindBuffer(a.ARRAY_BUFFER, e);\n      a.bufferData(a.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), a.STATIC_DRAW);\n      a.enableVertexAttribArray(c);\n      a.vertexAttribPointer(c, 2, a.FLOAT, !1, 0, 0);\n      this.program = a = b;\n    }\n\n    setUniforms() {\n      let a = this.gl.getUniformLocation(this.program, \"u_flipY\");\n      this.gl.uniform1f(a, 1);\n    }\n\n  }\n\n  class Nb extends Rk {\n    constructor(a, b, c, e) {\n      super(a, b);\n      this.denoiseLevel = 5;\n      this.xOffset = 1 / c;\n      this.yOffset = 1 / e;\n    }\n\n    setUniforms() {\n      let a = this.gl.getUniformLocation(this.program, \"u_flipY\"),\n          b = this.gl.getUniformLocation(this.program, \"u_singleStepOffset\"),\n          c = this.gl.getUniformLocation(this.program, \"u_denoiseLevel\");\n      this.gl.uniform2f(b, this.xOffset, this.yOffset);\n      this.gl.uniform1f(c, this.denoiseLevel);\n      this.gl.uniform1f(a, 1);\n    }\n\n    setParameters(a) {\n      void 0 !== a.denoiseLevel && (this.denoiseLevel = a.denoiseLevel);\n    }\n\n    setSize(a, b) {\n      this.xOffset = 1 / a;\n      this.yOffset = 1 / b;\n    }\n\n  }\n\n  let vo = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 155, 210, 164, 99, 114, 228, 96, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 133, 194, 247, 34, 31, 39, 142, 28, 2, 130, 18, 109, 84, 124, 223, 62, 140, 52, 128, 47, 208, 47, 115, 39, 4, 200, 220, 171, 53, 36, 150, 101, 10, 75, 247, 121, 74, 36, 35, 143, 108, 176, 235, 211, 135, 164, 36, 11, 88, 160, 148, 35, 6, 221, 41, 32, 166, 109, 205, 171, 228, 4, 26, 169, 244, 82, 119, 102, 86, 61, 201, 103, 248, 18, 97, 242, 182, 34, 121, 70, 28, 71, 126, 197, 223, 126, 14, 244, 149, 192, 12, 176, 187, 149, 212, 156, 22, 44, 36, 133, 10, 216, 63, 198, 213, 154, 116, 230, 253, 154, 154, 249, 215, 55, 60, 34, 196, 229, 76, 50, 44, 135, 22, 77, 113, 247, 142, 94, 60, 23, 172, 145, 175, 218, 81, 86, 162, 239, 180, 205, 63, 118, 3, 110, 123, 224, 127, 158, 124, 15, 127, 157, 27, 66, 176, 33, 24, 51, 53, 194, 178, 56, 6, 74, 191, 111, 51, 78, 174, 157, 229, 17, 22, 178, 231, 92, 25, 23, 191, 157, 137, 188, 54, 64, 176, 13, 22, 81, 207, 45, 108, 203, 83, 186, 130, 237, 186, 153, 110, 8, 196, 168, 152, 161, 28, 238, 46, 184, 36, 185, 20, 203, 183, 98, 95, 41, 149, 93, 105, 37, 116, 91, 68, 105, 164, 217, 30, 42, 60, 53, 173, 213, 177, 216, 195, 53, 204, 173, 128, 243, 42, 122, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 220, 161, 39, 214, 146, 183, 193, 225, 23, 177, 201, 243, 128, 160, 33, 75, 86, 126, 139, 254, 232, 14, 13, 85, 2, 112, 17, 150, 36, 180, 86, 226, 225, 126, 197, 17, 228, 225, 142, 245, 37, 170, 39, 96, 187, 190, 2, 35, 85, 237, 11, 189, 1, 79, 237, 2, 1, 114, 246, 109, 190, 66, 54, 153, 43, 218, 204, 70, 6, 204, 162, 247, 18, 130, 123, 30, 60, 165, 130, 142, 210, 133, 91, 127, 117, 71, 38, 145, 172, 7, 5, 16, 220, 222, 111, 98, 141, 239, 208, 125, 26, 238, 28, 0, 216, 89, 13, 7, 119, 134, 194, 75, 41, 67, 174, 1, 217, 80, 101, 40, 26, 59, 28, 59, 46, 108, 138, 38, 157, 167, 28, 234, 73, 177, 42, 42, 102, 108, 26, 181, 27, 178, 42, 43, 52, 28, 110, 117, 198, 173, 176, 178, 101, 225, 150, 36, 139, 108, 105, 10, 237, 222, 3, 143, 126, 18, 144, 115, 74, 56, 114, 134, 231, 159, 212, 62, 126, 80, 173, 216, 167, 4, 81, 18, 52, 17, 144, 218, 32, 139, 207, 104, 128, 229, 99, 84, 120, 31, 87, 227, 154, 91, 196, 63, 123, 111, 125, 36, 52, 57, 168, 113, 150, 189, 204, 24, 104, 196, 237, 86, 163, 68, 197, 202, 170, 212, 191, 81, 193, 111, 255, 162, 181, 202, 156, 146, 196, 96, 16, 118, 117, 55, 71, 156, 31, 163, 242, 204, 239, 11, 150, 27, 126, 115, 154, 107, 247, 134, 158, 125, 255, 146, 35, 183, 209, 36, 116, 87, 215, 172, 5, 251, 133, 114, 254, 141, 195, 6, 145, 4, 111, 182, 167, 74, 154, 152, 68, 18, 146, 88, 106, 200, 154, 15, 176, 94, 86, 66, 178, 101, 219, 35, 188, 129, 66, 28, 41, 110, 174, 53, 88, 174, 64, 191, 206, 127, 48, 126, 214, 216, 93, 119, 2, 166, 99, 181, 222, 29, 218, 28, 195, 219, 125, 44, 50, 16, 99, 174, 225, 51, 133, 120, 184, 159, 168, 75, 242, 162, 124, 255, 81, 25, 153, 109, 69, 220, 176, 4, 237, 196, 233, 19, 8, 240, 160, 39, 122, 81, 29, 188, 144, 249, 170, 174, 137, 30, 10, 93, 133, 151, 199, 248, 175, 38, 41, 144, 229, 245, 149, 25, 240, 138, 179, 114, 182, 84, 50, 103, 95, 31, 199, 31, 87, 208, 203, 199, 135, 49, 211, 43, 52, 36, 74, 59, 37, 22, 136, 171, 244, 126, 18, 251, 39, 159, 241, 66, 206, 127, 149, 159, 182, 143, 232, 199, 136, 46, 150, 32, 51, 221, 74, 22, 102, 93, 22, 44, 132, 140, 199, 43, 69, 249, 77, 75, 140, 70, 4, 252, 98, 235, 77, 190, 125, 18, 56, 21, 10, 244, 42, 2, 246, 62, 127, 241, 123, 137, 22, 247, 219, 177, 160, 84, 18, 10, 84, 97, 251, 127, 102, 16, 209, 181, 100, 94, 56, 238, 209, 207, 76, 189, 95, 15, 165, 139, 143, 189, 96, 225, 55, 112, 178, 27, 218, 198, 223, 251, 52, 123, 94, 130, 220, 142, 216, 116, 237, 18, 254, 49, 59, 128, 41, 29, 15, 179, 164, 85, 76, 167, 166, 151, 39, 221, 2, 190, 68, 167, 26, 177, 114, 141, 4, 67, 25, 69, 182, 38, 166, 160, 27, 151, 148, 108, 48, 227, 60, 112, 48, 22, 159, 76, 127, 251, 63, 254, 177, 113, 217, 197, 95, 179, 109, 128, 138, 99, 27, 249, 10, 174, 155, 129, 80, 39, 165, 252, 85, 60, 131, 183, 98, 107, 68, 207, 19, 233, 231, 55, 225, 126, 77, 49, 53, 145, 203, 113, 29, 208, 64, 237, 182, 229, 165, 7, 11, 169, 106, 253, 116, 141, 200, 62, 16, 38, 121, 55, 148, 91, 83, 160, 140, 126, 121, 12, 79, 189, 72, 172, 31, 243, 240, 209, 229, 32, 220, 91, 229, 81, 94, 247, 121, 153, 151, 232, 182, 171, 198, 50, 31, 152, 245, 172, 151, 130, 55, 62, 125, 38, 155, 229, 78, 207, 148, 201, 2, 78, 63, 119, 107, 168, 78, 139, 141, 163, 177, 191, 239, 141, 39, 182, 174, 40, 76, 226, 62, 125, 209, 6, 6, 34, 37, 147, 85, 204, 103, 51, 191, 36, 248, 17, 175, 20, 1, 53, 16, 35, 143, 237, 177, 125, 86, 29, 219, 235, 20, 121, 205, 59, 5, 250, 107, 109, 32, 224, 30, 152, 143, 113, 151, 95, 85, 19, 254, 164, 135, 124, 68, 136, 199, 29, 31, 244, 91, 10, 84, 127, 101, 210, 70, 226, 195, 140, 70, 166, 54, 217, 165, 84, 42, 165, 175, 100, 234, 124, 121, 105, 53, 101, 118, 174, 101, 220, 147, 68, 161, 37, 0, 182, 220, 142, 221, 155, 230, 115, 164, 10, 214, 208, 120, 91, 152, 66, 27, 81, 184, 48, 84, 70, 7, 128, 153, 217, 218, 249, 226, 70, 130, 200, 156, 61, 227, 21, 164, 137, 193, 221, 119, 10, 134, 204, 23, 20, 17, 90, 94, 105, 204, 39, 99, 1, 64, 153, 45, 213, 19, 247, 97, 194, 49, 35, 125, 255, 195, 139, 63, 209, 175, 208, 147, 189, 244, 204, 24, 211, 99, 142, 18, 92, 130, 254, 182, 231, 235, 93, 10, 127, 175, 87, 35, 62, 110, 137, 184, 39, 114, 200, 150, 11, 190, 40, 162, 168, 223, 203, 110, 242, 192, 234, 26, 11, 54, 155, 38, 48, 79, 109, 101, 119, 165, 187, 223, 5, 20, 168, 171, 241, 20, 243, 108, 199, 3, 155, 69, 244, 149, 0, 187, 110, 12, 233, 42, 151, 189, 139, 133, 104, 3, 30, 16, 200, 69, 4, 123, 103, 144, 12, 106, 182, 1, 127, 91, 125, 158, 12, 144, 238, 232, 209, 101, 159, 56, 163, 240, 179, 50, 169, 120, 219, 176, 87, 77, 45, 247, 153, 190, 82, 132, 50, 137, 209, 97, 19, 35, 247, 161, 62, 77, 16, 71, 152, 72, 61, 50, 99, 157, 154, 56, 58, 175, 27, 73, 121, 229, 195, 228, 132, 69, 233, 169, 100, 21, 123, 17, 3, 164, 6, 146, 106, 196, 29, 3, 250, 217, 164, 23, 171, 203, 14, 242, 239, 249, 169, 116, 138, 209, 98, 113, 181, 122, 35, 162, 216, 46, 230, 4, 155, 142, 118, 216, 232, 229, 28, 12, 158, 153, 126, 149, 171, 172, 231, 99, 211, 57, 114, 136, 183, 114, 74, 35, 233, 115, 127, 253, 157, 38, 49, 136, 141, 25, 161, 255, 232, 110, 101, 208, 166, 186, 226, 12, 185, 19, 155, 53, 93, 155, 39, 161, 7, 124, 213, 52, 223, 125, 211, 242, 253, 22, 13, 131, 115, 167, 198, 188, 90, 209, 63, 224, 92, 112, 118, 220, 165, 31, 164, 43, 58, 197, 77, 17, 247, 77, 164, 74, 77, 218, 18, 187, 41, 76, 189, 127, 98, 18, 226, 231, 71, 115, 236, 68, 183, 111, 50, 168, 88, 247, 9, 123, 65, 180, 88, 74, 44, 101, 101, 173, 11];\n\n  class wo extends Nb {\n    constructor(a, b, c) {\n      super(a, vo, b, c);\n    }\n\n  }\n\n  let xo = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 165, 108, 122, 254, 125, 130, 229, 55, 109, 113, 11, 210, 238, 163, 213, 86, 116, 156, 248, 215, 63, 20, 48, 173, 31, 55, 133, 18, 105, 32, 16, 204, 35, 128, 38, 212, 87, 200, 97, 114, 40, 12, 210, 193, 171, 59, 33, 158, 108, 14, 75, 228, 74, 65, 32, 57, 192, 112, 156, 234, 250, 140, 189, 40, 20, 6, 230, 135, 52, 17, 200, 123, 68, 183, 44, 215, 187, 234, 2, 13, 169, 234, 94, 115, 60, 6, 107, 224, 118, 254, 88, 2, 235, 134, 36, 120, 5, 85, 94, 126, 222, 223, 101, 105, 227, 147, 199, 64, 185, 246, 143, 183, 210, 30, 37, 127, 226, 79, 156, 118, 147, 208, 131, 51, 248, 232, 217, 206, 181, 218, 58, 61, 112, 244, 227, 68, 45, 41, 206, 69, 12, 45, 163, 205, 75, 6, 23, 167, 145, 250, 237, 92, 84, 164, 240, 253, 216, 54, 85, 7, 108, 62, 255, 42, 217, 3, 27, 0, 196, 94, 28, 241, 120, 80, 92, 89, 135, 228, 125, 2, 3, 242, 39, 116, 64, 248, 216, 177, 122, 66, 178, 180, 9, 7, 33, 186, 208, 213, 188, 59, 78, 243, 95, 123, 28, 142, 45, 99, 130, 7, 167, 194, 156, 238, 199, 10, 71, 141, 251, 221, 158, 16, 255, 38, 181, 36, 184, 20, 136, 240, 55, 27, 51, 191, 82, 105, 55, 97, 78, 74, 121, 191, 161, 91, 126, 105, 103, 174, 139, 223, 145, 150, 120, 156, 240, 252, 182, 105, 104, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 201, 211, 39, 203, 146, 225, 246, 252, 21, 161, 250, 188, 137, 190, 42, 4, 90, 126, 211, 171, 240, 113, 67, 28, 92, 57, 77, 200, 125, 224, 19, 178, 142, 112, 202, 5, 233, 229, 128, 235, 105, 239, 102, 52, 179, 224, 87, 45, 68, 211, 10, 187, 9, 38, 190, 86, 25, 43, 175, 56, 231, 11, 108, 220, 36, 129, 131, 19, 93, 163, 239, 169, 118, 205, 50, 77, 121, 139, 139, 141, 197, 170, 20, 44, 39, 19, 97, 205, 228, 8, 106, 67, 210, 135, 111, 127, 141, 185, 175, 123, 26, 226, 42, 29, 217, 16, 99, 9, 46, 157, 232, 22, 3, 105, 174, 73, 144, 23, 110, 55, 84, 46, 4, 116, 39, 113, 205, 58, 158, 242, 7, 208, 75, 162, 55, 115, 35, 52, 124, 235, 114, 178, 55, 43, 98, 17, 100, 33, 134, 237, 190, 230, 60, 184, 192, 104, 146, 52, 58, 79, 174, 180, 81, 155, 114, 0, 153, 113, 90, 51, 86, 150, 254, 136, 205, 104, 39, 11, 190, 187, 233, 80, 81, 81, 56, 18, 222, 148, 116, 155, 156, 33, 132, 226, 127, 84, 34, 83, 28, 249, 153, 18, 197, 10, 116, 102, 125, 45, 47, 36, 235, 46, 212, 166, 209, 3, 125, 132, 237, 124, 163, 68, 197, 202, 232, 152, 234, 75, 235, 103, 248, 160, 241, 213, 151, 144, 130, 37, 23, 51, 48, 55, 12, 227, 31, 163, 242, 251, 245, 22, 129, 77, 20, 35, 150, 20, 181, 203, 138, 69, 233, 215, 109, 178, 209, 52, 85, 96, 221, 179, 56, 249, 138, 111, 250, 141, 134, 95, 152, 92, 109, 183, 174, 104, 151, 156, 31, 66, 211, 10, 57, 141, 167, 18, 177, 27, 126, 74, 252, 29, 143, 121, 173, 203, 8, 27, 44, 123, 148, 57, 88, 163, 68, 228, 158, 62, 98, 121, 192, 228, 94, 92, 72, 241, 33, 230, 173, 0, 197, 1, 194, 144, 111, 91, 60, 0, 106, 181, 203, 51, 133, 120, 250, 158, 184, 93, 216, 184, 126, 253, 21, 22, 155, 99, 80, 205, 227, 69, 231, 141, 165, 71, 70, 252, 223, 105, 51, 93, 22, 165, 135, 233, 177, 164, 139, 53, 5, 85, 151, 134, 214, 165, 249, 100, 24, 186, 207, 245, 149, 68, 218, 204, 252, 32, 190, 90, 48, 76, 57, 31, 201, 15, 52, 130, 135, 152, 206, 63, 198, 100, 126, 36, 2, 104, 116, 0, 160, 163, 186, 2, 91, 165, 57, 149, 163, 12, 239, 121, 152, 209, 224, 136, 248, 135, 136, 46, 150, 32, 51, 154, 6, 105, 0, 71, 30, 44, 175, 147, 139, 34, 91, 184, 78, 31, 145, 18, 3, 250, 122, 166, 47, 252, 109, 19, 40, 10, 123, 163, 99, 76, 133, 119, 37, 180, 38, 207, 79, 171, 185, 188];\n\n  class yo extends Nb {\n    constructor(a, b, c) {\n      super(a, xo, b, c);\n    }\n\n  }\n\n  let zo = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 160, 96, 121, 255, 120, 207, 227, 114, 120, 38, 72, 149, 145, 165, 227, 75, 122, 158, 250, 232, 46, 34, 52, 135, 9, 30, 144, 17, 110, 126, 110, 130, 71, 156, 46, 210, 67, 202, 51, 119, 97, 3, 211, 214, 227, 45, 109, 151, 97, 21, 10, 229, 53, 80, 26, 51, 202, 119, 128, 230, 197, 140, 135, 40, 14, 88, 128, 202, 95, 21, 208, 96, 83, 185, 98, 216, 242, 224, 15, 25, 224, 233, 86, 96, 46, 80, 120, 220, 48, 187, 86, 30, 240, 140, 46, 95, 81, 48, 90, 117, 140, 177, 51, 107, 235, 158, 137, 5, 241, 191, 154, 149, 219, 30, 126, 85, 175, 10, 216, 63, 139, 216, 151, 122, 251, 224, 202, 220, 227, 221, 53, 122, 34, 213, 224, 94, 45, 14, 200, 68, 31, 61, 175, 208, 17, 120, 82, 244, 138, 208, 165, 21, 19, 236, 232, 180, 217, 50, 74, 70, 126, 114, 227, 62, 192, 124, 9, 85, 148, 33, 77, 255, 117, 75, 102, 87, 151, 255, 87, 74, 74, 181, 111, 108, 9, 249, 220, 174, 59, 80, 254, 168, 29, 30, 94, 171, 133, 133, 195, 105, 64, 254, 68, 65, 18, 158, 54, 73, 203, 65, 175, 151, 170, 236, 138, 17, 119, 128, 237, 214, 189, 28, 250, 38, 149, 97, 242, 81, 212, 254, 57, 18, 120, 155, 64, 96, 108, 75, 78, 74, 121, 191, 243, 30, 42, 60, 103, 165, 196, 160, 195, 216, 99, 182, 173, 214, 182, 105, 53, 231, 3, 45, 212, 144, 101, 217, 65, 141, 44, 230, 125, 151, 154, 123, 57, 134, 223, 98, 133, 156, 238, 137, 181, 80, 175, 230, 167, 131, 180, 13, 69, 77, 44, 156, 165, 252, 14, 27, 85, 71, 1, 82, 196, 64, 243, 26, 167, 146, 98, 201, 6, 195, 247, 200, 224, 44, 177, 104, 109, 187, 231, 83, 118, 28, 159, 92, 179, 28, 14, 162, 81, 84, 21, 168, 34, 156, 21, 127, 215, 88, 218, 208, 11, 92, 161, 239, 239, 82, 221, 59, 86, 83, 201, 199, 216, 151, 139, 23, 54, 39, 52, 103, 204, 247, 24, 102, 94, 157, 138, 42, 49, 131, 183, 208, 50, 95, 236, 54, 6, 211, 26, 68, 72, 56, 212, 134, 24, 91, 114, 132, 1, 217, 80, 38, 47, 29, 47, 0, 107, 102, 99, 129, 33, 140, 243, 74, 251, 89, 247, 103, 12, 114, 58, 113, 240, 72, 188, 39, 48, 72, 89, 45, 102, 206, 245, 247, 231, 56, 167, 129, 122, 222, 47, 40, 78, 227, 159, 64, 206, 34, 127, 203, 127, 87, 40, 108, 152, 238, 147, 231, 46, 104, 89, 182, 180, 232, 86, 89, 91, 57, 10, 222, 202, 59, 199, 135, 60, 199, 189, 40, 84, 125, 28, 84, 162, 210, 91, 143, 34, 106, 117, 118, 3, 125, 126, 237, 60, 131, 173, 153, 69, 49, 212, 204, 117, 163, 31, 239, 202, 232, 152, 234, 3, 162, 32, 176, 184, 184, 196, 154, 131, 144, 115, 6, 53, 122, 55, 69, 166, 19, 230, 183, 175, 244, 1, 156, 11, 37, 121, 134, 121, 152, 142, 158, 125, 229, 150, 44, 183, 216, 109, 7, 65, 222, 169, 56, 222, 140, 110, 233, 157, 138, 66, 208, 6, 111, 166, 188, 76, 208, 222, 4, 104, 211, 10, 57, 141, 243, 65, 228, 86, 85, 88, 169, 91, 237, 56, 249, 133, 77, 21, 32, 37, 230, 55, 0, 184, 110, 228, 158, 62, 98, 45, 147, 177, 19, 119, 89, 164, 103, 132, 239, 84, 139, 68, 204, 157, 49, 41, 50, 89, 113, 159, 203, 51, 133, 120, 184, 210, 237, 15, 249, 187, 100, 253, 50, 16, 154, 112, 64, 193, 254, 10, 235, 200, 253, 84, 31, 169, 171, 39, 122, 70, 46, 186, 139, 212, 162, 173, 158, 41, 23, 86, 148, 172, 196, 237, 242, 58, 102, 180, 150, 238, 191, 25, 240, 204, 252, 125, 148, 29, 124, 51, 95, 10, 196, 55, 49, 159, 138, 144, 255, 126, 205, 43, 49, 42, 17, 59, 60, 77, 139, 177, 239, 64, 36, 224, 98, 205, 234, 70, 199, 103, 139, 218, 206, 207, 178, 217, 255, 32, 134, 59, 25, 221, 74, 22, 102, 82, 19, 20, 170, 142, 134, 42, 106, 249, 64, 80, 222, 28, 21, 169, 50, 235, 4, 237, 56, 81, 87, 76, 32, 251, 42, 6, 173, 105, 54, 191, 8, 136, 5, 245, 206, 239, 176, 9, 116, 24];\n\n  class Ao extends Nb {\n    constructor(a, b, c) {\n      super(a, zo, b, c);\n    }\n\n  }\n\n  let Bo = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 190, 100, 112, 230, 97, 199, 225, 96, 74, 99, 94, 248, 222, 162, 213, 95, 122, 158, 212, 233, 42, 22, 37, 217, 115, 36, 152, 30, 123, 116, 104, 212, 109, 129, 41, 220, 77, 213, 97, 124, 45, 4, 219, 197, 171, 40, 18, 149, 104, 20, 4, 248, 102, 64, 9, 50, 217, 124, 131, 180, 188, 159, 170, 63, 1, 84, 130, 150, 117, 14, 212, 118, 67, 165, 97, 207, 242, 251, 15, 30, 187, 188, 77, 79, 122, 67, 101, 252, 109, 244, 82, 37, 191, 227, 35, 114, 87, 57, 71, 99, 218, 155, 54, 101, 239, 138, 197, 13, 226, 228, 176, 157, 158, 87, 98, 55, 251, 79, 150, 64, 138, 200, 135, 40, 132, 135, 207, 146, 252, 222, 57, 58, 111, 151, 225, 78, 59, 36, 210, 70, 29, 121, 160, 210, 31, 109, 67, 167, 194, 177, 236, 91, 108, 164, 229, 130, 211, 59, 66, 93, 18, 107, 226, 54, 210, 51, 8, 77, 217, 19, 73, 187, 33, 30, 59, 9, 135, 162, 49, 5, 11, 225, 111, 119, 11, 247, 218, 129, 115, 83, 205, 170, 21, 4, 69, 210, 133, 134, 245, 109, 15, 177, 9, 81, 81, 203, 105, 42, 158, 12, 255, 151, 165, 230, 205, 5, 92, 196, 251, 211, 187, 27, 214, 43, 186, 91, 233, 85, 192, 229, 15, 71, 38, 220, 20, 38, 101, 44, 78, 7, 60, 251, 186, 75, 103, 108, 53, 166, 220, 186, 208, 194, 120, 207, 230, 159, 248, 22, 32, 142, 124, 96, 157, 222, 60, 191, 65, 145, 6, 239, 125, 151, 147, 50, 58, 130, 207, 110, 131, 223, 231, 137, 238, 28, 182, 216, 167, 198, 191, 37, 67, 76, 1, 144, 232, 218, 79, 72, 28, 65, 101, 43, 216, 64, 253, 16, 173, 179, 123, 140, 27, 233, 245, 199, 230, 36, 181, 102, 114, 247, 162, 18, 34, 20, 212, 25, 171, 24, 28, 143, 80, 94, 40, 167, 34, 209, 61, 117, 130, 1, 198, 196, 7, 21, 252, 180, 255, 92, 128, 119, 9, 48, 156, 138, 136, 151, 143, 23, 44, 52, 3, 40, 197, 228, 31, 123, 67, 163, 140, 32, 54, 204, 187, 149, 80, 19, 255, 82, 120, 195, 12, 110, 65, 56, 212, 143, 22, 78, 44, 234, 72, 140, 29, 118, 103, 18, 36, 7, 122, 50, 37, 139, 47, 142, 243, 25, 208, 88, 237, 126, 50, 103, 127, 19, 183, 29, 169, 29, 1, 55, 23, 100, 32, 129, 239, 243, 160, 61, 178, 197, 117, 199, 45, 57, 26, 165, 135, 92, 218, 59, 0, 197, 54, 13, 96, 40, 141, 212, 221, 131, 103, 46, 22, 228, 191, 167, 73, 20, 86, 62, 11, 147, 217, 116, 205, 203, 110, 134, 249, 51, 6, 123, 23, 86, 231, 157, 8, 144, 83, 126, 115, 118, 35, 96, 36, 229, 36, 220, 228, 143, 71, 45, 223, 129, 48, 236, 5, 145, 202, 188, 208, 184, 70, 241, 104, 255, 188, 181, 146, 210, 206, 144, 53, 77, 101, 120, 38, 8, 245, 80, 230, 165, 160, 183, 83, 202, 79, 127, 57, 214, 126, 242, 150, 208, 40, 239, 148, 35, 163, 201, 97, 74, 70, 214, 181, 63, 240, 147, 33, 253, 149, 140, 77, 197, 82, 126, 189, 231, 7, 196, 212, 80, 14, 151, 24, 57, 144, 243, 81, 234, 66, 24, 19, 236, 2, 137, 121, 246, 129, 65, 7, 99, 110, 174, 54, 74, 182, 81, 234, 142, 37, 72, 110, 220, 255, 64, 119, 10, 188, 111, 191, 228, 1, 205, 9, 204, 143, 56, 62, 125, 84, 106, 225, 131, 97, 192, 43, 240, 157, 161, 75, 168, 247, 44, 175, 65, 81, 192, 48, 21, 157, 167, 80, 191, 130, 161, 75, 85, 186, 174, 42, 117, 1, 68, 252, 204, 138, 254, 203, 152, 21, 13, 64, 144, 195, 207, 238, 229, 54, 103, 247, 159, 245, 211, 85, 191, 141, 168, 32, 234, 85, 46, 118, 12, 5, 199, 4, 19, 217, 203, 202, 156, 33, 143, 114, 116, 60, 66, 40, 58, 77, 208, 237, 171, 26, 72, 175, 114, 205, 248, 87, 137, 62, 210, 143, 151, 197, 167, 210, 241, 122, 150, 104, 122, 154, 2, 70, 102, 83, 19, 36, 141, 136, 199, 42, 79, 229, 71, 86, 194, 109, 31, 236, 80, 166, 17, 230, 109, 1, 40, 28, 46, 224, 56, 20, 230, 47, 100, 254, 116, 208, 76, 169, 157, 241, 175, 3, 70, 85, 31, 38, 245, 58, 33, 80, 145, 237, 8, 22, 71, 224, 158, 156, 31, 249, 81, 87, 247, 230, 199, 237, 96, 167, 123, 63, 243, 79, 156, 206, 203, 160, 54, 124, 68, 253, 215, 132, 235, 57, 185, 92, 238, 55, 59, 210, 104, 71, 26, 183, 180, 71, 12, 255, 224, 192, 65, 154, 72, 244, 8, 164, 10, 248, 46, 207, 30, 92, 1, 80, 244, 31, 189, 138, 88, 216, 218, 63, 100, 227, 116, 57, 119, 94, 135, 5, 126, 255, 32, 191, 163, 61, 209, 194, 88, 248, 112, 139, 173, 43, 69, 134, 3, 160, 151, 137, 25, 98, 239, 166, 19, 123, 208, 180, 31, 120, 30, 191, 75, 183, 179, 126, 180, 125, 92, 107, 105, 206, 138, 28, 67, 139, 3, 188, 230, 184, 255, 121, 13, 181, 45, 160, 114, 202, 194, 123, 87, 55, 124, 97, 164, 82, 95, 232, 216, 117, 62, 5, 90, 176, 82, 167, 52, 160, 153, 174, 168, 105, 146, 91, 248, 81, 79, 249, 97, 138, 133, 170, 245, 229, 132, 61, 5, 149, 224, 246, 194, 213, 61, 12, 109, 44, 136, 235, 95, 219, 133, 220, 27, 93, 36, 93, 124, 180, 81, 141, 152, 220, 170, 163, 229, 197, 124, 171, 232, 48, 70, 251, 106, 119, 150, 20, 16, 49, 119, 247, 42, 132, 36, 76, 254, 124, 177, 66, 175, 9, 1, 39, 92, 127, 195, 171, 198, 34, 2, 64, 144, 179, 72, 40, 151, 110, 89, 229, 42, 125, 33, 238, 16, 220, 228, 51, 203, 8, 1, 68, 145, 253, 133, 118, 93, 163, 129, 22, 13, 248, 65, 12, 4, 63, 101, 210, 70, 170, 138, 203, 14, 246, 54, 194, 195, 27, 107, 241, 175, 35, 171, 49, 52, 106, 121, 45, 36, 152, 85, 215, 132, 78, 167, 34, 18, 167, 245, 152, 133, 134, 170, 120, 182, 10, 146, 191, 37, 2, 205, 47, 125, 20, 203, 44, 88, 81, 32, 150, 223, 220, 218, 238, 254, 30, 212, 167, 221, 115, 156, 82, 226, 137, 220, 221, 97, 3, 139, 202, 33, 9, 27, 26, 126, 40, 215, 25, 126, 9, 82, 208, 49, 217, 14, 161, 81, 196, 61, 60, 87, 254, 213, 194, 81, 216, 161, 151, 209, 166, 222, 230, 24, 128, 117, 140, 92, 4, 203, 254, 170, 253, 249, 88, 90, 112, 226, 18, 44, 122, 39, 158, 158, 56, 69, 204, 159, 5, 179, 51, 197, 233, 139, 216, 102, 226, 206, 248, 15, 78, 112, 214, 126, 67, 28, 40, 38, 98, 190, 178, 206, 67, 94, 245, 254, 160, 101, 176, 32, 157, 26, 132, 83, 252, 228, 87, 242, 32, 127, 160, 112, 210, 224, 133, 149, 115, 41, 30, 16, 200, 69, 89, 81, 77, 144, 12, 106, 182, 73, 54, 28, 53, 195, 28, 216, 179, 179, 136, 35, 141, 102, 234, 177, 240, 34, 186, 106, 145, 245, 3, 84, 48, 251, 157, 245, 11, 217, 111, 227, 138, 42, 67, 114, 211, 177, 37, 103, 16, 71, 152, 72, 117, 123, 36, 213, 202, 56, 124, 227, 84, 8, 45, 229, 149, 165, 214, 69, 244, 169, 55, 68, 62, 94, 104, 228, 74, 205, 123, 222, 17, 7, 172, 158, 227, 74, 206, 149, 67, 175, 171, 251, 185, 121, 151, 223, 63, 35, 229, 32, 49, 190, 209, 120, 137, 69, 213, 214, 19, 150, 187, 177, 28, 12, 158, 153, 126, 149, 171, 167, 234, 120, 129, 109, 32, 157, 180, 75, 66, 56, 233, 115, 127, 230, 157, 32, 34, 143, 156, 31, 230, 168, 174, 125, 118, 195, 249, 243, 165, 81, 246, 10, 144, 15, 103, 139, 55, 173, 7, 59, 136, 69, 172, 54, 132, 165, 140, 78, 77, 230, 33, 169, 129, 188, 71, 209, 109, 161, 8, 57, 57, 199, 143, 31, 164, 43, 58, 130, 1, 110, 145, 31, 229, 13, 46, 149, 94, 244, 106, 76, 238, 105, 107, 1, 183, 177, 10, 61, 225, 94, 185, 116, 58, 183, 95, 225, 22, 119, 19, 248, 28, 13, 123, 125, 108, 158, 64, 184, 77, 245, 153, 162, 217, 227, 208, 41, 185, 211, 235, 41, 153, 181, 54, 166, 165, 11, 154, 55, 21, 184, 209, 192, 249, 44, 164, 160, 29, 229, 159, 82, 156, 198, 241, 183, 114, 83, 137, 186, 151, 148, 31, 21, 197, 216, 145, 32, 13, 50, 22, 241, 137, 39, 71, 28, 142, 160, 215, 107, 221, 45, 202, 104, 227, 110, 186, 12, 150, 145, 240, 51, 49, 44, 196, 115, 224, 238, 149, 189, 134, 99, 67, 241, 62, 157, 240, 114, 247, 195, 26, 200, 141, 97, 147, 249, 23, 150, 174, 10, 13, 219, 81, 73, 58, 242, 96, 250, 243, 15, 49, 218, 58, 230, 104, 252, 175, 150, 123, 86, 185, 84, 90, 198, 6, 36, 0, 99, 72, 28, 166, 238, 115, 231, 171, 249, 179, 71, 174, 68, 156, 227, 17, 198, 79, 73, 142, 99, 144, 20, 80, 62, 80, 191, 142, 46, 71, 9, 243, 6, 8, 214, 116, 72, 190, 106, 161, 19, 185, 100, 9, 187, 64, 94, 86, 203, 174, 156, 245, 222, 95, 54, 30, 148, 19, 11, 50, 112, 96, 61, 237, 159, 173, 7, 154, 127, 175, 79, 48, 97, 89, 78, 126, 66, 171, 204, 158, 195, 27, 226, 205, 222, 157, 89, 251, 90, 125, 37, 212, 27, 97, 3, 141, 247, 175, 50, 121, 7, 187, 68, 196, 181, 202, 167, 189, 57, 84, 81, 222, 23, 27, 84, 130, 176, 98, 66, 240, 207, 18, 23, 28, 163, 163, 194, 45, 37, 129, 202, 170, 97, 189, 0, 81, 238, 0, 39, 199, 163, 35, 211, 206, 247, 65, 29, 116, 242, 67, 102, 235, 13, 136, 232, 230, 114, 146, 187, 7, 254, 142, 26, 121, 16, 237, 5, 160, 201, 114, 94, 178, 199, 95, 212, 241, 45, 112, 180, 188, 72, 86, 114, 189, 155, 149, 149, 163, 210, 112, 101, 12, 69, 225, 75, 202, 223, 28, 242, 90, 215, 156, 169, 224, 245, 135, 128, 92, 148, 217, 131, 208, 255, 25, 135, 117, 136, 5, 104, 185, 249, 161, 228, 214, 16, 105, 204, 9, 182, 135, 153, 220, 101, 244, 160, 207, 58, 182, 118, 185, 240, 57, 245, 123, 13, 112, 182, 106, 229, 220, 90, 29, 86, 215, 96, 147, 232, 2, 55, 131, 225, 137, 68, 245, 89, 141, 252, 97, 3, 129, 155, 216, 223, 98, 116, 45, 78, 85, 141, 161, 74, 215, 7, 150, 171, 225, 59, 78, 221, 152, 236, 14, 117, 100, 208, 158, 86, 13, 185, 124, 87, 157, 111, 40, 187, 182, 124, 173, 71, 173, 23, 199, 52, 155, 190, 134, 11, 23, 64, 25, 215, 39, 115, 231, 173, 77, 72, 114, 54, 252, 116, 178, 59, 221, 106, 241, 119, 254, 30, 226, 241, 204, 233, 113, 197, 96, 146, 0, 41, 67, 3, 231, 126, 12, 218, 202, 22, 171, 114, 249, 176, 134, 160, 19, 216, 31, 229, 118, 226, 62, 242, 126, 126, 42, 127, 130, 68, 218, 218, 81, 202, 106, 217, 191, 25, 177, 82, 97, 81, 36, 232, 137, 58, 90, 216, 190, 117, 235, 20, 194, 144, 76, 178, 27, 213, 13, 208, 18, 29, 118, 126, 49, 98, 203, 179, 128, 237, 100, 32, 242, 189, 212, 6, 210, 210, 188, 161, 205, 13, 124, 119, 13, 215, 112, 41, 183, 176, 215, 168, 210, 182, 111, 1, 115, 2, 239, 141, 8, 177, 124, 112, 48, 197, 2, 239, 11, 99, 4, 36, 77, 69, 47, 244, 19, 153, 61, 19, 2, 96, 176, 7, 112, 122, 131, 169, 25, 189, 116, 171, 49, 12, 121, 162, 79, 154, 74, 251, 50, 233, 182, 63, 180, 224, 118, 49, 253, 21, 20, 16, 31, 144, 184, 93, 174, 231, 244, 183, 13, 49, 225, 189, 211, 73, 185, 49, 110, 142, 25, 226, 45, 176, 233, 204, 74, 33, 16, 205, 88, 131, 92, 157, 170, 175, 68, 170, 61, 53, 116, 165, 16, 27, 182, 160, 181, 87, 241, 15, 151, 85, 107, 76, 167, 129, 25, 172, 127, 184, 138, 153, 222, 228, 125, 64, 44, 45, 32, 12, 227, 148, 106, 152, 83, 240, 166, 54, 235, 32, 190, 12, 242, 164, 123, 189, 53, 194, 141, 104, 43, 202, 110, 4, 168, 119, 245, 232, 179, 178, 198, 1, 224, 87, 86, 160, 31, 19, 140, 233, 102, 191, 204, 4, 98, 138, 163, 191, 106, 24, 213, 47, 208, 82, 137, 132, 131, 16, 253, 84, 25, 144, 90, 159, 148, 16, 196, 84, 166, 61, 160, 101, 229, 227, 93, 118, 59, 87, 66, 16, 128, 59, 96, 131, 250, 20, 184, 150, 205, 91, 227, 201, 62, 35, 79, 180, 172, 173, 85, 197, 106, 153, 238, 229, 60, 204, 65, 193, 230, 94, 101, 177, 134, 6, 165, 53, 171, 142, 208, 155, 2, 11, 4, 202, 127, 54, 17, 142, 117, 227, 121, 128, 204, 192, 147, 147, 92, 189, 5, 224, 148, 72, 18, 83, 101, 126, 124, 228, 153, 242, 123, 229, 247, 92, 221, 6, 73, 227, 250, 87, 167, 194, 129, 187, 73, 38, 185, 109, 217, 240, 193, 88, 50, 178, 180, 151, 54, 197, 187, 137, 190, 166, 233, 1, 103, 204, 88, 31, 127, 185, 29, 65, 1, 29, 254, 223, 14, 83, 167, 215, 114, 248, 30, 173, 89, 173, 187, 69, 5, 105, 117, 15, 106, 94, 173, 63, 227, 25, 230, 190, 136, 168, 177, 175, 107, 91, 126, 254, 34, 188, 25, 118, 48, 12, 226, 130, 153, 162, 57, 47, 181, 212, 79, 160, 97, 64, 157, 246, 90, 53, 43, 149, 76, 102, 15, 195, 107, 58, 242, 84, 172, 29, 81, 198, 113, 81, 251, 138, 182, 154, 111, 30, 171, 129, 56, 17, 45, 214, 153, 112, 117, 203, 174, 40, 38, 234, 236, 32, 4, 112, 225, 26, 187, 195, 246, 252, 9, 218, 69, 160, 223, 178, 54, 148, 81, 8, 134, 151, 75, 248, 63, 224, 240, 48, 75, 250, 221, 85, 46, 100, 50, 3, 70, 64, 102, 111, 160, 155, 233, 59, 147, 184, 57, 61, 6, 126, 79, 176, 16, 185, 94, 166, 33, 135, 78, 42, 75, 140, 208, 140, 44, 153, 187, 64, 103, 119, 160, 236, 16, 239, 74, 218, 219, 212, 207, 110, 53, 30, 76, 248, 40, 111, 98, 44, 20, 113, 204, 233, 109, 135, 96, 107, 39, 163, 203, 125, 45, 157, 152, 71, 239, 175, 174, 159, 147, 80, 111, 93, 38, 253, 228, 154, 225, 181, 101, 12, 241, 127, 65, 49, 189, 5, 85, 151, 237, 213, 143, 14, 104, 138, 54, 52, 27, 4, 132, 67, 35, 156, 86, 157, 73, 16, 229, 222, 245, 110, 79, 165, 179, 56, 179, 53, 218, 229, 100, 58, 87, 149, 48, 231, 64, 63, 115, 67, 3, 172, 6, 186, 115, 154, 60, 53, 214, 152, 149, 89, 234, 37, 143, 82, 255, 64, 28, 183, 93, 112, 39, 70, 185, 57, 0, 199, 9, 61, 175, 219, 41, 76, 37, 176, 82, 125, 65, 53, 160, 214, 105, 62, 153, 244, 222, 96, 205, 6, 178, 85, 41, 240, 113, 0, 96, 149, 38, 3, 195, 18, 152, 41, 246, 3, 103, 29, 110, 134, 30, 101, 75, 46, 103, 199, 184, 20, 230, 8, 55, 120, 4, 229, 168, 35, 43, 7, 28, 161, 143, 87, 27, 87, 79, 255, 186, 44, 195, 158, 155, 181, 119, 81, 172, 217, 107, 95, 98, 55, 243, 186, 66, 105, 48, 224, 123, 232, 84, 156, 20, 10, 156, 208, 204, 52, 34, 228, 136, 97, 242, 200, 246, 211, 67, 202, 40, 241, 91, 92, 253, 9, 54, 72, 131, 221, 106, 178, 32, 44, 182, 4, 225, 193, 37, 20, 249, 249, 231, 10, 206, 18, 71, 254, 221, 187, 172, 88, 204, 6, 127, 138, 102, 7, 208, 75, 147, 219, 199, 177, 79, 36, 170, 101, 207, 177, 109, 95, 143, 217, 41, 199, 80, 183, 201, 2, 254, 12, 55, 23, 198, 14, 255, 69, 245, 138, 155, 129, 227, 167, 168, 130, 156, 135, 14, 96, 93, 48, 99, 143, 107, 126, 92, 117, 143, 112, 108, 193, 228, 84, 13, 41, 186, 27, 172, 92, 201, 149, 116, 19, 112, 197, 116, 209, 128, 102, 1, 55, 152, 177, 28, 37, 34, 50, 83, 41, 199, 74, 178, 59, 111, 67, 118, 35, 252, 36, 33, 87, 28, 170, 17, 215, 47, 90, 154, 124, 137, 15, 14, 211, 59, 75, 59, 30, 77, 0, 49, 37, 225, 191, 87, 101, 127, 214, 227, 160, 99, 174, 234, 82, 148, 235, 16, 241, 219, 147, 170, 127, 221, 250, 116, 39, 218, 156, 72, 227, 172, 55, 0, 79, 188, 76, 51, 222, 232, 24, 36, 62, 94, 154, 3, 61, 230, 146, 114, 253, 0, 128, 58, 253, 90, 72, 211, 242, 38, 39, 133, 153, 161, 119, 105, 195, 152, 225, 208, 105, 140, 80, 217, 186, 196, 157, 21, 116, 230, 116, 139, 25, 159, 143, 118, 128, 77, 201, 238, 247, 228, 15, 168, 4, 133, 148, 21, 148, 12, 44, 241, 7, 115, 17, 129, 176, 202, 46, 130, 122, 129, 235, 141, 223, 85, 21, 199, 65, 181, 169, 52, 174, 161, 153, 62, 25, 164, 115, 213, 89, 138, 199, 103, 79, 200, 165, 135, 249, 244, 27, 209, 178, 240, 129, 211, 61, 9, 111, 157, 147, 119, 36, 119, 255, 110, 130, 84, 49, 210, 225, 247, 100, 26, 121, 127, 163, 160, 26, 79, 99, 24, 77, 65, 32, 178, 109, 36, 27, 253, 173, 110, 183, 11, 14, 211, 57, 130, 254, 124, 104, 165, 219, 31, 70, 97, 14, 194, 39, 61, 26, 141, 125, 228, 126, 194, 184, 101, 160, 204, 106, 128, 144, 106, 103, 171, 18, 246, 129, 220, 85, 172, 151, 123, 5, 73, 155, 192, 175, 91, 157, 239, 61, 237, 116, 170, 65, 233, 56, 19, 49, 114, 168, 190, 3, 214, 53, 250, 90, 213, 244, 88, 101, 30, 229, 248, 124, 15, 71, 141, 27, 172, 235, 21, 129, 211, 72, 61, 172, 112, 170, 128, 135, 96, 196, 221, 255, 27, 176, 105, 188, 183, 121, 33, 37, 149, 53, 131, 226, 233, 29, 167, 234, 218, 109, 53, 185, 152, 36, 248, 53, 61, 235, 78, 21, 201, 214, 210, 163, 12, 251, 187, 45, 188, 137, 126, 127, 237, 92, 234, 91, 240, 225, 38, 194, 57, 213, 251, 237, 171, 30, 99, 52, 14, 49, 84, 101, 252, 237, 7, 166, 122, 114, 32, 107, 32, 207, 239, 136, 168, 178, 12, 11, 241, 233, 230, 146, 132, 18, 83, 233, 41, 172, 17, 6, 161, 42, 113, 87, 40, 255, 185, 1, 146, 128, 5, 240, 126, 131, 71, 42, 54, 124, 205, 2, 122, 71, 30, 222, 229, 40, 134, 142, 102, 97, 239, 151, 177, 1, 230, 231, 49, 123, 219, 28, 129, 91, 152, 112, 13, 154, 81, 197, 226, 255, 112, 158, 178, 177, 55, 181, 108, 138, 185, 245, 29, 186, 21, 73, 188, 209, 154, 200, 89, 116, 235, 198, 144, 36, 87, 248, 22, 7, 200, 122, 7, 148, 44, 42, 87, 140, 238, 204, 95, 231, 252, 0, 136, 0, 22, 39, 70, 123, 125, 165, 113, 227, 172, 146, 163, 128, 158, 36, 52, 91, 19, 36, 245, 27, 150, 138, 141, 11, 67, 239, 224, 65, 24, 116, 101, 7, 39, 46, 142, 172, 164, 243, 148, 0, 33, 226, 59, 47, 203, 137, 156, 241, 66, 250, 157, 30, 204, 101, 143, 134, 98, 238, 155, 226, 25, 184, 136, 219, 89, 100, 193, 11, 143, 71, 139, 243, 230, 151, 0, 249, 1, 78, 26, 32, 93, 104, 157, 67, 97, 164, 248, 86, 124, 146, 93, 74, 222, 228, 167, 55, 53, 100, 135, 216, 109, 13, 64, 37, 106, 177, 200, 200, 182, 92, 251, 69, 31, 243, 89, 80, 198, 14, 132, 203, 72, 103, 28, 104, 217, 24, 97, 223, 113, 11, 29, 178, 191, 210, 46, 162, 255, 68, 99, 8, 237, 213, 162, 152, 193, 183, 121, 203, 19, 108, 182, 29, 86, 26, 192, 103, 220, 103, 205, 154, 179, 197, 9, 22, 73, 127, 175, 146, 38, 119, 210, 0, 24, 180, 21, 245, 215, 204, 91, 186, 119, 138, 183, 239, 15, 155, 231, 248, 133, 39, 24, 101, 144, 236, 10, 230, 54, 174, 227, 73, 21, 110, 10, 160, 241, 232, 131, 14, 212, 127, 232, 59, 122, 65, 146, 54, 163, 9, 189, 190, 121, 88, 170, 62, 194, 14, 204, 152, 245, 38, 131, 37, 91, 81, 72, 114, 29, 115, 239, 182, 56, 44, 156, 159, 177, 180, 82, 160, 93, 97, 86, 183, 236, 50, 95, 85, 39, 71, 181, 225, 152, 143, 63, 123, 117, 34, 44, 109, 160, 166, 229, 240, 91, 138, 102, 54, 180, 173, 44, 50, 80, 42, 124, 7, 50, 124, 211, 239, 21, 94, 197, 185, 239, 213, 107, 142, 64, 95, 124, 125, 17, 180, 97, 189, 101, 52, 48, 19, 112, 12, 70, 9, 212, 177, 54, 118, 66, 84, 147, 236, 248, 26, 124, 95, 103, 135, 254, 124, 49, 112, 186, 99, 120, 90, 8, 194, 191, 88, 57, 242, 65, 61, 10, 104, 246, 197, 252, 19, 159, 58, 194, 75, 173, 242, 103, 8, 115, 84, 69, 238, 149, 26, 15, 159, 182, 141, 132, 119, 70, 29, 53, 20, 143, 46, 163, 204, 6, 236, 59, 45, 185, 172, 89, 119, 83, 38, 144, 36, 222, 96, 151, 26, 99, 195, 163, 170, 133, 92, 159, 214, 53, 150, 116, 90, 176, 69, 145, 130, 15, 172, 140, 217, 215, 101, 163, 115, 161, 65, 101, 8, 7, 183, 113, 213, 134, 58, 175, 130, 251, 143, 173, 248, 168, 135, 60, 159, 30, 194, 68, 208, 119, 120, 2, 40, 178, 227, 247, 161, 77, 47, 136, 46, 244, 163, 72, 65, 158, 25, 225, 195, 61, 132, 182, 204, 177, 186, 200, 81, 2, 65, 105, 212, 72, 94, 203, 232, 217, 182, 123, 251, 228, 160, 1, 161, 204, 123, 20, 37, 1, 77, 208, 179, 45, 149, 181, 122, 102, 190, 123, 213, 164, 231, 41, 216, 130, 234, 248, 208, 251, 252, 220, 84, 209, 67, 47, 61, 220, 5, 142, 162, 26, 236, 121, 142, 248, 132, 255, 65, 122, 203, 196, 102, 191, 187, 2, 195, 127, 255, 193, 92, 49, 91, 186, 154, 39, 156, 29, 211, 172, 49, 104, 245, 114, 153, 223, 211, 199, 249, 35, 130, 160, 128, 0, 152, 176, 183, 20, 236, 113, 193, 108, 26, 255, 11, 237, 102, 133, 245, 94, 115, 114, 10, 89, 229, 214, 221, 99, 149, 30, 99, 37, 246, 10, 26, 26, 39, 92, 123, 170, 73, 211, 127, 227, 54, 30, 86, 133, 159, 112, 225, 91, 148, 100, 174, 149, 75, 143, 14, 140, 20, 44, 64, 212, 5, 243, 8, 116, 63, 30, 97, 42, 123, 20, 73, 212, 85, 207, 83, 122, 27, 251, 233, 84, 10, 17, 236, 232, 83, 200, 127, 119, 143, 163, 204, 220, 167, 59, 231, 20, 106, 186, 222, 191, 8, 40, 234, 21, 25, 180, 13, 116, 250, 152, 224, 174, 75, 3, 205, 38, 173, 215, 236, 151, 185, 121, 254, 244, 154, 239, 17, 53, 106, 164, 61, 49, 116, 216, 118, 94, 150, 35, 181, 26, 238, 66, 49, 211, 221, 132, 146, 166, 115, 39, 136, 36, 205, 230, 179, 31, 197, 51, 148, 165, 109, 38, 70, 37, 148, 52, 44, 209, 250, 98, 58, 246, 225, 103, 198, 101, 26, 25, 196, 207, 8, 166, 21, 88, 252, 175, 253, 10, 88, 107, 157, 19, 225, 61, 12, 246, 221, 37, 239, 186, 167, 137, 142, 135, 222, 128, 174, 62, 95, 216, 38, 141, 157, 45, 232, 97, 217, 173, 203, 234, 116, 129, 69, 206, 189, 94, 221, 12, 54, 139, 186, 247, 184, 16, 200, 121, 244, 104, 8, 7, 35, 111, 47, 188, 10, 140, 92, 73, 143, 206, 203, 72, 122, 184, 20, 102, 197, 130, 64, 150, 63, 96, 239, 8, 132, 111, 217, 84, 91, 198, 32, 43, 100, 138, 241, 15, 160, 42, 190, 253, 193, 184, 164, 124, 29, 210, 96, 67, 224, 221, 182, 29, 218, 129, 149, 29, 128, 174, 98, 88, 88, 125, 56, 40, 255, 120, 5, 0, 87, 174, 42, 150, 90, 112, 201, 183, 169, 19, 57, 195, 191, 12, 58, 244, 235, 132, 25, 145, 72, 146, 214, 8, 125, 100, 135, 12, 5, 102, 97, 248, 174, 24, 159, 90, 33, 43, 187, 6, 61, 212, 241, 225, 190, 219, 252, 197, 123, 129, 164, 108, 123, 55, 230, 4, 153, 166, 105, 234, 15, 85, 216, 23, 56, 32, 3, 41, 110, 68, 146, 172, 133, 202, 98, 41, 7, 47, 152, 35, 255, 168, 106, 241, 226, 222, 77, 244, 52, 185, 65, 252, 227, 32, 66, 38, 11, 172, 60, 28, 28, 103, 84, 1, 1, 205, 182, 190, 28, 189, 102, 253, 43, 1, 191, 148, 116, 10, 227, 18, 81, 93, 80, 239, 157, 232, 215, 180, 163, 165, 161, 109, 177, 71, 150, 244, 144, 208, 160, 110, 22, 174, 60, 206, 43, 103, 121, 55, 103, 114, 115, 173, 238, 13, 10, 227, 251, 41, 176, 216, 158, 229, 216, 55, 234, 128, 128, 20, 167, 106, 181, 86, 163, 130, 215, 110, 149, 191, 10, 227, 215, 8, 214, 154, 178, 181, 15, 19, 0, 247, 250, 97, 74, 43, 157, 55, 94, 174, 41, 41, 9, 199, 97, 20, 91, 32, 18, 10, 43, 98, 240, 247, 203, 20, 250, 117, 160, 44, 229, 202, 187, 64, 54, 124, 15, 184, 169, 129, 27, 160, 240, 26, 61, 255, 60, 166, 60, 144, 209, 84, 55, 187, 186, 168, 13, 124, 125, 29, 17, 100, 249, 227, 62, 205, 78, 179, 163, 168, 139, 168, 21, 38, 83, 239, 151, 74, 43, 66, 2, 92, 72, 71, 94, 216, 134, 238, 20, 45, 158, 213, 164, 73, 57, 80, 47, 198, 184, 130, 223, 227, 71, 132, 133, 235, 177, 85, 174, 142, 124, 172, 200, 54, 229, 40, 126, 60, 76, 92, 216, 153, 56, 241, 174, 66, 141, 90, 226, 3, 30, 68, 234, 71, 187, 163, 112, 146, 255, 22, 143, 170, 204, 3, 127, 179, 81, 139, 160, 37, 77, 246, 128, 220, 196, 158, 153, 73, 177, 65, 199, 119, 29, 197, 144, 130, 248, 206, 155, 253, 108, 213, 124, 7, 223, 221, 162, 146, 134, 242, 65, 99, 162, 107, 120, 247, 214, 207, 96, 150, 169, 131, 208, 218, 221, 28, 24, 112, 208, 23, 1, 130, 142, 232, 56, 104, 45, 33, 158, 95, 255, 123, 31, 74, 76, 120, 178, 155, 213, 6, 195, 164, 8, 8, 69, 241, 197, 127, 83, 169, 21, 167, 19, 94, 143, 252, 33, 159, 248, 241, 170, 153, 147, 1, 149, 199, 201, 131, 170, 79, 236, 212, 209, 143, 107, 98, 24, 123, 56, 33, 193, 85, 247, 64, 225, 135, 210, 78, 145, 57, 16, 145, 71, 170, 20, 133, 87, 235, 4, 166, 239, 100, 82, 235, 81, 50, 223, 9, 193, 52, 49, 86, 129, 190, 196, 82, 165, 107, 63, 115, 161, 98, 33, 20, 193, 29, 42, 151, 205, 252, 124, 72, 245, 48, 181, 67, 7, 13, 21, 127, 59, 226, 188, 144, 129, 112, 244, 192, 121, 213, 80, 42, 196, 1, 13, 107, 108, 78, 0, 40, 121, 225, 148, 237, 234, 209, 216, 238, 9, 147, 226, 254, 96, 89, 212, 72, 193, 106, 75, 135, 74, 227, 67, 255, 92, 191, 81, 188, 124, 226, 149, 152, 142, 15, 159, 195, 238, 114, 55, 255, 166, 157, 230, 59, 148, 170, 166, 151, 65, 213, 104, 253, 253, 112, 150, 82, 147, 137, 27, 214, 100, 247, 65, 81, 92, 47, 86, 217, 7, 45, 120, 81, 130, 31, 236, 243, 76, 78, 3, 45, 105, 172, 220, 71, 48, 220, 94, 196, 249, 163, 193, 133, 50, 236, 205, 20, 55, 2, 63, 14, 127, 69, 113, 212, 204, 12, 58, 79, 89, 86, 29, 61, 199, 201, 64, 149, 6, 144, 182, 150, 129, 31, 18, 167, 120, 248, 82, 107, 25, 143, 128, 27, 161, 28, 25, 153, 183, 217, 238, 78, 186, 106, 92, 27, 202, 219, 165, 96, 0, 216, 234, 169, 73, 101, 39, 182, 113, 217, 240, 170, 116, 172, 221, 250, 233, 48, 49, 242, 83, 227, 92, 181, 184, 72, 230, 180, 21, 15, 108, 135, 25, 38, 153, 25, 124, 227, 26, 149, 73, 236, 39, 211, 244, 149, 58, 183, 132, 26, 223, 219, 174, 144, 117, 233, 219, 165, 205, 157, 159, 222, 184, 52, 47, 241, 201, 123, 65, 24, 44, 55, 215, 177, 168, 250, 179, 115, 190, 227, 123, 158, 163, 179, 224, 69, 196, 66, 207, 254, 243, 101, 221, 193, 140, 250, 4, 28, 222, 52, 96, 138, 160, 33, 218, 64, 118, 214, 234, 201, 152, 148, 91, 178, 111, 107, 144, 142, 6, 182, 102, 72, 188, 34, 213, 181, 26, 223, 58, 255, 103, 81, 17, 47, 169, 11, 245, 224, 123, 148, 215, 237, 186, 107, 75, 152, 90, 202, 166, 22, 149, 197, 5, 246, 238, 78, 76, 229, 106, 199, 94, 127, 195, 0, 45, 82, 6, 159, 103, 96, 138, 231, 71, 46, 107, 59, 216, 39, 43, 12, 221, 27, 214, 56, 155, 145, 66, 187, 169, 250, 235, 78, 211, 179, 239, 183, 198, 163, 93, 5, 196, 24, 174, 143, 225, 106, 139, 89, 98, 13, 127, 207, 184, 194, 30, 1, 165, 198, 169, 8, 197, 118, 86, 163, 221, 138, 23, 209, 61, 116, 79, 99, 233, 43, 130, 60, 244, 85, 229, 243, 172, 123, 148, 200, 120, 192, 127, 211, 52, 11, 159, 41, 95, 212, 230, 188, 169, 156, 137, 29, 212, 12, 148, 168, 148, 133, 243, 44, 241, 139, 127, 24, 246, 220, 227, 125, 209, 97, 60, 52, 162, 192, 146, 49, 161, 92, 138, 112, 189, 128, 59, 126, 125, 46, 207, 60, 79, 231, 174, 152, 209, 68, 223, 205, 2, 38, 14, 91, 116, 159, 255, 28, 27, 178, 248, 164, 104, 158, 79, 69, 214, 234, 157, 12, 75, 163, 83, 253, 245, 202, 61, 213, 176, 6, 197, 230, 29, 208, 166, 253, 194, 254, 235, 29, 141, 241, 70, 249, 15, 62, 0, 148, 163, 135, 52, 122, 40, 96, 87, 31, 179, 152, 51, 216, 133, 184, 122, 198, 203, 60, 115, 218, 191, 193, 16, 178, 25, 148, 252, 112, 104, 103, 252, 36, 92, 221, 28, 179, 43, 199, 198, 151, 128, 100, 252, 217, 161, 249, 34, 201, 172, 118, 52, 180, 252, 104, 7, 223, 44, 116, 102, 212, 21, 40, 224, 184, 55, 163, 210, 21, 207, 161, 239, 51, 54, 155, 41, 133, 18, 67, 48, 3, 165, 130, 251, 4, 79, 214, 57, 72, 130, 157, 212, 144],\n      Co = [0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 26, 29, 31, 34, 36, 39, 41, 44, 46, 49, 51, 54, 56, 59, 61, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 180, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 212, 213, 214, 215, 216, 217, 219, 220, 221, 222, 223, 224, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 239, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255],\n      Sk = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 66, 67, 68, 69, 71, 72, 73, 74, 76, 77, 78, 79, 81, 82, 83, 84, 86, 87, 88, 90, 91, 92, 93, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 107, 108, 110, 111, 112, 113, 115, 116, 117, 118, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132, 134, 135, 136, 137, 139, 140, 141, 142, 144, 145, 146, 147, 149, 150, 151, 152, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165, 166, 168, 169, 170, 171, 173, 174, 175, 176, 178, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 195, 197, 198, 199, 200, 202, 203, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 219, 220, 222, 223, 224, 226, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255],\n      Do = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 72, 73, 74, 76, 77, 78, 80, 81, 83, 84, 85, 87, 88, 89, 91, 92, 94, 95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 127, 128, 129, 131, 132, 133, 135, 136, 138, 139, 140, 142, 143, 144, 146, 147, 149, 150, 151, 153, 154, 155, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 205, 205, 206, 207, 207, 208, 209, 209, 210, 211, 211, 212, 213, 213, 214, 215, 215, 216, 217, 217, 218, 219, 219, 220, 221, 221, 222, 223, 223, 224, 225, 225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235, 235, 236, 237, 237, 238, 239, 239, 240, 241, 241, 242, 243, 243, 244, 245, 245, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252, 253, 253, 254, 255];\n\n  class Eo extends Nb {\n    constructor(a, b, c, e) {\n      super(a, Bo, c, e);\n      this.lightLevel = .1;\n      this.rednessLevel = .5;\n      this.mskin_he_max = 175 / 180 * 3.141593;\n      this.mskin_he_min = 115 / 180 * 3.141593;\n      this.mskin_hc_max = 173 / 180 * 3.141593;\n      this.mskin_hc_min = 116 / 180 * 3.141593;\n      this.mskin_hc_axis = 2.04203545;\n      this.mfacts_rotate_ge = this.mfacts_rotate_le = this.mfacts_rotate_c = 0;\n      this.tab_addr = null;\n      this.lutTextures = [];\n      this.inputTexture = b;\n      this.init();\n    }\n\n    setUniforms() {\n      var a = this.gl.getUniformLocation(this.program, \"u_flipY\"),\n          b = this.gl.getUniformLocation(this.program, \"u_denoiseLevel\");\n      this.gl.uniform1f(b, this.denoiseLevel);\n      this.gl.uniform1f(a, 1);\n      a = this.gl.getUniformLocation(this.program, \"light\");\n      this.gl.uniform1f(a, this.lightLevel);\n      a = this.gl.getUniformLocation(this.program, \"redness\");\n      this.gl.uniform1f(a, this.rednessLevel);\n      a = this.gl.getUniformLocation(this.program, \"skin_he_max\");\n      b = this.gl.getUniformLocation(this.program, \"skin_he_min\");\n      var c = this.gl.getUniformLocation(this.program, \"skin_hc_max\"),\n          e = this.gl.getUniformLocation(this.program, \"skin_hc_min\");\n      let g = this.gl.getUniformLocation(this.program, \"skin_hc_axis\"),\n          h = this.gl.getUniformLocation(this.program, \"facts_rotate_c\"),\n          k = this.gl.getUniformLocation(this.program, \"facts_rotate_le\"),\n          l = this.gl.getUniformLocation(this.program, \"facts_rotate_ge\");\n      this.gl.uniform1f(a, this.mskin_he_max);\n      this.gl.uniform1f(b, this.mskin_he_min);\n      this.gl.uniform1f(c, this.mskin_hc_max);\n      this.gl.uniform1f(e, this.mskin_hc_min);\n      this.gl.uniform1f(g, this.mskin_hc_axis);\n      this.gl.uniform1f(h, this.mfacts_rotate_c);\n      this.gl.uniform1f(k, this.mfacts_rotate_le);\n      this.gl.uniform1f(l, this.mfacts_rotate_ge);\n      a = this.gl.getUniformLocation(this.program, \"u_originImage\");\n      this.gl.activeTexture(this.gl.TEXTURE2);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture);\n      this.gl.uniform1i(a, 2);\n      a = [\"lighten_lut\"];\n      b = [this.gl.TEXTURE3];\n\n      for (c = 0; c < a.length; c++) e = this.gl.getUniformLocation(this.program, a[c]), this.gl.activeTexture(b[c]), this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[c]), this.gl.uniform1i(e, c + 3);\n    }\n\n    setParameters(a) {\n      void 0 !== a.denoiseLevel && (this.denoiseLevel = a.denoiseLevel);\n      void 0 !== a.lightLevel && (this.lightLevel = a.lightLevel);\n      void 0 !== a.rednessLevel && (this.rednessLevel = a.rednessLevel, this.updateRedness(this.rednessLevel));\n      a.lighteningContrastLevel && this.updateLut(a.lighteningContrastLevel);\n    }\n\n    init() {\n      this.tab_addr = new Uint8Array(Sk);\n      let a = [this.tab_addr],\n          b = [256],\n          c = [1];\n\n      for (let e = 0; e < a.length; e++) {\n        let g = this.gl.createTexture();\n        if (!g) throw new n(l.WEBGL_INTERNAL_ERROR, \"create lut texture failed\");\n        this.gl.bindTexture(this.gl.TEXTURE_2D, g);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, b[e], c[e], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, a[e]);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        this.lutTextures.push(g);\n      }\n    }\n\n    updateRedness(a) {\n      var b = a;\n      1 < a && (a = 1);\n      0 > a && (a = 0);\n      1 < b && (b = 1);\n      0 > b && (b = 0);\n      this.mfacts_rotate_c = .8 * a;\n      .8 > b && (b = 0);\n      this.mskin_he_max = 175 / 180 * 3.141593;\n      this.mskin_hc_max = 173 / 180 * 3.141593;\n      this.mskin_he_min = (115 - 4 * b) / 180 * 3.141593;\n      this.mskin_hc_min = (116 - 4 * b) / 180 * 3.141593;\n      this.mskin_hc_axis = (117 - 4 * b) / 180 * 3.141593;\n      this.mskin_hc_axis < this.mskin_hc_min && (this.mskin_hc_axis = this.mskin_hc_min);\n      1.5707965 > this.mskin_hc_min && (this.mskin_hc_min = 1.5707965);\n      1.5707965 > this.mskin_hc_axis && (this.mskin_hc_axis = 1.5707965);\n      1.5707965 > this.mskin_he_min && (this.mskin_he_min = 1.5707965);\n      3.141593 < this.mskin_hc_max && (this.mskin_hc_max = 3.141593);\n      3.141593 < this.mskin_hc_axis && (this.mskin_hc_axis = 3.141593);\n      3.141593 < this.mskin_he_max && (this.mskin_he_max = 3.141593);\n      a = this.mskin_he_max - this.mskin_hc_max;\n      b = this.mskin_hc_max - this.mskin_hc_axis;\n      this.mfacts_rotate_ge = .01 < a ? this.mfacts_rotate_c * b / a : this.mfacts_rotate_c;\n      a = this.mskin_hc_min - this.mskin_he_min;\n      b = this.mskin_hc_axis - this.mskin_hc_min;\n      this.mfacts_rotate_le = .01 < a ? this.mfacts_rotate_c * b / a : this.mfacts_rotate_c;\n    }\n\n    updateLut(a) {\n      var b = null;\n      if (0 === a && (b = Sk), 1 === a && (b = Do), 2 === a && (b = Co), !b) throw new n(l.WEBGL_INTERNAL_ERROR, \"invalid ylut_table value:\" + a);\n      this.tab_addr = new Uint8Array(b);\n      a = [this.tab_addr];\n      b = [256];\n      let c = [1];\n\n      for (let e = 0; e < a.length; e++) this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e]), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, b[e], c[e], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, a[e]);\n    }\n\n  }\n\n  class Fo {\n    constructor() {\n      this.canvas = this.gl = null;\n      this.programs = [];\n      this.inputTexture = this.commonProgram = null;\n      this.outputTextures = [];\n      this.fbos = [];\n      this.originalFrameHeight = this.originalFrameWidth = 0;\n      this.enableBeauty = !1;\n      this.denoiseLevel = 5;\n      this.lightLevel = .35;\n      this.rednessLevel = .5;\n      this.lighteningContrastLevel = 1;\n    }\n\n    setEnableBeauty(a) {\n      this.enableBeauty = !!a;\n    }\n\n    init(a, b, c) {\n      if (!ha.supportWebGL) throw new n(l.NOT_SUPPORTED, \"your browser is not support webGL\");\n      if (this.gl = c.getContext(\"webgl\"), !this.gl) throw new n(l.WEBGL_INTERNAL_ERROR, \"can not get webgl context\");\n      if (this.initGL(a, b), !this.inputTexture) throw new n(l.WEBGL_INTERNAL_ERROR, \"can not find input texture\");\n      this.canvas = c;\n      this.programs.push(new Rk(this.gl));\n      this.programs.push(new wo(this.gl, a, b));\n      this.programs.push(new yo(this.gl, a, b));\n      this.programs.push(new Ao(this.gl, a, b));\n      this.programs.push(new Eo(this.gl, this.inputTexture, a, b));\n      this.commonProgram = this.programs[0].program;\n      this.setDenoiseLevel(this.denoiseLevel);\n      this.setLightLevel(this.lightLevel);\n      this.setRednessLevel(this.rednessLevel);\n      this.setContrastLevel(this.lighteningContrastLevel);\n    }\n\n    render(a) {\n      if (!this.gl || !this.commonProgram || !this.canvas) return void k.warning(\"video effect manager is not init!\");\n      var b = 0;\n      if (this.originalFrameHeight === a.videoWidth && this.originalFrameWidth === a.videoHeight) b = 2;else if (this.originalFrameHeight !== a.videoHeight || this.originalFrameWidth !== a.videoWidth) {\n        var c, e, g;\n        if (k.debug(m(c = m(e = m(g = \"beauty effect: resolution changed \".concat(this.originalFrameWidth, \"x\")).call(g, this.originalFrameHeight, \" -> \")).call(e, a.videoWidth, \"x\")).call(c, a.videoHeight)), 0 === a.videoHeight || 0 === a.videoWidth) return void k.debug(\"beauty effect: skip 0 resolution frame\");\n        this.canvas.width = a.videoWidth;\n        this.canvas.height = a.videoHeight;\n        a.setAttribute(\"width\", a.videoWidth.toString());\n        a.setAttribute(\"height\", a.videoHeight.toString());\n        this.release();\n        this.init(a.videoWidth, a.videoHeight, this.canvas);\n      }\n      this.gl.viewport(0, 0, a.videoWidth, a.videoHeight);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture);\n      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, a);\n      a = this.enableBeauty ? this.programs.length - 1 : 0;\n\n      for (c = 0; c <= a; c++) e = this.programs[c].program, this.gl.useProgram(e), e = this.gl.getUniformLocation(e, \"u_image\"), this.programs[c].setUniforms(), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbos[b + c % 2]), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.outputTextures[b + c % 2]), this.gl.uniform1i(e, 0);\n\n      this.gl.useProgram(this.commonProgram);\n      b = this.gl.getUniformLocation(this.commonProgram, \"u_flipY\");\n      this.gl.uniform1f(b, -1);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.clearColor(0, 0, 0, 1);\n      this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    }\n\n    setDenoiseLevel(a) {\n      var b;\n      q(b = this.programs).call(b, b => {\n        b instanceof Nb && b.setParameters({\n          denoiseLevel: a\n        });\n      });\n      this.denoiseLevel = a;\n    }\n\n    setLightLevel(a) {\n      var b;\n      q(b = this.programs).call(b, b => {\n        b instanceof Nb && b.setParameters({\n          lightLevel: a\n        });\n      });\n      this.lightLevel = a;\n    }\n\n    setRednessLevel(a) {\n      var b;\n      q(b = this.programs).call(b, b => {\n        b instanceof Nb && b.setParameters({\n          rednessLevel: a\n        });\n      });\n      this.rednessLevel = a;\n    }\n\n    setContrastLevel(a) {\n      var b;\n      q(b = this.programs).call(b, b => {\n        b instanceof Nb && b.setParameters({\n          lighteningContrastLevel: a\n        });\n      });\n      this.lighteningContrastLevel = a;\n    }\n\n    setSize(a, b) {\n      var c;\n      q(c = this.programs).call(c, c => {\n        c instanceof Nb && c.setSize(a, b);\n      });\n    }\n\n    release() {\n      this.inputTexture = this.commonProgram = this.gl = null;\n      this.programs = [];\n      this.outputTextures = [];\n      this.fbos = [];\n    }\n\n    initGL(a, b) {\n      if (!this.gl) throw new n(l.WEBGL_INTERNAL_ERROR, \"can not find webgl context\");\n      this.inputTexture = this.gl.createTexture();\n      this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n\n      for (let c = 0; 4 > c; c++) {\n        let e = this.gl.createTexture();\n        if (!e) throw new n(l.WEBGL_INTERNAL_ERROR, \"create texture failed\");\n        this.gl.bindTexture(this.gl.TEXTURE_2D, e);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        2 > c ? this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, a, b, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null) : this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, b, a, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);\n        let g = this.gl.createFramebuffer();\n        if (!g) throw new n(l.WEBGL_INTERNAL_ERROR, \"create frame buffer failed\");\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, g);\n        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, e, 0);\n        this.outputTextures.push(e);\n        this.fbos.push(g);\n      }\n\n      this.gl.viewport(0, 0, a, b);\n      this.originalFrameWidth = a;\n      this.originalFrameHeight = b;\n    }\n\n  }\n\n  class Go {\n    constructor() {\n      this.recordedFrameCount = this.targetFrameRate = 0;\n      this.recordingTime = 2;\n    }\n\n    startRecordBeautyEffectOutput(a, b = 4) {\n      var _this51 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this51.recordID) throw new n(l.UNEXPECTED_ERROR, \"another beauty effect recording is in progress\");\n        let c = qa(6, \"\");\n        return _this51.recordID = c, _this51.targetFrameRate = a, _this51.recordedFrameCount = 0, _this51.recordingTime = b, yield wb(1E3 * _this51.recordingTime), _this51.recordID !== c ? (_this51.recordID = void 0, !0) : (_this51.recordID = void 0, _this51.recordedFrameCount < _this51.targetFrameRate * _this51.recordingTime / 2 ? (k.warning(\"detect beauty effect overload, current framerate\", _this51.recordedFrameCount / 2), !1) : (k.debug(\"beauty effect current framerate\", _this51.recordedFrameCount / 2), !0));\n      })();\n    }\n\n    stopRecordBeautyEffectOutput() {\n      this.recordedFrameCount = this.targetFrameRate = 0;\n      this.recordID = void 0;\n    }\n\n    addFrame() {\n      this.recordID && (this.recordedFrameCount += 1);\n    }\n\n  }\n\n  class Ho extends class {\n    get output() {\n      return this._output;\n    }\n\n    setInput(a) {\n      var _this57 = this;\n\n      return _asyncToGenerator(function* () {\n        if (a !== _this57.input) {\n          if (a.kind !== _this57.kind) throw new n(l.UNEXPECTED_ERROR);\n          _this57.input && _this57.removeInput();\n          _this57.input = a;\n          yield _this57._setInput(a);\n        }\n      })();\n    }\n\n    removeInput() {\n      this.input = void 0;\n\n      this._removeInput();\n    }\n\n    updateOutput(a) {\n      var _this58 = this;\n\n      return _asyncToGenerator(function* () {\n        _this58.output !== a && (_this58._output = a, _this58.onOutputChange && (yield _this58.onOutputChange()));\n      })();\n    }\n\n    replaceOriginMediaStream(a, b) {\n      var c, e;\n      let g = R(c = a.getTracks()).call(c, a => a.kind === this.kind);\n      g && a.removeTrack(g);\n      b = R(e = b.getTracks()).call(e, a => a.kind === this.kind);\n      void 0 === this.output && b && a.addTrack(b);\n      this.output && (k.debug(\"replace \".concat(this.output.kind, \" track to origin media stream\")), a.addTrack(this.output));\n    }\n\n  } {\n    constructor() {\n      super();\n      this.kind = \"video\";\n      this.fps = 15;\n      this.overloadDetector = new Go();\n      this.enabled = !1;\n      this.stopChromeBackgroundLoop = null;\n      this.lastRenderTime = 0;\n      this.fps = 30;\n      this.manager = new Fo();\n    }\n\n    setBeautyEffectOptions(a, b) {\n      var _this52 = this;\n\n      return _asyncToGenerator(function* () {\n        void 0 !== b.smoothnessLevel && W(b.smoothnessLevel, \"options.smoothnessLevel\", 0, 1, !1);\n        void 0 !== b.lighteningLevel && W(b.lighteningLevel, \"options.lighteningLevel\", 0, 1, !1);\n        void 0 !== b.rednessLevel && W(b.rednessLevel, \"options.rednessLevel\", 0, 1, !1);\n        void 0 !== b.lighteningContrastLevel && Ka(b.lighteningContrastLevel, \"options.lighteningContrastLevel\", [0, 1, 2]);\n        void 0 !== b.smoothnessLevel && _this52.manager.setDenoiseLevel(Math.max(.1, 10 * b.smoothnessLevel));\n        void 0 !== b.lighteningLevel && _this52.manager.setLightLevel(Math.max(.1, b.lighteningLevel / 2));\n        void 0 !== b.rednessLevel && _this52.manager.setRednessLevel(Math.max(.01, b.rednessLevel));\n        void 0 !== b.lighteningContrastLevel && _this52.manager.setContrastLevel(b.lighteningContrastLevel);\n        _this52.enabled !== a && (_this52.manager.setEnableBeauty(a), _this52.enabled = a, a ? _this52.input && (yield _this52.startEffect()) : yield _this52.stopEffect());\n      })();\n    }\n\n    destroy() {\n      this.onOutputChange = void 0;\n      this.stopEffect();\n      this.enabled = !1;\n    }\n\n    startEffect() {\n      var _this53 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = na();\n        if (!_this53.input) return void k.warning(\"video track is null, fail to start video effect!\");\n        if (_this53.output) return void k.warning(\"video effect is already enabled\");\n        let b = yield _this53.renderWithWebGL();\n        yield _this53.updateOutput(b);\n        k.info(\"start video effect, output:\", _this53.output);\n\n        _this53.overloadDetector.startRecordBeautyEffectOutput(_this53.fps).then(a => {\n          a || _this53.onOverload && _this53.onOverload();\n        });\n\n        let c = () => {\n          requestAnimationFrame(c);\n          const a = x(),\n                b = 1E3 / _this53.fps,\n                h = _this53.lastRenderTime ? a - _this53.lastRenderTime : b;\n          h < b || (_this53.lastRenderTime = a - (h - b), _this53.video && _this53.video.paused && _this53.video.play(), _this53.enabled && _this53.video && (_this53.manager.render(_this53.video), _this53.output && _this53.output.requestFrame && _this53.output.requestFrame(), _this53.overloadDetector.addFrame()));\n        };\n\n        requestAnimationFrame(c);\n        a.name === ca.CHROME && document.addEventListener(\"visibilitychange\", () => {\n          document.hidden ? _this53.stopChromeBackgroundLoop = Le(() => {\n            _this53.enabled && _this53.video && _this53.manager.render(_this53.video);\n            _this53.output && _this53.output.requestFrame && _this53.output.requestFrame();\n\n            _this53.overloadDetector.addFrame();\n          }, _this53.fps) : _this53.stopChromeBackgroundLoop && (_this53.stopChromeBackgroundLoop(), _this53.stopChromeBackgroundLoop = null);\n        }, !1);\n      })();\n    }\n\n    stopEffect() {\n      var _this54 = this;\n\n      return _asyncToGenerator(function* () {\n        k.info(\"stop video effect\");\n\n        _this54.overloadDetector.stopRecordBeautyEffectOutput();\n\n        _this54.manager.release();\n\n        _this54.canvas && _this54.canvas.remove();\n        _this54.video && _this54.video.remove();\n        _this54.video = _this54.canvas = void 0;\n        yield _this54.updateOutput(void 0);\n      })();\n    }\n\n    _setInput(a) {\n      var _this55 = this;\n\n      return _asyncToGenerator(function* () {\n        _this55.enabled && !_this55.video && (yield _this55.startEffect());\n      })();\n    }\n\n    _removeInput() {\n      this.stopEffect();\n    }\n\n    renderWithWebGL() {\n      var _this56 = this;\n\n      return _asyncToGenerator(function* () {\n        var a;\n        if (!_this56.input) throw new n(l.BEAUTY_PROCESSOR_INTERNAL_ERROR, \"can not renderWithWebGL, no input\");\n        _this56.canvas && (_this56.canvas.remove(), _this56.canvas = void 0);\n        _this56.video && (_this56.video.remove(), _this56.video = void 0);\n        _this56.canvas = document.createElement(\"canvas\");\n        _this56.video = document.createElement(\"video\");\n\n        _this56.video.setAttribute(\"autoplay\", \"\");\n\n        _this56.video.setAttribute(\"muted\", \"\");\n\n        _this56.video.muted = !0;\n\n        _this56.video.setAttribute(\"playsinline\", \"\");\n\n        _this56.video.setAttribute(\"style\", \"display:none\");\n\n        _this56.video.srcObject = new MediaStream([_this56.input]);\n        var b = new A(a => {\n          const b = () => {\n            _this56.video && _this56.video.removeEventListener(\"playing\", b);\n            a(void 0);\n          };\n\n          _this56.video && _this56.video.addEventListener(\"playing\", b);\n        });\n\n        _this56.video.play();\n\n        yield b;\n        b = _this56.input.getSettings();\n        let c = b.width || _this56.video.videoWidth,\n            e = b.height || _this56.video.videoHeight;\n        if (b.frameRate && _this56.fps !== b.frameRate && (_this56.fps = b.frameRate, k.debug(\"beauty video processor: set fps to\", _this56.fps)), k.debug(m(a = \"beauty video processor: width \".concat(c, \" height \")).call(a, e)), !c || !e) throw new n(l.BEAUTY_PROCESSOR_INTERNAL_ERROR, \"can not get track resolution\");\n        _this56.canvas.width = c;\n        _this56.canvas.height = e;\n\n        _this56.video.setAttribute(\"width\", c.toString());\n\n        _this56.video.setAttribute(\"height\", e.toString());\n\n        _this56.manager.init(c, e, _this56.canvas);\n\n        return _this56.canvas.captureStream(ha.supportRequestFrame ? 0 : _this56.fps).getVideoTracks()[0];\n      })();\n    }\n\n  }\n\n  class Ma extends ne {\n    constructor(a, b, c, e, g) {\n      super(a, g);\n      this.trackMediaType = \"video\";\n      this._scalabiltyMode = {\n        numSpatialLayers: 1,\n        numTemporalLayers: 1\n      };\n      this._enabled = !0;\n      this.updateMediaStreamTrackResolution();\n      this._encoderConfig = b;\n      this._scalabiltyMode = c;\n      this._optimizationMode = e;\n    }\n\n    get isPlaying() {\n      return !(!this._player || this._player.videoElementStatus !== Ba.PLAYING);\n    }\n\n    play(a, b = {}) {\n      let c = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.LOCAL_VIDEO_TRACK_PLAY,\n        options: [this.getTrackId(), \"string\" == typeof a ? a : \"HTMLElement\", b]\n      });\n\n      if (!(a instanceof HTMLElement)) {\n        let b = document.getElementById(a.toString());\n        var e;\n        b ? a = b : (k.warning(m(e = \"[track-\".concat(this.getTrackId(), '] can not find \"#')).call(e, a, '\" element, use document.body')), a = document.body);\n      }\n\n      k.debug(\"[track-\".concat(this.getTrackId(), \"] start video playback\"), w(b));\n      a = Id({}, this._getDefaultPlayerConfig(), {}, b, {\n        trackId: this.getTrackId(),\n        element: a\n      });\n      this._player ? this._player.updateConfig(a) : (this._player = new Pk(a), this._player.updateVideoTrack(this._mediaStreamTrack));\n\n      this._player.play();\n\n      c.onSuccess();\n    }\n\n    stop() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.LOCAL_VIDEO_TRACK_STOP,\n        options: [this.getTrackId()]\n      });\n      if (!this._player) return a.onSuccess();\n\n      this._player.destroy();\n\n      this._player = void 0;\n      k.debug(\"[track-\".concat(this.getTrackId(), \"] stop video playback\"));\n      a.onSuccess();\n    }\n\n    setEnabled(a) {\n      var _this59 = this;\n\n      return _asyncToGenerator(function* () {\n        if (a !== _this59._enabled) {\n          k.info(\"[\".concat(_this59.getTrackId(), \"] start setEnabled\"), a);\n          var b = yield _this59._enabledMutex.lock();\n\n          if (!a) {\n            _this59._originMediaStreamTrack.enabled = !1;\n\n            try {\n              yield Pa(_this59, M.NEED_REMOVE_TRACK, _this59);\n            } catch (c) {\n              throw k.error(\"[\".concat(_this59.getTrackId(), \"] setEnabled to false error\"), c.toString()), b(), c;\n            }\n\n            return _this59._enabled = !1, k.info(\"[\".concat(_this59.getTrackId(), \"] setEnabled to false success\")), b();\n          }\n\n          _this59._originMediaStreamTrack.enabled = !0;\n\n          try {\n            yield Pa(_this59, M.NEED_ADD_TRACK, _this59);\n          } catch (c) {\n            throw k.error(\"[\".concat(_this59.getTrackId(), \"] setEnabled to true error\"), c.toString()), b(), c;\n          }\n\n          k.info(\"[\".concat(_this59.getTrackId(), \"] setEnabled to true success\"));\n          _this59._enabled = !0;\n          b();\n        }\n      })();\n    }\n\n    getStats() {\n      Oc(() => {\n        k.warning(\"[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead\");\n      }, \"localVideoTrackGetStatsWarning\");\n      return Zb(this, M.GET_STATS) || Id({}, le);\n    }\n\n    setBeautyEffect(a, b = {}) {\n      var _this60 = this;\n\n      return _asyncToGenerator(function* () {\n        let c = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.LOCAL_VIDEO_TRACK_BEAUTY,\n          options: [_this60.getTrackId(), a, b]\n        });\n\n        if (a || _this60._videoBeautyProcessor) {\n          if (na().os === X.IOS || na().os === X.ANDROID) throw a = new n(l.INVALID_OPERATION, \"can not enable beauty effect on mobile device\"), c.onError(a), a;\n          if (!_this60._enabled && a) throw a = new n(l.TRACK_IS_DISABLED, \"can not enable beauty effect when track is disabled\"), c.onError(a), a;\n          k.info(\"[\".concat(_this60.getTrackId(), \"] start setBeautyEffect\"), a, w(b));\n\n          try {\n            _this60._videoBeautyProcessor ? yield _this60._videoBeautyProcessor.setBeautyEffectOptions(a, b) : (_this60._videoBeautyProcessor = new Ho(), _this60._videoBeautyProcessor.onOverload = () => {\n              Za(() => _this60.emit(fd.BEAUTY_EFFECT_OVERLOAD));\n            }, yield _this60._videoBeautyProcessor.setBeautyEffectOptions(a, b), yield _this60._registerTrackProcessor(_this60._videoBeautyProcessor));\n          } catch (e) {\n            throw k.error(\"[\".concat(_this60.getTrackId(), \"] setBeautyEffect error\"), e.toString()), c.onError(e), e;\n          }\n\n          k.info(\"[\".concat(_this60.getTrackId(), \"] setBeautyEffect success\"));\n          c.onSuccess();\n        }\n      })();\n    }\n\n    getCurrentFrameData() {\n      return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n    }\n\n    clone(a, b, c, e) {\n      let g = this._mediaStreamTrack.clone();\n\n      return new Ma(g, a, b, c, e);\n    }\n\n    setBitrateLimit(a) {\n      var _this61 = this;\n\n      return _asyncToGenerator(function* () {\n        var b;\n\n        if (k.debug(m(b = \"[\".concat(_this61.getTrackId(), \"] set bitrate limit, \")).call(b, w(a))), a) {\n          _this61._forceBitrateLimit = a;\n          _this61._encoderConfig && (_this61._encoderConfig.bitrateMax ? _this61._encoderConfig.bitrateMax = _this61._encoderConfig.bitrateMax < a.max_bitrate ? _this61._encoderConfig.bitrateMax : a.max_bitrate : _this61._encoderConfig.bitrateMax = a.max_bitrate, _this61._encoderConfig.bitrateMin, _this61._encoderConfig.bitrateMin = a.min_bitrate);\n\n          try {\n            yield Pa(_this61, M.NEED_RESET_REMOTE_SDP);\n          } catch (c) {\n            return c.throw();\n          }\n        }\n      })();\n    }\n\n    setOptimizationMode(a) {\n      var _this62 = this;\n\n      return _asyncToGenerator(function* () {\n        var b;\n\n        if (\"motion\" === a || \"detail\" === a || \"balanced\" === a) {\n          try {\n            _this62._optimizationMode = a, yield Pa(_this62, M.SET_OPTIMIZATION_MODE, a);\n          } catch (c) {\n            throw k.error(\"[\".concat(_this62.getTrackId(), \"] set optimization mode failed\"), c.toString()), c;\n          }\n\n          k.info(m(b = \"[\".concat(_this62.getTrackId(), \"] set optimization mode success (\")).call(b, a, \")\"));\n        } else k.error(l.INVALID_PARAMS, \"optimization mode must be motion, detail or balanced\");\n      })();\n    }\n\n    setScalabiltyMode(a) {\n      var b;\n      if (1 === a.numSpatialLayers && 1 !== a.numTemporalLayers) return k.error(l.INVALID_PARAMS, \"scalability mode currently not supported, no SVC.\"), void (this._scalabiltyMode = {\n        numSpatialLayers: 1,\n        numTemporalLayers: 1\n      });\n      this._scalabiltyMode = a;\n      k.info(m(b = \"[\".concat(this.getTrackId(), \"] set scalability mode success (\")).call(b, a, \")\"));\n    }\n\n    updateMediaStreamTrackResolution() {\n      ph(this._originMediaStreamTrack).then(([a, b]) => {\n        this._videoHeight = b;\n        this._videoWidth = a;\n      }).catch(bg);\n    }\n\n    _updatePlayerSource() {\n      this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n    }\n\n    _getDefaultPlayerConfig() {\n      return {\n        fit: \"contain\"\n      };\n    }\n\n  }\n\n  class Tk extends Ma {\n    constructor(a, b, c, e, g, h) {\n      super(a, b.encoderConfig ? kc(b.encoderConfig) : {}, e, g, h);\n      this._enabled = !0;\n      this._deviceName = \"default\";\n      this._config = b;\n      this._constraints = c;\n      this._deviceName = a.label;\n      this._config.encoderConfig && (this._encoderConfig = kc(this._config.encoderConfig));\n    }\n\n    setDevice(a) {\n      var _this63 = this;\n\n      return _asyncToGenerator(function* () {\n        var b;\n        let c = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CAM_VIDEO_TRACK_SET_DEVICE,\n          options: [_this63.getTrackId(), a]\n        });\n        if (k.info(m(b = \"[track-\".concat(_this63.getTrackId(), \"] set device to \")).call(b, a)), _this63._enabled) try {\n          let c = yield cb.getDeviceById(a);\n          b = {};\n          b.video = Id({}, _this63._constraints);\n          b.video.deviceId = {\n            exact: a\n          };\n          b.video.facingMode = void 0;\n\n          _this63._originMediaStreamTrack.stop();\n\n          let g = null;\n\n          try {\n            g = yield xb(b, _this63.getTrackId());\n          } catch (h) {\n            throw k.error(\"[\".concat(_this63.getTrackId(), \"] setDevice failed\"), h.toString()), g = yield xb({\n              video: _this63._constraints\n            }, _this63.getTrackId()), yield _this63._updateOriginMediaStreamTrack(g.getVideoTracks()[0], !1), h;\n          }\n\n          yield _this63._updateOriginMediaStreamTrack(g.getVideoTracks()[0], !1);\n\n          _this63.updateMediaStreamTrackResolution();\n\n          _this63._deviceName = c.label;\n          _this63._config.cameraId = a;\n          _this63._constraints.deviceId = {\n            exact: a\n          };\n        } catch (e) {\n          throw c.onError(e), k.error(\"[\".concat(_this63.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        } else try {\n          _this63._deviceName = (yield cb.getDeviceById(a)).label, _this63._config.cameraId = a, _this63._constraints.deviceId = {\n            exact: a\n          };\n        } catch (e) {\n          throw c.onError(e), k.error(\"[track-\".concat(_this63.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        }\n        k.info(\"[\".concat(_this63.getTrackId(), \"] setDevice success\"));\n        c.onSuccess();\n      })();\n    }\n\n    setEnabled(a) {\n      var _this64 = this;\n\n      return _asyncToGenerator(function* () {\n        if (a !== _this64._enabled) {\n          k.info(\"[\".concat(_this64.getTrackId(), \"] start setEnabled\"), a);\n          var b = yield _this64._enabledMutex.lock();\n\n          if (!a) {\n            _this64._originMediaStreamTrack.onended = null;\n\n            _this64._originMediaStreamTrack.stop();\n\n            _this64._enabled = !1;\n\n            try {\n              yield Pa(_this64, M.NEED_REMOVE_TRACK, _this64);\n            } catch (e) {\n              throw k.error(\"[\".concat(_this64.getTrackId(), \"] setEnabled to false error\"), e.toString()), b(), e;\n            }\n\n            return k.info(\"[\".concat(_this64.getTrackId(), \"] setEnabled to false success\")), b();\n          }\n\n          a = Id({}, _this64._constraints);\n          var c = cb.searchDeviceIdByName(_this64._deviceName);\n          c && !a.deviceId && (a.deviceId = {\n            exact: c\n          });\n\n          try {\n            let a = yield xb({\n              video: _this64._constraints\n            }, _this64.getTrackId());\n            yield _this64._updateOriginMediaStreamTrack(a.getVideoTracks()[0], !1);\n            yield Pa(_this64, M.NEED_ADD_TRACK, _this64);\n          } catch (e) {\n            throw k.error(\"[\".concat(_this64.getTrackId(), \"] setEnabled true error\"), e.toString()), b(), e;\n          }\n\n          _this64.updateMediaStreamTrackResolution();\n\n          k.info(\"[\".concat(_this64.getTrackId(), \"] setEnabled to true success\"));\n          _this64._enabled = !0;\n          b();\n        }\n      })();\n    }\n\n    setEncoderConfiguration(a, b) {\n      var _this65 = this;\n\n      return _asyncToGenerator(function* () {\n        b = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG,\n          options: [_this65.getTrackId(), a]\n        });\n        if (!_this65._enabled) throw a = new n(l.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\"), b.onError(a), a;\n        a = kc(a);\n        _this65._forceBitrateLimit && (a.bitrateMax = _this65._forceBitrateLimit.max_bitrate ? _this65._forceBitrateLimit.max_bitrate : a.bitrateMax, a.bitrateMin = _this65._forceBitrateLimit.min_bitrate ? _this65._forceBitrateLimit.min_bitrate : a.bitrateMin);\n        let c = (e = _this65._config, JSON.parse(w(e)));\n        var e;\n        c.encoderConfig = a;\n        e = Ve(c);\n        k.debug(\"[\".concat(_this65.getTrackId(), \"] setEncoderConfiguration applyConstraints\"), w(a), w(e));\n\n        try {\n          yield _this65._originMediaStreamTrack.applyConstraints(e), _this65.updateMediaStreamTrackResolution();\n        } catch (g) {\n          throw a = new n(l.UNEXPECTED_ERROR, g.toString()), k.error(\"[track-\".concat(_this65.getTrackId(), \"] applyConstraints error\"), a.toString()), b.onError(a), a;\n        }\n\n        _this65._config = c;\n        _this65._constraints = e;\n        _this65._encoderConfig = a;\n\n        try {\n          yield Pa(_this65, M.NEED_RENEGOTIATE);\n        } catch (g) {\n          return b.onError(g), g.throw();\n        }\n\n        b.onSuccess();\n      })();\n    }\n\n    _getDefaultPlayerConfig() {\n      return {\n        mirror: !0,\n        fit: \"cover\"\n      };\n    }\n\n  }\n\n  var Uk = !0;\n  \"findIndex\" in [] && Array(1).findIndex(function () {\n    Uk = !1;\n  });\n  O({\n    target: \"Array\",\n    proto: !0,\n    forced: Uk\n  }, {\n    findIndex: function (a) {\n      return im(this, a, 1 < arguments.length ? arguments[1] : void 0);\n    }\n  });\n\n  var Io = za(\"Array\").findIndex,\n      Vk = Array.prototype,\n      Jd = function (a) {\n    var b = a.findIndex;\n    return a === Vk || a instanceof Array && b === Vk.findIndex ? Io : b;\n  };\n\n  let Sh = (a, b) => {\n    let c = null;\n    if (\"h264\" === b ? c = a.match(/a=rtpmap:(\\d+) H264.*\\r\\n/) || a.match(/a=rtpmap:(\\d+) H264.*\\n/) : \"vp8\" === b ? c = a.match(/a=rtpmap:(\\d+) VP8.*\\r\\n/) || a.match(/a=rtpmap:(\\d+) VP8.*\\n/) : \"vp9\" === b ? c = a.match(/a=rtpmap:(\\d+) VP9.*\\r\\n/) || a.match(/a=rtpmap:(\\d+) VP9.*\\n/) : \"av1\" === b && (c = a.match(/a=rtpmap:(\\d+) AV1.*\\r\\n/) || a.match(/a=rtpmap:(\\d+) AV1.*\\n/)), c && c[1]) return c[1];\n  };\n\n  class Wk extends Ok {\n    constructor(a, b, c, e) {\n      var _this66;\n\n      super(b, b.stringUid || b.uid);\n      _this66 = this;\n      this.type = \"pub\";\n      this._waitingSuccessResponse = this.detecting = !1;\n      this.renegotiateWithGateway = /*#__PURE__*/_asyncToGenerator(function* () {\n        return k.debug(\"[pc-\".concat(_this66.pc.ID, \"] renegotiate start\")), new A( /*#__PURE__*/function () {\n          var _ref12 = _asyncToGenerator(function* (a, b) {\n            _this66.connectionState = \"connecting\";\n\n            let c = e => {\n              \"connected\" === e && (_this66.off(H.CONNECTION_STATE_CHANGE, c), a());\n              \"disconnected\" === e && (_this66.off(H.CONNECTION_STATE_CHANGE, c), b(new n(l.OPERATION_ABORTED, \"renegotiate abort\")));\n            };\n\n            _this66.on(H.CONNECTION_STATE_CHANGE, c);\n\n            var e = yield _this66.pc.createOfferSDP();\n            _this66.audioTrack && _this66.audioTrack._encoderConfig && (e = We(e, _this66.audioTrack._encoderConfig));\n            _this66.videoTrack && _this66.videoTrack._scalabiltyMode && (\"vp9\" !== _this66.codec ? (_this66.videoTrack._scalabiltyMode.numSpatialLayers = 1, _this66.videoTrack._scalabiltyMode.numTemporalLayers = 1) : e = Rh(e, _this66.codec, _this66.videoTrack._scalabiltyMode), k.debug(\"renegoation spatial layers: \", _this66.videoTrack._scalabiltyMode.numSpatialLayers));\n            yield _this66.pc.setOfferSDP(e);\n\n            _this66.pc.onOfferSettled();\n\n            let g = yield La(_this66, H.NEED_RENEGOTIATE, e);\n\n            e = function (a, b) {\n              var c, e, g;\n              const h = ra(c = RegExp.prototype.test).call(c, /^([a-z])=(.*)/);\n              a = I(e = a.split(/(\\r\\n|\\r|\\n)/)).call(e, h);\n              b = I(g = b.split(/(\\r\\n|\\r|\\n)/)).call(g, h);\n              let k = null;\n              const p = new aa();\n              return q(a).call(a, a => {\n                const b = a.match(/m=(audio|video)/);\n                if (b && b[1]) return void (k = b[1]);\n                k && (a = a.match(/=(sendrecv|recvonly|sendonly|inactive)/)) && a[1] && p.set(k, a[1]);\n              }), k = null, E(b).call(b, a => {\n                var b = a.match(/m=(audio|video)/);\n                if (b && b[1]) return k = b[1], a;\n                if (!k) return a;\n\n                if ((b = a.match(/=(sendrecv|recvonly|sendonly|inactive)/)) && b[1]) {\n                  const c = p.get(k);\n                  if (c && c !== b[1]) return a.replace(b[1], c);\n                }\n\n                return a;\n              }).join(\"\\r\\n\") + \"\\r\\n\";\n            }(e, _this66.updateAnswerSDP(g.sdp));\n\n            yield _this66.pc.setAnswerSDP(e);\n            k.debug(\"[pc-\".concat(_this66.pc.ID, \"] renegotiate success\"));\n            _this66.connectionState = \"connected\";\n          });\n\n          return function (_x41, _x42) {\n            return _ref12.apply(this, arguments);\n          };\n        }());\n      });\n\n      this.handleStreamRenegotiate = (a, b) => {\n        \"connected\" === this.connectionState ? this.renegotiateWithGateway().then(a).catch(b) : a();\n      };\n\n      this.handleReplaceTrack = (a, b, c) => {\n        if (this.audioTrack instanceof Fc && \"audio\" === a.kind) return A.resolve();\n        this.pc.replaceTrack(a).then(a => a ? this.renegotiateWithGateway() : A.resolve()).then(b).catch(c);\n      };\n\n      this.handleCloseAudioTrack = a => {};\n\n      this.handleCloseVideoTrack = () => {\n        this.lowStreamConnection && this.lowStreamConnection.videoTrack && this.lowStreamConnection.videoTrack.close();\n      };\n\n      this.handleGetSessionID = a => {\n        a(this.joinInfo.sid);\n      };\n\n      this.handleGetLocalVideoStats = a => {\n        a(this.statsCollector.getLocalVideoTrackStats(this.connectionId));\n      };\n\n      this.handleGetLocalAudioStats = a => {\n        a(this.statsCollector.getLocalAudioTrackStats(this.connectionId));\n      };\n\n      this.handleSetOptimizationMode = (a, b, c) => {\n        this.videoTrack && this.setRtpSenderParametersByTrackConfig(this.videoTrack).then(b).catch(c);\n      };\n\n      this.isLowStreamConnection = !!e;\n      this.codec = c;\n      this.statsCollector = a;\n      this.statsCollector.addLocalConnection(this);\n    }\n\n    getAllTracks() {\n      let a = [];\n      return this.videoTrack && a.push(this.videoTrack), this.audioTrack && this.audioTrack instanceof Fc ? a = m(a).call(a, this.audioTrack.trackList) : this.audioTrack && a.push(this.audioTrack), a;\n    }\n\n    addTracks(a) {\n      var _this67 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = ha;\n        if (\"connecting\" === _this67.connectionState) try {\n          return yield _this67.createWaitConnectionConnectedPromise(), yield _this67.addTracks(a);\n        } catch (h) {\n          throw new n(l.OPERATION_ABORTED, \"publish abort\");\n        }\n        var c = !1;\n\n        let e = _this67.getAllTracks();\n\n        a = qh(a = I(a).call(a, a => -1 === J(e).call(e, a)));\n\n        for (let e = 0; e < a.length; e += 1) {\n          var g = a[e];\n          if (!(g instanceof ne)) return new n(l.INVALID_LOCAL_TRACK).throw();\n\n          if (g instanceof Ma && _this67.disabledVideoTrack) {\n            if (_this67.disabledVideoTrack !== g) return new n(l.EXIST_DISABLED_VIDEO_TRACK).throw();\n            _this67.disabledVideoTrack = void 0;\n          }\n\n          if (g instanceof Ma && _this67.videoTrack) return new n(l.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw();\n          if (g instanceof Ya && _this67.audioTrack) {\n            if (_this67.audioTrack instanceof Fc) _this67.audioTrack.addAudioTrack(g);else {\n              if (!b.webAudioMediaStreamDest) throw new n(l.NOT_SUPPORTED, \"your browser is not support audio mixing\");\n              c = new Fc();\n              c.addAudioTrack(_this67.audioTrack);\n              c.addAudioTrack(g);\n              c = yield _this67.addTrackWithPC(c);\n            }\n          } else g instanceof Ma && _this67.isLowStreamConnection ? (c = Uh({}, {\n            width: 160,\n            height: 120,\n            framerate: 15,\n            bitrate: 50\n          }, {}, _this67.lowStreamParameter), b.supportDualStreamEncoding ? (k.debug(\"[\".concat(_this67.connectionId, \"] creating low stream using rtp encoding.\")), _this67.lowStreamEncoding = ml(c, g), g = g.clone({\n            bitrateMax: c.bitrate,\n            bitrateMin: c.bitrate\n          })) : (k.debug(\"[\".concat(_this67.connectionId, \"] creating low stream using canvas.\")), g = Al(g, c), g = new Ma(g, {\n            bitrateMax: c.bitrate,\n            bitrateMin: c.bitrate\n          })), g._hints.push(rb.LOW_STREAM), c = yield _this67.addTrackWithPC(g), _this67.bindTrackEvents(g)) : (_this67.detecting = !0, Ub(() => {\n            _this67.detecting = !1;\n          }, 8E3), c = yield _this67.addTrackWithPC(g));\n        }\n\n        c && (yield _this67.renegotiateWithGateway());\n        q(a).call(a, a => _this67.bindTrackEvents(a));\n      })();\n    }\n\n    removeTracks(a, b) {\n      var _this68 = this;\n\n      return _asyncToGenerator(function* () {\n        let c = _this68.getAllTracks();\n\n        a = qh(a = I(a).call(a, a => -1 !== J(c).call(c, a) || a === _this68.disabledVideoTrack));\n        let e = [];\n\n        for (let c = 0; c < a.length; c += 1) {\n          let g = a[c];\n          if (_this68.unbindTrackEvents(g), _this68.audioTrack instanceof Fc && g instanceof Ya) _this68.audioTrack.removeAudioTrack(g), 0 === _this68.audioTrack.trackList.length && (e.push(_this68.audioTrack), _this68.audioTrack = void 0);else if (g instanceof Ya) e.push(g), _this68.audioTrack = void 0;else if (g instanceof Ma) {\n            if (b) {\n              if (_this68.disabledVideoTrack === g) return void (_this68.disabledVideoTrack = void 0);\n            } else _this68.disabledVideoTrack = _this68.videoTrack;\n\n            e.push(g);\n            _this68.isLowStreamConnection && g.close();\n            _this68.videoTrack = void 0;\n          }\n        }\n\n        if (_this68.videoTrack || _this68.audioTrack) {\n          if (0 !== e.length) {\n            if (\"connecting\" === _this68.connectionState) try {\n              yield _this68.createWaitConnectionConnectedPromise();\n            } catch (h) {\n              return;\n            }\n\n            for (let a of e) {\n              var g;\n              k.debug(m(g = \"[\".concat(_this68.connectionId, \"] remove \")).call(g, a.trackMediaType, \" from pc\"));\n              yield _this68.pc.removeTrack(a._mediaStreamTrack);\n            }\n\n            yield _this68.renegotiateWithGateway();\n          }\n        } else yield _this68.closeP2PConnection();\n      })();\n    }\n\n    startP2PConnection() {\n      var _this69 = this;\n\n      return new A( /*#__PURE__*/function () {\n        var _ref13 = _asyncToGenerator(function* (a, b) {\n          if (!_this69.audioTrack && !_this69.videoTrack) return b(new n(l.UNEXPECTED_ERROR, \"no track to publish\"));\n\n          let c = e => {\n            if (\"connected\" === e && (_this69.off(H.CONNECTION_STATE_CHANGE, c), a()), \"disconnected\" === e) {\n              if (_this69.off(H.CONNECTION_STATE_CHANGE, c), _this69.disconnectedReason) return b(_this69.disconnectedReason);\n              b(new n(l.OPERATION_ABORTED, \"publish abort\"));\n            }\n          };\n\n          _this69.on(H.CONNECTION_STATE_CHANGE, c);\n\n          _this69.disconnectedReason = void 0;\n          _this69.connectionState = \"connecting\";\n          _this69._waitingSuccessResponse = !0;\n          _this69.startTime = x();\n\n          try {\n            var e;\n            !_this69.pc.audioTrack && _this69.audioTrack && (yield _this69.pc.addTrack(_this69.audioTrack._mediaStreamTrack));\n            !_this69.pc.videoTrack && _this69.videoTrack && (yield _this69.pc.addTrack(_this69.videoTrack._mediaStreamTrack));\n            let a = yield _this69.pc.createOfferSDP();\n            v.REMOVE_NEW_CODECS && (a = \"vp9\" === _this69.codec ? Xe(a, [\"av1\"]) : \"av1\" === _this69.codec ? Xe(a, [\"vp9\"]) : Xe(a, [\"vp9\", \"av1\"]));\n            let b = Ph(a);\n            _this69.videoTrack && !ba(e = b.video).call(e, _this69.codec.toUpperCase()) && k.warning(\"current codec is not supported, support list: \".concat(b.video.join(\",\")));\n            _this69.audioTrack && _this69.audioTrack._encoderConfig && (a = We(a, _this69.audioTrack._encoderConfig));\n            _this69.videoTrack && _this69.videoTrack._scalabiltyMode && (\"vp9\" !== _this69.codec && \"av1\" !== _this69.codec ? (_this69.videoTrack._scalabiltyMode.numSpatialLayers = 1, _this69.videoTrack._scalabiltyMode.numTemporalLayers = 1) : a = Rh(a, _this69.codec, _this69.videoTrack._scalabiltyMode), k.debug(\"spatial layers: \", _this69.videoTrack._scalabiltyMode.numSpatialLayers));\n            yield _this69.pc.setOfferSDP(a);\n\n            _this69.pc.onOfferSettled();\n\n            _this69.videoTrack && _this69.setRtpSenderParametersByTrackConfig(_this69.videoTrack);\n            k.debug(\"[\".concat(_this69.connectionId, \"] create and set offer success\"));\n            e = {\n              messageType: \"OFFER\",\n              sdp: a,\n              offererSessionId: 104,\n              retry: !0\n            };\n            ha.supportDualStreamEncoding && _this69.isLowStreamConnection && _this69.lowStreamEncoding && _this69.videoTrack && (yield _this69.setLowStreamEncoding(_this69.lowStreamEncoding, _this69.videoTrack));\n\n            let c = yield La(_this69, H.NEED_ANSWER, e),\n                l = _this69.updateAnswerSDP(c.sdp);\n\n            yield _this69.pc.setAnswerSDP(l);\n            k.debug(\"[\".concat(_this69.connectionId, \"] set answer success\"));\n            yield _this69.icePromise;\n            _this69.connectionState = \"connected\";\n\n            _this69.startUploadStats();\n          } catch (g) {\n            _this69.off(H.CONNECTION_STATE_CHANGE, c), _this69.connectionState = \"disconnected\", _this69.reportPublishEvent(!1, g.code), k.error(\"[\".concat(_this69.connectionId, \"] connection error\"), g.toString()), b(g);\n          }\n        });\n\n        return function (_x43, _x44) {\n          return _ref13.apply(this, arguments);\n        };\n      }());\n    }\n\n    reportPublishEvent(a, b, c) {\n      var e;\n      this._waitingSuccessResponse = !1;\n      u.publish(this.joinInfo.sid, {\n        lts: this.startTime,\n        succ: a,\n        ec: b,\n        audioName: this.audioTrack && this.audioTrack.getTrackLabel(),\n        videoName: this.videoTrack && this.videoTrack.getTrackLabel(),\n        screenshare: !(!this.videoTrack || -1 === J(e = this.videoTrack._hints).call(e, rb.SCREEN_TRACK)),\n        audio: !!this.audioTrack,\n        video: !!this.videoTrack,\n        p2pid: this.pc.ID,\n        publishRequestid: this.ID,\n        extend: c\n      });\n    }\n\n    closeP2PConnection(a) {\n      var _this70 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = _this70.getAllTracks();\n\n        var c;\n        (q(b).call(b, a => {\n          _this70.unbindTrackEvents(a);\n        }), _this70.isLowStreamConnection && _this70.videoTrack && _this70.videoTrack.close(), _this70.videoTrack = void 0, _this70.audioTrack instanceof Fc) && q(c = _this70.audioTrack.trackList).call(c, a => {\n          _this70.audioTrack.removeAudioTrack(a);\n        });\n        _this70.audioTrack = void 0;\n\n        _this70.stopUploadStats();\n\n        _this70.statsCollector.removeConnection(_this70.connectionId);\n\n        yield _this70.closePC(a);\n        _this70.connectionState = \"disconnected\";\n\n        _this70.removeAllListeners();\n      })();\n    }\n\n    getNetworkQuality() {\n      var a,\n          b = this.pc.getStats();\n      if (!b.videoSend[0] && !b.audioSend[0]) return 1;\n      var c = Zb(this, H.NEED_SIGNAL_RTT),\n          e = b.videoSend[0] ? b.videoSend[0].rttMs : void 0;\n      let g = b.audioSend[0] ? b.audioSend[0].rttMs : void 0;\n      e = e && g ? (e + g) / 2 : e || g;\n      c = 70 * b.sendPacketLossRate / 50 + .3 * ((e && c ? (e + c) / 2 : e || c) || 0) / 1500;\n      c = .17 > c ? 1 : .36 > c ? 2 : .59 > c ? 3 : .1 > c ? 4 : 5;\n      return this.videoTrack && this.videoTrack._encoderConfig && -1 === J(a = this.videoTrack._hints).call(a, rb.SCREEN_TRACK) && (a = this.videoTrack._encoderConfig.bitrateMax, b = b.bitrate.actualEncoded, a && b) ? (b = (1E3 * a - b) / (1E3 * a), Hn[.15 > b ? 0 : .3 > b ? 1 : .45 > b ? 2 : .6 > b ? 3 : 4][c]) : c;\n    }\n\n    handleUpdateBitrateLimit(a) {\n      this.videoTrack && this.videoTrack.setBitrateLimit(a);\n    }\n\n    uploadStats(a, b) {\n      let c = this.audioTrack ? function (a, b) {\n        const c = a.audioSend[0];\n        if (!c) return null;\n        a = {\n          id: qa(10, \"\"),\n          timestamp: new Date(a.timestamp).toISOString(),\n          mediaType: \"audio\",\n          type: \"ssrc\",\n          ssrc: c.ssrc.toString()\n        };\n        return a.A_astd = b._originMediaStreamTrack.enabled && b._mediaStreamTrack.enabled ? \"0\" : \"1\", c.inputLevel ? a.A_ail = Math.round(100 * c.inputLevel).toString() : a.A_ail = Math.round(100 * b._source.getAudioAvgLevel()).toString(), a.A_apil = Math.round(100 * b._source.getAudioAvgLevel()).toString(), a;\n      }(a, this.audioTrack) : void 0,\n          e = this.videoTrack ? function (a, b) {\n        const c = a.videoSend[0];\n        if (!c) return null;\n        a = {\n          id: qa(10, \"\"),\n          timestamp: new Date(a.timestamp).toISOString(),\n          mediaType: \"video\",\n          type: \"ssrc\",\n          ssrc: c.ssrc.toString()\n        };\n\n        switch (a.A_vstd = b._originMediaStreamTrack && !b._originMediaStreamTrack.enabled || !b._mediaStreamTrack.enabled ? \"1\" : \"0\", c.sentFrame && (a.A_fhs = c.sentFrame.height.toString(), a.A_frs = c.sentFrame.frameRate.toString(), a.A_fws = c.sentFrame.width.toString()), c.adaptionChangeReason) {\n          case \"none\":\n            a.A_ac = \"0\";\n            break;\n\n          case \"cpu\":\n            a.A_ac = \"1\";\n            break;\n\n          case \"bandwidth\":\n            a.A_ac = \"2\";\n            break;\n\n          case \"other\":\n            a.A_ac = \"3\";\n        }\n\n        return a.A_nr = c.nacksCount.toString(), c.avgEncodeMs && (a.A_aem = c.avgEncodeMs.toFixed(0).toString()), a;\n      }(a, this.videoTrack) : void 0,\n          g = mh(a, b),\n          h = function (a) {\n        const b = {\n          id: \"bweforvideo\",\n          timestamp: new Date(a.timestamp).toISOString(),\n          type: \"VideoBwe\"\n        };\n        return a.bitrate.retransmit && (b.A_rb = a.bitrate.retransmit.toString()), a.bitrate.targetEncoded && (b.A_teb = a.bitrate.targetEncoded.toString()), b.A_aeb = a.bitrate.actualEncoded.toString(), b.A_tb = a.bitrate.transmit.toString(), void 0 !== a.sendBandwidth && (b.A_asb = a.sendBandwidth.toString()), b;\n      }(a);\n\n      c && Za(() => this.emit(H.NEED_UPLOAD, qb.PUBLISH_STATS, c));\n      e && Za(() => this.emit(H.NEED_UPLOAD, qb.PUBLISH_STATS, Uh({}, e, {}, g)));\n      h && Za(() => this.emit(H.NEED_UPLOAD, qb.PUBLISH_STATS, h));\n    }\n\n    uploadSlowStats(a) {\n      let b = mh(a);\n      b && Za(() => this.emit(H.NEED_UPLOAD, qb.PUBLISH_STATS, b));\n    }\n\n    uploadRelatedStats(a) {\n      let b = function (a) {\n        return (a = a.videoSend[0]) ? {\n          mediaType: \"video\",\n          isVideoMute: !1,\n          frameRateInput: a.inputFrame && a.inputFrame.frameRate.toString(),\n          frameRateSent: a.sentFrame && a.sentFrame.frameRate.toString(),\n          googRtt: a.rttMs.toString()\n        } : null;\n      }(a);\n\n      b && Za(() => {\n        this.emit(H.NEED_UPLOAD, qb.PUBLISH_RELATED_STATS, b);\n      });\n    }\n\n    bindTrackEvents(a) {\n      var b;\n      a.addListener(M.NEED_RESET_REMOTE_SDP, ra(b = this.handleResetRemoteSdp).call(b, this));\n      this.isLowStreamConnection || (a instanceof Ya ? (a.addListener(M.GET_STATS, this.handleGetLocalAudioStats), a.addListener(M.NEED_CLOSE, this.handleCloseAudioTrack)) : a instanceof Ma && (a.addListener(M.GET_STATS, this.handleGetLocalVideoStats), a.addListener(M.NEED_CLOSE, this.handleCloseVideoTrack), a.addListener(M.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode)), a.addListener(M.NEED_RENEGOTIATE, this.handleStreamRenegotiate), a.addListener(M.NEED_REPLACE_TRACK, this.handleReplaceTrack), a.addListener(M.NEED_SESSION_ID, this.handleGetSessionID));\n    }\n\n    unbindTrackEvents(a) {\n      this.isLowStreamConnection || (a instanceof Ya ? (a.off(M.GET_STATS, this.handleGetLocalAudioStats), a.off(M.NEED_CLOSE, this.handleCloseAudioTrack)) : a instanceof Ma && (a.off(M.GET_STATS, this.handleGetLocalVideoStats), a.off(M.NEED_CLOSE, this.handleCloseVideoTrack)), a.off(M.NEED_RENEGOTIATE, this.handleStreamRenegotiate), a.off(M.NEED_REPLACE_TRACK, this.handleReplaceTrack), a.off(M.NEED_SESSION_ID, this.handleGetSessionID));\n    }\n\n    addTrackWithPC(a) {\n      var _this71 = this;\n\n      return _asyncToGenerator(function* () {\n        if (\"connecting\" === _this71.connectionState) return new n(l.INVALID_OPERATION, \"last publish operation has not finished\").throw();\n        let b = _this71.videoTrack,\n            c = !1;\n        return _this71.audioTrack && a instanceof Ya ? (_this71.audioTrack = a, k.debug(\"[\".concat(_this71.connectionId, \"] replace pc audio track\")), c = yield _this71.pc.replaceTrack(a._mediaStreamTrack)) : _this71.videoTrack && a instanceof Ma ? (_this71.videoTrack = a, k.debug(\"[\".concat(_this71.connectionId, \"] replace pc video track\")), c = yield _this71.pc.replaceTrack(a._mediaStreamTrack)) : a instanceof Ya ? (_this71.audioTrack = a, k.debug(\"[\".concat(_this71.connectionId, \"] add audio track to pc\")), yield _this71.pc.addTrack(a._mediaStreamTrack), c = !0) : a instanceof Ma && (_this71.videoTrack = a, k.debug(\"[\".concat(_this71.connectionId, \"] add video track to pc\")), yield _this71.pc.addTrack(a._mediaStreamTrack), c = !0), \"connected\" === _this71.connectionState && _this71.videoTrack !== b && _this71.videoTrack && (yield _this71.setRtpSenderParametersByTrackConfig(_this71.videoTrack)), \"disconnected\" !== _this71.connectionState && c;\n      })();\n    }\n\n    handleResetRemoteSdp() {\n      return new A((a, b) => {\n        var c;\n        k.info(\"[pc-\".concat(this.pc.ID, \"] start reset remote sdp\"));\n        let e = this.pc.getOfferSDP();\n        var g = this.pc.getAnswerSDP();\n        if (!g || !e) return a();\n        g = g.sdp;\n        let h;\n        this.videoTrack && this.videoTrack._encoderConfig && -1 === J(c = this.videoTrack._hints).call(c, rb.SCREEN_TRACK) && (h = function (a, b) {\n          var c, e;\n          let g = b.bitrateMin;\n          b = b.bitrateMax;\n          let h = ra(c = RegExp.prototype.test).call(c, /^([a-z])=(.*)/);\n          a = I(e = a.split(/(\\r\\n|\\r|\\n)/)).call(e, h);\n\n          if (b) {\n            let c = \"AS\";\n            na().name === ca.FIREFOX && (b = 1E3 * (b >>> 0), c = \"TIAS\");\n            e = Jd(a).call(a, a => ba(a).call(a, c));\n            var k;\n            0 < e && (a[e] = m(k = \"b=\".concat(c, \":\")).call(k, b));\n          }\n\n          g && (k = Jd(a).call(a, a => ba(a).call(a, \"x-google-min-bitrate\")), 0 < k && (a[k] = a[k].replace(/x-google-min-bitrate=(.*)/, \"x-google-min-bitrate=\".concat(g))));\n          return a.join(\"\\r\\n\") + \"\\r\\n\";\n        }(g, this.videoTrack._encoderConfig));\n        g !== h ? this.pc.setOfferSDP(e.sdp).then(() => {\n          if (h) return this.pc.setAnswerSDP(h);\n        }).then(a).catch(a => {\n          var c;\n          k.error(m(c = \"[pc-\".concat(this.pc.ID, \"] reset remote sdp error, \")).call(c, a));\n          b(a);\n        }) : k.debug(\"[pc-\".concat(this.pc.ID, \"] remote sdp have no not changed\"));\n      });\n    }\n\n    setRtpSenderParametersByTrackConfig(a) {\n      var _this72 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!ha.supportSetRtpSenderParameters) return void k.debug(\"[\".concat(_this72.connectionId, \"] do not support set pc rtp sender, skip\"));\n        let b = {},\n            c = \"balanced\";\n        \"motion\" === a._optimizationMode ? c = \"maintain-framerate\" : \"detail\" === a._optimizationMode && (c = \"maintain-resolution\");\n        k.debug(\"[\".concat(_this72.connectionId, \"] set pc rtp sender\"), b, c);\n        yield _this72.pc.setRtpSenderParameters(b, c);\n      })();\n    }\n\n    updateAnswerSDP(a) {\n      var b, c;\n      return a = a.replace(/a=x-google-flag:conference\\r\\n/g, \"\"), this.videoTrack && J(b = this.videoTrack._hints).call(b, rb.SCREEN_TRACK), this.videoTrack && this.videoTrack._encoderConfig && -1 === J(c = this.videoTrack._hints).call(c, rb.SCREEN_TRACK) && (a = function (a, b, c) {\n        let e = ha;\n        var g = c.bitrateMin;\n        c = c.bitrateMax;\n        let h = a.match(/m=video.*\\r\\n/) || a.match(/m=video.*\\n/);\n\n        if (h && 0 < h.length && e.supportMinBitrate && g) {\n          b = Sh(a, b);\n          var k, l;\n          b && (a = a.replace(h[0], m(k = m(l = \"\".concat(h[0], \"a=fmtp:\")).call(l, b, \" x-google-min-bitrate=\")).call(k, g, \"\\r\\n\")));\n        }\n\n        if (h && 0 < h.length && c) {\n          var n, q;\n          g = \"AS\";\n          na().name === ca.FIREFOX && (c = 1E3 * (c >>> 0), g = \"TIAS\");\n          a = a.replace(h[0], m(n = m(q = \"\".concat(h[0], \"b=\")).call(q, g, \":\")).call(n, c, \"\\r\\n\"));\n        }\n\n        return a;\n      }(a, this.codec, this.videoTrack._encoderConfig)), this.audioTrack && this.audioTrack._encoderConfig && (a = We(a, this.audioTrack._encoderConfig)), a = function (a) {\n        let b = na();\n        return b.name !== ca.SAFARI && b.os !== X.IOS ? a : a.replace(/a=.*video-orientation\\r\\n/g, \"\");\n      }(a);\n    }\n\n    createPC() {\n      this.pc = new Lk({\n        turnServer: this.joinInfo.turnServer\n      });\n      this.updateICEPromise();\n    }\n\n    closePC(a) {\n      var _this73 = this;\n\n      return _asyncToGenerator(function* () {\n        return _this73.pc.onICEConnectionStateChange = void 0, _this73.pc.close(), !a && (yield La(_this73, H.NEED_UNPUB));\n      })();\n    }\n\n    onPCDisconnected(a) {\n      this.reportPublishEvent(!1, a.code);\n    }\n\n    setLowStreamEncoding(a, b) {\n      var _this74 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          let c = yield _this74.pc.setVideoRtpEncodingParameters(a),\n              e = b.getMediaStreamTrack();\n\n          if (a.scaleResolutionDownBy && c.encodings[0].scaleResolutionDownBy !== a.scaleResolutionDownBy) {\n            let c = b._videoHeight || e.getSettings().height,\n                h = b._videoWidth || e.getSettings().width;\n            c && h && (yield e.applyConstraints({\n              height: c / a.scaleResolutionDownBy,\n              width: h / a.scaleResolutionDownBy\n            }));\n          }\n\n          a.maxFramerate && c.encodings[0].maxFramerate !== a.maxFramerate && (yield e.applyConstraints({\n            frameRate: a.maxFramerate\n          }));\n        } catch (c) {\n          if (c instanceof n) throw c;\n          throw new n(l.LOW_STREAM_ENCODING_ERROR, c.message);\n        }\n      })();\n    }\n\n  }\n\n  class Xk extends Bk {\n    constructor(a, b, c) {\n      super(a);\n      this._isDestroyed = !1;\n      this._userId = b;\n      this._uintId = c;\n    }\n\n    getUserId() {\n      return this._userId;\n    }\n\n    _updateOriginMediaStreamTrack(a) {\n      this._mediaStreamTrack = this._originMediaStreamTrack = a;\n\n      this._updatePlayerSource();\n    }\n\n    _destroy() {\n      this._isDestroyed = !0;\n      k.info(\"[track-\".concat(this.getTrackId(), \"] is destroyed\"));\n      this.stop();\n    }\n\n  }\n\n  class md extends Xk {\n    constructor(a, b, c) {\n      super(a, b, c);\n      this.trackMediaType = \"video\";\n      this.updateMediaStreamTrackResolution();\n    }\n\n    get isPlaying() {\n      return !(!this._player || this._player.videoElementStatus !== Ba.PLAYING);\n    }\n\n    getStats() {\n      Oc(() => {\n        k.warning(\"[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead\");\n      }, \"remoteVideoTrackGetStatsWarning\");\n      return Zb(this, M.GET_STATS) || Ye({}, Rf);\n    }\n\n    play(a, b = {}) {\n      let c = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.REMOTE_VIDEO_TRACK_PLAY,\n        options: [this.getTrackId(), \"string\" == typeof a ? a : \"HTMLElement\", b]\n      });\n\n      if (\"string\" == typeof a) {\n        let b = document.getElementById(a);\n        var e;\n        b ? a = b : (k.warning(m(e = \"[track-\".concat(this.getTrackId(), '] can not find \"#')).call(e, a, '\" element, use document.body')), a = document.body);\n      }\n\n      k.debug(\"[track-\".concat(this.getTrackId(), \"] start video playback\"), w(b));\n      a = Ye({\n        fit: \"cover\"\n      }, b, {\n        trackId: this.getTrackId(),\n        element: a\n      });\n      this._player ? this._player.updateConfig(a) : (this._player = new Pk(a), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {\n        this.emit(gd.FIRST_FRAME_DECODED);\n      });\n\n      this._player.play();\n\n      c.onSuccess();\n    }\n\n    stop() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.REMOTE_VIDEO_TRACK_STOP,\n        options: [this.getTrackId()]\n      });\n      if (!this._player) return a.onSuccess();\n\n      this._player.destroy();\n\n      this._player = void 0;\n      k.debug(\"[track-\".concat(this.getTrackId(), \"] stop video playback\"));\n      a.onSuccess();\n    }\n\n    getCurrentFrameData() {\n      return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n    }\n\n    updateMediaStreamTrackResolution() {\n      ph(this._originMediaStreamTrack).then(([a, b]) => {\n        this._videoHeight = b;\n        this._videoWidth = a;\n      }).catch(bg);\n    }\n\n    _updatePlayerSource() {\n      k.debug(\"[track-\".concat(this.getTrackId(), \"] update player source track\"));\n      this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n    }\n\n  }\n\n  class nd extends Xk {\n    constructor(a, b, c) {\n      super(a, b, c);\n      this.trackMediaType = \"audio\";\n      this._useAudioElement = !0;\n      this._volume = 100;\n      this._source = new Dk(a, !0);\n\n      this._source.once(ib.RECEIVE_TRACK_BUFFER, () => {\n        this.emit(gd.FIRST_FRAME_DECODED);\n      });\n    }\n\n    get isPlaying() {\n      return this._useAudioElement ? db.isPlaying(this.getTrackId()) : this._source.isPlayed;\n    }\n\n    setAudioFrameCallback(a, b = 4096) {\n      if (!a) return this._source.removeAllListeners(ib.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n\n      this._source.startGetAudioBuffer(b);\n\n      this._source.removeAllListeners(ib.ON_AUDIO_BUFFER);\n\n      this._source.on(ib.ON_AUDIO_BUFFER, b => a(b));\n    }\n\n    setVolume(a) {\n      let b = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.REMOTE_AUDIO_SET_VOLUME,\n        options: [this.getTrackId(), a]\n      }, 300);\n      this._volume = a;\n      this._useAudioElement ? db.setVolume(this.getTrackId(), a) : this._source.setVolume(a / 100);\n      b.onSuccess();\n    }\n\n    setPlaybackDevice(a) {\n      var _this75 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.REMOTE_AUDIO_SET_OUTPUT_DEVICE,\n          options: [_this75.getTrackId(), a]\n        });\n        if (!_this75._useAudioElement) throw new n(l.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n\n        try {\n          yield db.setSinkID(_this75.getTrackId(), a);\n        } catch (c) {\n          throw b.onError(c), c;\n        }\n\n        b.onSuccess();\n      })();\n    }\n\n    getVolumeLevel() {\n      return this._source.getAudioLevel();\n    }\n\n    getStats() {\n      Oc(() => {\n        k.warning(\"[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead\");\n      }, \"remoteAudioTrackGetStatsWarning\");\n      return Zb(this, M.GET_STATS) || Ye({}, Qf);\n    }\n\n    play() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.REMOTE_AUDIO_TRACK_PLAY,\n        options: [this.getTrackId()]\n      });\n      k.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\"));\n      this._useAudioElement ? (k.debug(\"[track-\".concat(this.getTrackId(), \"] use audio element to play\")), db.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();\n      a.onSuccess();\n    }\n\n    stop() {\n      let a = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.REMOTE_AUDIO_TRACK_STOP,\n        options: [this.getTrackId()]\n      });\n      k.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\"));\n      this._useAudioElement ? db.stop(this.getTrackId()) : this._source.stop();\n      a.onSuccess();\n    }\n\n    _destroy() {\n      super._destroy();\n\n      this._source.destroy();\n    }\n\n    _isFreeze() {\n      return this._source.isFreeze;\n    }\n\n    _updatePlayerSource() {\n      k.debug(\"[track-\".concat(this.getTrackId(), \"] update player source track\"));\n\n      this._source.updateTrack(this._mediaStreamTrack);\n\n      this._useAudioElement && db.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n    }\n\n  }\n\n  class Jo extends Ok {\n    constructor(a, b, c, e) {\n      super(c, a.uid);\n      this.type = \"sub\";\n      this.unusedTracks = [];\n\n      this.onTrack = a => {\n        var b, c;\n        if (\"audio\" === a.kind && !this.subscribeOptions.audio || \"video\" === a.kind && !this.subscribeOptions.video) return this.unusedTracks.push(a), void k.debug(m(c = \"[\".concat(this.connectionId, \"] unused ontrack event, kind: \")).call(c, a.kind));\n        k.debug(m(b = \"[\".concat(this.connectionId, \"] emit pc ontrack after subscribe \")).call(b, a.kind), a);\n        b = \"audio\" === a.kind ? this.user._audioTrack : this.user._videoTrack;\n        var e, g;\n        b ? b._updateOriginMediaStreamTrack(a) : \"audio\" === a.kind ? (this.pc._statsFilter.setIsFirstAudioDecoded(!1), this.user._audioTrack = new nd(a, this.getUserId(), this.user._uintid), k.info(m(e = \"[\".concat(this.connectionId, \"] create remote audio track: \")).call(e, this.user._audioTrack.getTrackId())), this.bindTrackEvents(this.user._audioTrack)) : (this.user._videoTrack = new md(a, this.getUserId(), this.user._uintid), k.info(m(g = \"[\".concat(this.connectionId, \"] create remote video track: \")).call(g, this.user._videoTrack.getTrackId())), this.bindTrackEvents(this.user._videoTrack));\n      };\n\n      this.handleGetRemoteAudioStats = a => {\n        a(this.statsCollector.getRemoteAudioTrackStats(this.connectionId));\n      };\n\n      this.handleGetRemoteVideoStats = a => {\n        a(this.statsCollector.getRemoteVideoTrackStats(this.connectionId));\n      };\n\n      this.handleGetSessionID = a => {\n        a(this.joinInfo.sid);\n      };\n\n      this.user = a;\n      this.statsCollector = b;\n      this.statsCollector.addRemoteConnection(this);\n      this.subscribeOptions = e;\n    }\n\n    startP2PConnection() {\n      var _this76 = this;\n\n      return _asyncToGenerator(function* () {\n        return new A( /*#__PURE__*/function () {\n          var _ref14 = _asyncToGenerator(function* (a, b) {\n            let c = e => {\n              if (\"connected\" === e && (u.subscribe(_this76.joinInfo.sid, {\n                lts: _this76.startTime,\n                succ: !0,\n                video: _this76.subscribeOptions.video,\n                audio: _this76.subscribeOptions.audio,\n                peerid: _this76.user.uid,\n                ec: null,\n                subscribeRequestid: _this76.ID,\n                p2pid: _this76.pc.ID\n              }), _this76.off(H.CONNECTION_STATE_CHANGE, c), a()), \"disconnected\" === e) {\n                if (_this76.off(H.CONNECTION_STATE_CHANGE, c), _this76.disconnectedReason) return b(_this76.disconnectedReason);\n                b(new n(l.OPERATION_ABORTED, \"subscribe abort\"));\n              }\n            };\n\n            if (_this76.on(H.CONNECTION_STATE_CHANGE, c), _this76.disconnectedReason = void 0, _this76.connectionState = \"connecting\", _this76.startTime = x(), !_this76.subscribeOptions) return void b(new n(l.UNEXPECTED_ERROR, \"no subscribe options\"));\n            let e = new MediaStream(),\n                g = new A(a => {\n              _this76.pc.onTrack = (b, c) => {\n                var g, h;\n                if (\"audio\" === b.kind && !_this76.subscribeOptions.audio || \"video\" === b.kind && !_this76.subscribeOptions.video) return _this76.unusedTracks.push(b), void k.debug(m(h = \"[\".concat(_this76.connectionId, \"] unused ontrack event \")).call(h, b.kind));\n                e.addTrack(b);\n                h = {\n                  audio: 0 < e.getAudioTracks().length,\n                  video: 0 < e.getVideoTracks().length\n                };\n                k.debug(m(g = \"[\".concat(_this76.connectionId, \"] subscribe ontrack: \")).call(g, b.kind), c, b);\n\n                a: {\n                  b = _this76.subscribeOptions;\n                  var p, l;\n                  c = dd(p = V(h)).call(p);\n                  p = dd(l = V(b)).call(l);\n\n                  for (l = 0; l < c.length; l += 1) {\n                    if (c[l] !== p[l]) {\n                      h = !1;\n                      break a;\n                    }\n\n                    if (h[c[l]] !== b[c[l]]) {\n                      h = !1;\n                      break a;\n                    }\n                  }\n\n                  h = !0;\n                }\n\n                h && (_this76.pc.onTrack = _this76.onTrack, k.debug(\"[\".concat(_this76.connectionId, \"] get all subscribed tracks\")), a(e));\n              };\n            });\n\n            try {\n              let a = function (a) {\n                return na().name !== ca.FIREFOX ? a : a.replace(\"/recvonly http://www.webrtc.org/experiments/rtp-hdrext/playout-delay\", \" http://www.webrtc.org/experiments/rtp-hdrext/playout-delay\");\n              }(Qh(yield _this76.pc.createOfferSDP()));\n\n              yield _this76.pc.setOfferSDP(a);\n              k.debug(\"[\".concat(_this76.connectionId, \"] create and set offer success\"));\n              let b = yield La(_this76, H.NEED_ANSWER, {\n                messageType: \"OFFER\",\n                sdp: a,\n                offererSessionId: 104,\n                retry: !0\n              });\n              yield _this76.pc.setAnswerSDP(Qh(b.sdp));\n              k.debug(\"[\".concat(_this76.connectionId, \"] set answer success\"));\n              let c = yield A.all([g, _this76.icePromise]),\n                  e = c[0].getAudioTracks()[0],\n                  l = c[0].getVideoTracks()[0];\n              var h, p;\n              e && (_this76.user._audioTrack ? _this76.user._audioTrack._updateOriginMediaStreamTrack(e) : (_this76.user._audioTrack = new nd(e, _this76.getUserId(), _this76.user._uintid), k.info(m(h = \"[\".concat(_this76.connectionId, \"] create remote audio track: \")).call(h, _this76.user._audioTrack.getTrackId())), _this76.bindTrackEvents(_this76.user._audioTrack)));\n              l && (_this76.user._videoTrack ? _this76.user._videoTrack._updateOriginMediaStreamTrack(l) : (_this76.user._videoTrack = new md(l, _this76.getUserId(), _this76.user._uintid), k.info(m(p = \"[\".concat(_this76.connectionId, \"] create remote video track: \")).call(p, _this76.user._videoTrack.getTrackId())), _this76.bindTrackEvents(_this76.user._videoTrack)));\n              _this76.connectionState = \"connected\";\n\n              _this76.startUploadStats();\n            } catch (r) {\n              _this76.off(H.CONNECTION_STATE_CHANGE, c), _this76.connectionState = \"disconnected\", u.subscribe(_this76.joinInfo.sid, {\n                lts: _this76.startTime,\n                succ: !1,\n                video: _this76.subscribeOptions.video,\n                audio: _this76.subscribeOptions.audio,\n                peerid: _this76.user.uid,\n                ec: r.code,\n                subscribeRequestid: _this76.ID,\n                p2pid: _this76.pc.ID\n              }), b(r);\n            }\n          });\n\n          return function (_x45, _x46) {\n            return _ref14.apply(this, arguments);\n          };\n        }());\n      })();\n    }\n\n    closeP2PConnection(a) {\n      var _this77 = this;\n\n      return _asyncToGenerator(function* () {\n        \"disconnected\" !== _this77.connectionState && (_this77.stopUploadStats(), _this77.statsCollector.removeConnection(_this77.connectionId), _this77.connectionState = \"disconnected\", yield _this77.setSubscribeOptions({\n          audio: !1,\n          video: !1\n        }), yield _this77.closePC(a), _this77.removeAllListeners());\n      })();\n    }\n\n    getNetworkQuality() {\n      var a = this.pc.getStats();\n      if (!a.audioRecv[0] && !a.videoRecv[0]) return 1;\n      var b = Zb(this, H.NEED_SIGNAL_RTT),\n          c = a.rtt;\n      b = (c && b ? (c + b) / 2 : c || b) || 0;\n      c = a.audioRecv[0] ? a.audioRecv[0].jitterMs : void 0;\n      a = a.recvPacketLossRate;\n      let e = 70 * a / 50 + .3 * b / 1500;\n      c && (e = 60 * a / 50 + .2 * b / 1500 + .2 * c / 400);\n      return .1 > e ? 1 : .17 > e ? 2 : .36 > e ? 3 : .59 > e ? 4 : 5;\n    }\n\n    uploadStats(a) {\n      let b = this.user.audioTrack ? function (a, b) {\n        const c = a.audioRecv[0];\n        if (!c) return null;\n        a = {\n          id: qa(10, \"\"),\n          timestamp: new Date(a.timestamp).toISOString(),\n          mediaType: \"audio\",\n          type: \"ssrc\",\n          ssrc: c.ssrc.toString()\n        };\n        return a.bytesReceived = c.bytes.toString(), a.packetsLost = c.packetsLost.toString(), a.packetsReceived = c.packets.toString(), c.outputLevel ? a.A_aol = Math.round(100 * c.outputLevel).toString() : a.A_aol = Math.round(100 * b._source.getAudioAvgLevel()).toString(), a.A_apol = Math.round(100 * b._source.getAudioAvgLevel()).toString(), b && (a.A_artd = b._originMediaStreamTrack.enabled && b._mediaStreamTrack.enabled ? \"0\" : \"1\"), a.A_jr = c.jitterMs.toString(), a.A_jbm = Math.floor(c.jitterBufferMs).toString(), a.A_cdm = Math.floor(c.jitterBufferMs).toString(), a;\n      }(a, this.user.audioTrack) : void 0,\n          c = this.user.videoTrack ? function (a, b) {\n        const c = a.videoRecv[0];\n        if (!c) return null;\n        a = {\n          id: qa(10, \"\"),\n          timestamp: new Date(a.timestamp).toISOString(),\n          mediaType: \"video\",\n          type: \"ssrc\",\n          ssrc: c.ssrc.toString()\n        };\n        var e;\n        return a.bytesReceived = c.bytes.toString(), a.packetsLost = c.packetsLost.toString(), a.packetsReceived = c.packets.toString(), c.framesRateFirefox && (a.A_frr = c.framesRateFirefox.toString()), c.receivedFrame && (a.A_frr = c.receivedFrame.frameRate.toString()), a.A_frd = c.decodeFrameRate.toString(), c.outputFrame && (a.A_fro = c.outputFrame.frameRate.toString()), void 0 !== c.jitterBufferMs && (a.A_jbm = Math.floor(c.jitterBufferMs).toString()), void 0 !== c.currentDelayMs && (a.A_cdm = Math.floor(c.currentDelayMs).toString()), a.A_fs = c.firsCount.toString(), a.A_ns = c.nacksCount.toString(), a.A_ps = c.plisCount.toString(), b && (a.A_vrtd = b._originMediaStreamTrack.enabled && b._mediaStreamTrack.enabled ? \"0\" : \"1\"), b._player && 0 < b._player.freezeTimeCounterList.length && (a.A_vrft = Ia(e = b._player.freezeTimeCounterList).call(e, 0, 1)[0].toString()), a;\n      }(a, this.user.videoTrack) : void 0;\n      b && Za(() => this.emit(H.NEED_UPLOAD, qb.SUBSCRIBE_STATS, b));\n      c && Za(() => this.emit(H.NEED_UPLOAD, qb.SUBSCRIBE_STATS, c));\n    }\n\n    uploadSlowStats(a) {}\n\n    uploadRelatedStats(a, b) {\n      let c = !0 === this.pc._statsFilter.videoIsReady,\n          e = function (a, b, c) {\n        a = a.audioRecv[0];\n        if (!a) return null;\n        c = kd.isRemoteAudioFreeze(c);\n        return {\n          mediaType: \"audio\",\n          isAudioMute: !1,\n          peerId: b,\n          googJitterReceived: a.jitterMs.toString(),\n          isFreeze: c,\n          bytesReceived: a.bytes.toString(),\n          packetsReceived: a.packets.toString(),\n          packetsLost: a.packetsLost.toString(),\n          frameReceived: a.receivedFrames.toString(),\n          frameDropped: a.droppedFrames.toString()\n        };\n      }(a, this.getUserId(), this.user.audioTrack),\n          g = function (a, b, c, e, g) {\n        b = b.videoRecv[0];\n        if (!b) return null;\n        a = kd.isRemoteVideoFreeze(g, b, e ? e.videoRecv[0] : void 0) && a;\n        c = {\n          mediaType: \"video\",\n          isVideoMute: !1,\n          peerId: c,\n          frameRateReceived: b.receivedFrame && b.receivedFrame.frameRate.toString(),\n          frameRateDecoded: b.decodedFrame && b.decodedFrame.frameRate.toString(),\n          isFreeze: a,\n          bytesReceived: b.bytes.toString(),\n          packetsReceived: b.packets.toString(),\n          packetsLost: b.packetsLost.toString()\n        };\n        return b.framesRateFirefox && (c.frameRateDecoded = b.framesRateFirefox.toString(), c.frameRateReceived = b.framesRateFirefox.toString()), c;\n      }(c, a, this.getUserId(), b, this.user.videoTrack);\n\n      e && Za(() => {\n        this.emit(H.NEED_UPLOAD, qb.SUBSCRIBE_RELATED_STATS, e);\n      });\n      g && Za(() => {\n        this.emit(H.NEED_UPLOAD, qb.SUBSCRIBE_RELATED_STATS, g);\n      });\n    }\n\n    emitOnTrackFromUnusedTracks() {\n      if (this.subscribeOptions) {\n        var a = this.subscribeOptions.video;\n\n        if (this.subscribeOptions.audio) {\n          var b;\n          let a = R(b = this.unusedTracks).call(b, a => \"audio\" === a.kind && \"live\" === a.readyState);\n          Nc(this.unusedTracks, a);\n          a && this.onTrack(a);\n        }\n\n        if (a) {\n          var c;\n          a = R(c = this.unusedTracks).call(c, a => \"video\" === a.kind && \"live\" === a.readyState);\n          Nc(this.unusedTracks, a);\n          a && this.onTrack(a);\n        }\n      }\n    }\n\n    setSubscribeOptions(a) {\n      var _this78 = this;\n\n      return _asyncToGenerator(function* () {\n        var b, c, e, g;\n\n        if (a.audio !== _this78.subscribeOptions.audio || a.video !== _this78.subscribeOptions.video) {\n          if (\"connecting\" === _this78.connectionState) try {\n            yield _this78.createWaitConnectionConnectedPromise();\n          } catch (h) {\n            throw new n(l.OPERATION_ABORTED, \"can not update subscribe options, operation abort\");\n          }\n          a.audio === _this78.subscribeOptions.audio && a.video === _this78.subscribeOptions.video || (k.debug(m(b = m(c = m(e = m(g = \"[\".concat(_this78.connectionId, \"] update subscribe options [a: \")).call(g, _this78.subscribeOptions.audio, \", v: \")).call(e, _this78.subscribeOptions.video, \"] -> [a: \")).call(c, a.audio, \", v: \")).call(b, a.video, \"]\")), _this78.subscribeOptions = a, !a.audio && _this78.user._audioTrack && (_this78.unusedTracks.push(_this78.user._audioTrack._originMediaStreamTrack), _this78.user._audioTrack._destroy(), _this78.unbindTrackEvents(_this78.user._audioTrack), _this78.user._audioTrack = void 0), !a.video && _this78.user._videoTrack && (_this78.unusedTracks.push(_this78.user._videoTrack._originMediaStreamTrack), _this78.user._videoTrack._destroy(), _this78.unbindTrackEvents(_this78.user._videoTrack), _this78.user._videoTrack = void 0), _this78.emitOnTrackFromUnusedTracks());\n        }\n      })();\n    }\n\n    createPC() {\n      this.pc = new Mk({\n        turnServer: this.joinInfo.turnServer\n      });\n\n      this.pc.onFirstAudioDecoded = () => {\n        this.user.audioTrack && this.user.audioTrack.emit(gd.FIRST_FRAME_DECODED);\n        u.firstRemoteFrame(this.joinInfo.sid, Ca.FIRST_AUDIO_DECODE, ma.FIRST_AUDIO_DECODE, {\n          peer: this.user._uintid,\n          subscribeElapse: x() - this.startTime,\n          subscribeRequestid: this.ID,\n          p2pid: this.pc.ID\n        });\n      };\n\n      this.pc.onFirstAudioReceived = () => {\n        u.firstRemoteFrame(this.joinInfo.sid, Ca.FIRST_AUDIO_RECEIVED, ma.FIRST_AUDIO_RECEIVED, {\n          peer: this.user._uintid,\n          subscribeElapse: x() - this.startTime,\n          subscribeRequestid: this.ID,\n          p2pid: this.pc.ID\n        });\n      };\n\n      this.pc.onFirstVideoDecoded = (a, b) => {\n        u.firstRemoteFrame(this.joinInfo.sid, Ca.FIRST_VIDEO_DECODE, ma.FIRST_VIDEO_DECODE, {\n          peer: this.user._uintid,\n          videowidth: a,\n          videoheight: b,\n          subscribeElapse: x() - this.startTime,\n          subscribeRequestid: this.ID,\n          p2pid: this.pc.ID\n        });\n      };\n\n      this.pc.onFirstVideoReceived = () => {\n        u.firstRemoteFrame(this.joinInfo.sid, Ca.FIRST_VIDEO_RECEIVED, ma.FIRST_VIDEO_RECEIVED, {\n          peer: this.user._uintid,\n          subscribeElapse: x() - this.startTime,\n          subscribeRequestid: this.ID,\n          p2pid: this.pc.ID\n        });\n      };\n\n      this.updateICEPromise();\n    }\n\n    closePC(a) {\n      var _this79 = this;\n\n      return _asyncToGenerator(function* () {\n        return (_this79.pc.audioTrack && _this79.pc.audioTrack.stop(), _this79.pc.videoTrack && _this79.pc.videoTrack.stop(), _this79.pc.onTrack = void 0, _this79.pc.onICEConnectionStateChange = void 0, _this79.pc.close(), a) ? !1 : yield La(_this79, H.NEED_UNSUB);\n      })();\n    }\n\n    onPCDisconnected(a) {\n      u.subscribe(this.joinInfo.sid, {\n        lts: this.startTime,\n        succ: !1,\n        video: this.subscribeOptions.video,\n        audio: this.subscribeOptions.audio,\n        peerid: this.user.uid,\n        ec: a.code,\n        subscribeRequestid: this.ID,\n        p2pid: this.pc.ID\n      });\n    }\n\n    bindTrackEvents(a) {\n      a instanceof nd ? a.addListener(M.GET_STATS, this.handleGetRemoteAudioStats) : a instanceof md && a.addListener(M.GET_STATS, this.handleGetRemoteVideoStats);\n    }\n\n    unbindTrackEvents(a) {\n      a instanceof nd ? a.off(M.GET_STATS, this.handleGetRemoteAudioStats) : a instanceof md && a.off(M.GET_STATS, this.handleGetRemoteVideoStats);\n    }\n\n  }\n\n  class Ko extends Sa {\n    constructor(a, b, c, e) {\n      super();\n      this.reconnectMode = \"retry\";\n      this.commandReqId = this.reqId = 0;\n\n      this.handleWebSocketOpen = () => {\n        this.reconnectMode = \"retry\";\n        this.startPingPong();\n      };\n\n      this.handleWebSocketMessage = a => {\n        if (a.data) {\n          a = JSON.parse(a.data);\n          var b;\n          a.requestId ? this.emit(m(b = \"@\".concat(a.requestId, \"-\")).call(b, a.sid), a) : this.serviceMode === oa.INJECT ? this.emit(jb.INJECT_STREAM_STATUS, a) : (u.workerEvent(this.spec.sid, {\n            actionType: \"status\",\n            serverCode: a.code,\n            workerType: this.serviceMode === oa.TRANSCODE ? 1 : 2\n          }), this.emit(jb.PUBLISH_STREAM_STATUS, a));\n        }\n      };\n\n      this.spec = b;\n      this.token = a;\n      this.serviceMode = e;\n      this.websocket = new cg(\"live-streaming\", c);\n      this.websocket.on(S.CONNECTED, this.handleWebSocketOpen);\n      this.websocket.on(S.ON_MESSAGE, this.handleWebSocketMessage);\n      this.websocket.on(S.REQUEST_NEW_URLS, (a, b) => {\n        La(this, jb.REQUEST_NEW_ADDRESS).then(a).catch(b);\n      });\n      this.websocket.on(S.RECONNECTING, () => {\n        this.websocket.reconnectMode = this.reconnectMode;\n      });\n    }\n\n    init(a) {\n      return this.websocket.init(a);\n    }\n\n    request(a, b, c, e) {\n      var _this80 = this;\n\n      return _asyncToGenerator(function* () {\n        _this80.reqId += 1;\n        \"request\" === a && (_this80.commandReqId += 1);\n        let g = _this80.commandReqId,\n            h = _this80.reqId;\n        if (!h || !_this80.websocket) throw new n(l.UNEXPECTED_ERROR);\n        var k = Ze({\n          command: a,\n          sdkVersion: \"4.5.0\" === Ta ? \"0.0.1\" : Ta,\n          seq: h,\n          requestId: h,\n          allocate: c,\n          cname: _this80.spec.cname,\n          appId: _this80.spec.appId,\n          sid: _this80.spec.sid,\n          uid: _this80.spec.uid.toString(),\n          ts: Math.floor(x() / 1E3)\n        }, b);\n        if (\"closed\" === _this80.websocket.state) throw new n(l.WS_DISCONNECT);\n\n        let r = () => new A((a, b) => {\n          _this80.websocket.once(S.CLOSED, () => b(new n(l.WS_ABORT)));\n\n          _this80.websocket.once(S.CONNECTED, a);\n        });\n\n        \"connected\" !== _this80.websocket.state && (yield r());\n        k.clientRequest && (k.clientRequest.workerToken = _this80.token);\n        let t = new A((a, b) => {\n          var c;\n\n          const e = () => {\n            b(new n(l.WS_ABORT));\n          };\n\n          _this80.websocket.once(S.RECONNECTING, e);\n\n          _this80.websocket.once(S.CLOSED, e);\n\n          _this80.once(m(c = \"@\".concat(h, \"-\")).call(c, _this80.spec.sid), b => {\n            a(b);\n          });\n        });\n        e && u.workerEvent(_this80.spec.sid, Ze({}, e, {\n          requestId: g,\n          actionType: \"request\",\n          payload: w(b.clientRequest),\n          serverCode: 0,\n          code: 0\n        }));\n        let y = x();\n\n        _this80.websocket.sendMessage(k);\n\n        k = null;\n\n        try {\n          k = yield t;\n        } catch (ua) {\n          if (\"closed\" === _this80.websocket.state) throw ua;\n          return yield r(), yield _this80.request(a, b, c);\n        }\n\n        return e && u.workerEvent(_this80.spec.sid, Ze({}, e, {\n          requestId: g,\n          actionType: \"response\",\n          payload: w(k.serverResponse),\n          serverCode: k.code,\n          success: 200 === k.code,\n          responseTime: x() - y\n        })), 200 !== k.code && _this80.handleResponseError(k), k;\n      })();\n    }\n\n    tryNextAddress() {\n      this.reconnectMode = \"tryNext\";\n      this.websocket.reconnect(\"tryNext\");\n    }\n\n    close() {\n      let a = \"4.5.0\" === Ta ? \"0.0.1\" : Ta;\n      this.reqId += 1;\n      \"connected\" === this.websocket.state ? (this.websocket.sendMessage({\n        command: \"request\",\n        appId: this.spec.appId,\n        cname: this.spec.cname,\n        uid: this.spec.uid.toString(),\n        sdkVersion: a,\n        sid: this.spec.sid,\n        seq: this.reqId,\n        ts: Math.floor(x() / 1E3),\n        requestId: this.reqId,\n        clientRequest: {\n          command: \"DestroyWorker\"\n        }\n      }), this.websocket.close(!1, !0)) : this.websocket.close(!1);\n      this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);\n    }\n\n    handleResponseError(a) {\n      switch (a.code) {\n        case ja.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:\n          return void k.warning(\"live stream response already exists stream\");\n\n        case ja.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:\n        case ja.LIVE_STREAM_RESPONSE_BAD_STREAM:\n        case ja.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:\n          return new n(l.LIVE_STREAMING_INVALID_ARGUMENT, \"\", {\n            code: a.code\n          }).throw();\n\n        case ja.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:\n          if (\"UnpublishStream\" === a.serverResponse.command || \"UninjectStream\" === a.serverResponse.command) break;\n          throw new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream response wm worker not exist\", {\n            retry: !0\n          });\n\n        case ja.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:\n          return new n(l.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, \"\", {\n            code: a.code\n          }).throw();\n\n        case ja.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:\n          var b = new n(l.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);\n          return this.emit(jb.WARNING, b, a.serverResponse.url);\n\n        case ja.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN:\n          return b = new n(l.LIVE_STREAMING_WARN_FREQUENT_REQUEST), this.emit(jb.WARNING, b, a.serverResponse.url);\n\n        case ja.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:\n          throw new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream response wm worker not exist\", {\n            retry: !0\n          });\n\n        case ja.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:\n          return new n(l.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, \"\", {\n            code: a.code\n          }).throw();\n\n        case ja.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM:\n          return b = new n(l.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT), this.emit(jb.WARNING, b, a.serverResponse.url);\n\n        case ja.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:\n          return new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"\", {\n            code: a.code\n          }).throw();\n\n        case ja.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:\n          throw new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream resource limit\", {\n            retry: !0,\n            changeAddress: !0\n          });\n\n        case ja.LIVE_STREAM_RESPONSE_WORKER_LOST:\n        case ja.LIVE_STREAM_RESPONSE_WORKER_QUIT:\n          if (\"UnpublishStream\" === a.serverResponse.command || \"UninjectStream\" === a.serverResponse.command) break;\n          throw new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            retry: !0,\n            changeAddress: !0\n          });\n\n        case ja.ERROR_FAIL_SEND_MESSAGE:\n          if (\"UnpublishStream\" === a.serverResponse.command || \"UninjectStream\" === a.serverResponse.command) break;\n          if (\"UpdateTranscoding\" === a.serverResponse.command || \"ControlStream\" === a.serverResponse.command) return new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            code: a.code\n          }).throw();\n          throw new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            retry: !0,\n            changeAddress: !0\n          });\n\n        case ja.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:\n        case ja.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:\n        case ja.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:\n        case ja.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:\n          return new n(l.LIVE_STREAMING_CDN_ERROR, \"\", {\n            code: a.code\n          }).throw();\n      }\n    }\n\n    startPingPong() {\n      this.pingpongTimer && window.clearInterval(this.pingpongTimer);\n      this.pingpongTimer = window.setInterval(() => {\n        \"connected\" === this.websocket.state && this.request(\"ping\", {}).catch(bg);\n      }, 6E3);\n    }\n\n  }\n\n  class Lo extends Sa {\n    constructor(a, b = Qa, c = Qa) {\n      super();\n      this.retryTimeout = 1E4;\n      this.streamingTasks = new aa();\n      this.isStartingStreamingTask = !1;\n      this.taskMutex = new Mb(\"live-streaming\");\n      this.cancelToken = zb.CancelToken.source();\n      this.injectConfig = Rb({}, Vn);\n      this.injectLoopTimes = 0;\n      this.lastTaskId = 1;\n      this.statusError = new aa();\n      this.spec = a;\n      this.httpRetryConfig = c;\n      this.wsRetryConfig = b;\n    }\n\n    setTranscodingConfig(a) {\n      var _this81 = this;\n\n      return _asyncToGenerator(function* () {\n        var b;\n        let c = Rb({}, Un, {}, a);\n        var e, g;\n        66 !== c.videoCodecProfile && 77 !== c.videoCodecProfile && 100 !== c.videoCodecProfile && (k.debug(m(e = \"[\".concat(_this81.spec.clientId, \"] set transcoding config, fix video codec profile: \")).call(e, c.videoCodecProfile, \" -> 100\")), c.videoCodecProfile = 100);\n        (c.transcodingUsers || (c.transcodingUsers = c.userConfigs), c.transcodingUsers) && (c.transcodingUsers = E(g = c.transcodingUsers).call(g, a => Rb({}, Tn, {}, a, {\n          zOrder: a.zOrder ? a.zOrder + 1 : 1\n        })));\n        !function (a) {\n          var b, c;\n          null == a.width || W(a.width, \"config.width\", 0, 1E4);\n          null == a.height || W(a.height, \"config.height\", 0, 1E4);\n          null == a.videoBitrate || W(a.videoBitrate, \"config.videoBitrate\", 1, 1E6);\n          null == a.videoFrameRate || W(a.videoFrameRate, \"config.videoFrameRate\");\n          null == a.lowLatency || Be(a.lowLatency, \"config.lowLatency\");\n          null == a.audioSampleRate || Ka(a.audioSampleRate, \"config.audioSampleRate\", [32E3, 44100, 48E3]);\n          null == a.audioBitrate || W(a.audioBitrate, \"config.audioBitrate\", 1, 128);\n          null == a.audioChannels || Ka(a.audioChannels, \"config.audioChannels\", [1, 2, 3, 4, 5]);\n          null == a.videoGop || W(a.videoGop, \"config.videoGop\");\n          null == a.videoCodecProfile || Ka(a.videoCodecProfile, \"config.videoCodecProfile\", [66, 77, 100]);\n          null == a.userCount || W(a.userCount, \"config.userCount\", 0, 17);\n          null == a.backgroundColor || W(a.backgroundColor, \"config.backgroundColor\", 0, 16777215);\n          null == a.userConfigExtraInfo || Fa(a.userConfigExtraInfo, \"config.userConfigExtraInfo\", 0, 4096, !1);\n          a.transcodingUsers && null != a.transcodingUsers && (dh(a.transcodingUsers, \"config.transcodingUsers\"), q(b = a.transcodingUsers).call(b, (a, b) => {\n            De(a.uid);\n            null == a.x || W(a.x, \"transcodingUser[\".concat(b, \"].x\"), 0, 1E4);\n            null == a.y || W(a.y, \"transcodingUser[\".concat(b, \"].y\"), 0, 1E4);\n            null == a.width || W(a.width, \"transcodingUser[\".concat(b, \"].width\"), 0, 1E4);\n            null == a.height || W(a.height, \"transcodingUser[\".concat(b, \"].height\"), 0, 1E4);\n            null == a.zOrder || W(a.zOrder - 1, \"transcodingUser[\".concat(b, \"].zOrder\"), 0, 100);\n            null == a.alpha || W(a.alpha, \"transcodingUser[\".concat(b, \"].alpha\"), 0, 1, !1);\n          }));\n          null == a.watermark || Ee(a.watermark, \"watermark\");\n          null == a.backgroundImage || Ee(a.backgroundImage, \"backgroundImage\");\n          a.images && null != a.images && (dh(a.images, \"config.images\"), q(c = a.images).call(c, (a, b) => {\n            Ee(a, \"images[\".concat(b, \"]\"));\n          }));\n        }(c);\n        a = [];\n        var h, l;\n        c.images && a.push(...E(h = c.images).call(h, a => Rb({}, Sf, {}, a, {\n          zOrder: 255\n        })));\n        (c.backgroundImage && (a.push(Rb({}, Sf, {}, c.backgroundImage, {\n          zOrder: 0\n        })), delete c.backgroundImage), c.watermark && (a.push(Rb({}, Sf, {}, c.watermark, {\n          zOrder: 255\n        })), delete c.watermark), c.images = a, c.transcodingUsers) && (c.userConfigs = E(l = c.transcodingUsers).call(l, a => Rb({}, a)), c.userCount = c.transcodingUsers.length, delete c.transcodingUsers);\n        h = E(b = c.userConfigs || []).call(b, a => \"number\" == typeof a.uid ? A.resolve(a.uid) : Hh(a.uid, _this81.spec, _this81.cancelToken.token, _this81.httpRetryConfig));\n        b = yield A.all(h);\n        if (q(b).call(b, (a, b) => {\n          c.userConfigs && c.userConfigs[b] && (c.userConfigs[b].uid = a);\n        }), _this81.transcodingConfig = c, _this81.connection) try {\n          var r, n, y;\n          let a = yield _this81.connection.request(\"request\", {\n            clientRequest: {\n              command: \"UpdateTranscoding\",\n              transcodingConfig: _this81.transcodingConfig\n            }\n          }, !1, {\n            command: \"UpdateTranscoding\",\n            workerType: 1,\n            requestByUser: !0,\n            tid: E(r = Gb(ic(n = _this81.streamingTasks).call(n))).call(r, a => a.taskId).join(\"#\")\n          });\n          k.debug(m(y = \"[\".concat(_this81.spec.clientId, \"] update live transcoding config success, code: \")).call(y, a.code, \", config:\"), w(_this81.transcodingConfig));\n        } catch (D) {\n          var u;\n          if (!D.data || !D.data.retry) throw D;\n          D.data.changeAddress && _this81.connection.tryNextAddress();\n          q(u = _this81.streamingTasks).call(u, a => {\n            k.warning(\"[\".concat(_this81.spec.clientId, \"] live streaming receive error\"), D.toString(), \"try to republish\", a.url);\n\n            _this81.startLiveStreamingTask(a.url, a.mode, D).then(() => {\n              var b;\n              k.debug(m(b = \"[\".concat(_this81.spec.clientId, \"] live streaming republish \")).call(b, a.url, \" success\"));\n            }).catch(b => {\n              k.error(\"[\".concat(_this81.spec.clientId, \"] live streaming republish failed\"), a.url, b.toString());\n              _this81.onLiveStreamError && _this81.onLiveStreamError(a.url, b);\n            });\n          });\n        }\n      })();\n    }\n\n    setInjectStreamConfig(a, b) {\n      this.injectConfig = Ga({}, this.injectConfig, a);\n      this.injectLoopTimes = b;\n    }\n\n    startLiveStreamingTask(a, b, c) {\n      var _this82 = this;\n\n      return _asyncToGenerator(function* () {\n        var e, g, h, p;\n        if (R(e = Gb(ic(g = _this82.streamingTasks).call(g))).call(e, a => a.mode === oa.INJECT) && b === oa.INJECT) return new n(l.LIVE_STREAMING_TASK_CONFLICT, \"inject stream over limit\").throw();\n        if (!_this82.transcodingConfig && b === oa.TRANSCODE) throw new n(l.INVALID_OPERATION, \"[LiveStreaming] no transcoding config found, can not start transcoding streaming task\");\n        e = {\n          command: \"PublishStream\",\n          ts: x(),\n          url: a,\n          uid: _this82.spec.uid.toString(),\n          autoDestroyTime: 100,\n          acceptImageTimeout: !0\n        };\n        k.debug(m(h = m(p = \"[\".concat(_this82.spec.clientId, \"] start live streaming \")).call(p, a, \", mode: \")).call(h, b));\n        h = yield _this82.taskMutex.lock();\n        if (!_this82.connection && c) return void h();\n        if (_this82.streamingTasks.get(a) && !c) return h(), new n(l.LIVE_STREAMING_TASK_CONFLICT).throw();\n\n        try {\n          _this82.connection || (_this82.connection = yield _this82.connect(b));\n        } catch (t) {\n          throw h(), t;\n        }\n\n        switch (b) {\n          case oa.TRANSCODE:\n            e.transcodingConfig = Rb({}, _this82.transcodingConfig);\n            break;\n\n          case oa.INJECT:\n            e = {\n              cname: _this82.spec.cname,\n              command: \"InjectStream\",\n              sid: _this82.spec.sid,\n              transcodingConfig: _this82.injectConfig,\n              ts: x(),\n              url: a,\n              loopTimes: _this82.injectLoopTimes\n            };\n        }\n\n        _this82.uapResponse && _this82.uapResponse.vid && (e.vid = _this82.uapResponse.vid);\n        _this82.isStartingStreamingTask = !0;\n        p = _this82.lastTaskId++;\n\n        try {\n          var r;\n          let g = new A((b, e) => {\n            wb(_this82.retryTimeout).then(() => {\n              if (c) return e(c);\n\n              const b = _this82.statusError.get(a);\n\n              return b ? (_this82.statusError.delete(a), e(b)) : void 0;\n            });\n          }),\n              l = yield A.race([_this82.connection.request(\"request\", {\n            clientRequest: e\n          }, !0, {\n            url: a,\n            command: \"PublishStream\",\n            workerType: b === oa.TRANSCODE ? 1 : 2,\n            requestByUser: !c,\n            tid: p.toString()\n          }), g]);\n          _this82.isStartingStreamingTask = !1;\n          k.debug(m(r = \"[\".concat(_this82.spec.clientId, \"] live streaming started, code: \")).call(r, l.code));\n\n          _this82.streamingTasks.set(a, {\n            clientRequest: e,\n            mode: b,\n            url: a,\n            taskId: p\n          });\n\n          h();\n        } catch (t) {\n          if (h(), _this82.isStartingStreamingTask = !1, !t.data || !t.data.retry || c) throw t;\n          return t.data.changeAddress ? (_this82.connection.tryNextAddress(), yield _this82.startLiveStreamingTask(a, b, t)) : yield _this82.startLiveStreamingTask(a, b, t);\n        }\n      })();\n    }\n\n    stopLiveStreamingTask(a) {\n      return new A((b, c) => {\n        let e = this.streamingTasks.get(a);\n        if (!e || !this.connection) return new n(l.UNEXPECTED_ERROR, \"can not find streaming task to stop\").throw();\n        let g = e.mode;\n\n        e.abortTask = () => {\n          k.debug(\"[\".concat(this.spec.clientId, \"] stop live streaming success(worker exception)\"));\n          this.streamingTasks.delete(a);\n          b();\n        };\n\n        this.connection.request(\"request\", {\n          clientRequest: {\n            command: g === oa.INJECT ? \"UninjectStream\" : \"UnpublishStream\",\n            url: e.url\n          }\n        }, !1, {\n          url: a,\n          command: \"UnPublishStream\",\n          workerType: g === oa.TRANSCODE ? 1 : 2,\n          requestByUser: !0,\n          tid: (this.lastTaskId++).toString()\n        }).then(c => {\n          var e;\n          k.debug(m(e = \"[\".concat(this.spec.clientId, \"] stop live streaming success, code: \")).call(e, c.code));\n          this.streamingTasks.delete(a);\n          0 === this.streamingTasks.size && g !== oa.INJECT && (this.connection && this.connection.close(), this.connection = void 0);\n          b();\n          g === oa.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(5, this.spec.uid, a);\n        }).catch(c);\n      });\n    }\n\n    controlInjectStream(a, b, c, e) {\n      var _this83 = this;\n\n      return _asyncToGenerator(function* () {\n        let g = _this83.streamingTasks.get(a);\n\n        if (!g || !_this83.connection || g.mode !== oa.INJECT) throw new n(l.INVALID_OPERATION, \"can not find inject stream task to control\");\n        return (yield _this83.connection.request(\"request\", {\n          clientRequest: {\n            command: \"ControlStream\",\n            url: a,\n            control: b,\n            audioVolume: c,\n            position: e\n          }\n        })).serverResponse;\n      })();\n    }\n\n    resetAllTask() {\n      var a;\n      let b = Gb(ic(a = this.streamingTasks).call(a));\n      this.terminate();\n\n      for (let a of b) this.startLiveStreamingTask(a.url, a.mode).catch(b => {\n        this.onLiveStreamError && this.onLiveStreamError(a.url, b);\n      });\n    }\n\n    terminate() {\n      this.cancelToken && this.cancelToken.cancel();\n      this.streamingTasks = new aa();\n      this.isStartingStreamingTask = !1;\n      this.statusError = new aa();\n      this.cancelToken = zb.CancelToken.source();\n      this.uapResponse = void 0;\n      this.connection && this.connection.close();\n      this.connection = void 0;\n    }\n\n    connect(a) {\n      var _this84 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this84.connection) throw new n(l.UNEXPECTED_ERROR, \"live streaming connection has already connected\");\n        let b = yield La(_this84, Ec.REQUEST_WORKER_MANAGER_LIST, a);\n        return _this84.uapResponse = b, _this84.connection = new Ko(b.workerToken, _this84.spec, _this84.wsRetryConfig, a), _this84.connection.on(jb.WARNING, (a, b) => _this84.onLiveStreamWarning && _this84.onLiveStreamWarning(b, a)), _this84.connection.on(jb.PUBLISH_STREAM_STATUS, a => _this84.handlePublishStreamServer(a)), _this84.connection.on(jb.INJECT_STREAM_STATUS, a => _this84.handleInjectStreamServerStatus(a)), _this84.connection.on(jb.REQUEST_NEW_ADDRESS, (b, e) => {\n          if (!_this84.connection) return e(new n(l.UNEXPECTED_ERROR, \"can not get new live streaming address list\"));\n          La(_this84, Ec.REQUEST_WORKER_MANAGER_LIST, a).then(a => {\n            _this84.uapResponse = a;\n            b(a.addressList);\n          }).catch(e);\n        }), yield _this84.connection.init(b.addressList), _this84.connection;\n      })();\n    }\n\n    handlePublishStreamServer(a) {\n      var b = a.serverStatus && a.serverStatus.url || \"empty_url\";\n      let c = this.streamingTasks.get(b),\n          e = a.reason;\n\n      switch (a.code) {\n        case ja.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:\n        case ja.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:\n        case ja.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:\n        case ja.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:\n          a = new n(l.LIVE_STREAMING_CDN_ERROR, \"\", {\n            code: a.code\n          });\n          if (c) return k.error(a.toString()), this.onLiveStreamError && this.onLiveStreamError(b, a);\n          if (!this.isStartingStreamingTask) break;\n          this.statusError.set(b, a);\n\n        case ja.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:\n          return a = new n(l.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, e), this.onLiveStreamWarning && this.onLiveStreamWarning(b, a);\n\n        case ja.LIVE_STREAM_RESPONSE_WORKER_LOST:\n        case ja.LIVE_STREAM_RESPONSE_WORKER_QUIT:\n          var g;\n\n          if (this.connection) {\n            this.connection.tryNextAddress();\n            b = Gb(ic(g = this.streamingTasks).call(g));\n\n            for (let c of b) c.abortTask ? c.abortTask() : (k.warning(\"[\".concat(this.spec.clientId, \"] publish stream status code\"), a.code, \"try to republish\", c.url), this.startLiveStreamingTask(c.url, c.mode, new n(l.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"\", {\n              code: a.code\n            })).then(() => {\n              k.debug(\"[\".concat(this.spec.clientId, \"] republish live stream success\"), c.url);\n            }).catch(a => {\n              k.error(a.toString());\n              this.onLiveStreamError && this.onLiveStreamError(c.url, a);\n            }));\n          }\n\n      }\n    }\n\n    handleInjectStreamServerStatus(a) {\n      let b = Number(a.uid),\n          c = a.serverStatus && a.serverStatus.url;\n\n      switch (a.code) {\n        case 200:\n          return void (this.onInjectStatusChange && this.onInjectStatusChange(0, b, c));\n\n        case 451:\n          return this.onInjectStatusChange && this.onInjectStatusChange(1, b, c), void this.streamingTasks.delete(c);\n\n        case 453:\n          return this.onInjectStatusChange && this.onInjectStatusChange(2, b, c), void this.streamingTasks.delete(c);\n\n        case 470:\n          return this.onInjectStatusChange && this.onInjectStatusChange(10, b, c), void this.streamingTasks.delete(c);\n\n        case 499:\n          return this.onInjectStatusChange && this.onInjectStatusChange(3, b, c), void this.streamingTasks.delete(c);\n\n        default:\n          return void k.debug(\"inject stream server status\", a);\n      }\n    }\n\n    hasUrl(a) {\n      return this.streamingTasks.has(a);\n    }\n\n  }\n\n  class Zh {\n    constructor() {\n      this.destChannelMediaInfos = new aa();\n    }\n\n    setSrcChannelInfo(a) {\n      ih(a);\n      this.srcChannelMediaInfo = a;\n    }\n\n    addDestChannelInfo(a) {\n      ih(a);\n      this.destChannelMediaInfos.set(a.channelName, a);\n    }\n\n    removeDestChannelInfo(a) {\n      Ce(a);\n      this.destChannelMediaInfos.delete(a);\n    }\n\n    getSrcChannelMediaInfo() {\n      return this.srcChannelMediaInfo;\n    }\n\n    getDestChannelMediaInfo() {\n      return this.destChannelMediaInfos;\n    }\n\n  }\n\n  class Mo extends Sa {\n    constructor(a, b, c) {\n      super();\n      this.requestId = 1;\n\n      this.onOpen = () => {\n        this.emit(\"open\");\n        this.startHeartBeatCheck();\n      };\n\n      this.onClose = a => {\n        this.emit(\"close\");\n        this.dispose();\n      };\n\n      this.onMessage = a => {\n        a = JSON.parse(a.data);\n        if (!a || \"serverResponse\" !== a.command || !a.requestId) return a && \"serverStatus\" === a.command && a.serverStatus && a.serverStatus.command ? (this.emit(\"status\", a.serverStatus), void this.emit(a.serverStatus.command, a.serverStatus)) : void 0;\n        this.emit(\"req_\".concat(a.requestId), a);\n      };\n\n      this.joinInfo = a;\n      this.clientId = b;\n      this.ws = new cg(\"cross-channel-\".concat(this.clientId), c);\n      this.ws.on(S.RECONNECTING, () => {\n        this.ws.reconnectMode = \"retry\";\n        this.emit(\"reconnecting\");\n      });\n      this.ws.on(S.CONNECTED, this.onOpen);\n      this.ws.on(S.ON_MESSAGE, this.onMessage);\n      this.ws.on(S.CLOSED, this.onClose);\n    }\n\n    isConnect() {\n      return \"connected\" === this.ws.state;\n    }\n\n    sendMessage(a) {\n      let b = this.requestId++;\n      return a.requestId = b, a.seq = b, this.ws.sendMessage(a), b;\n    }\n\n    waitStatus(a) {\n      return new A((b, c) => {\n        let e = window.setTimeout(() => {\n          c(new n(l.TIMEOUT, \"wait status timeout, status: \".concat(a)));\n        }, 5E3);\n        this.once(a, g => {\n          window.clearTimeout(e);\n          g.state && 0 !== g.state ? c(new n(l.CROSS_CHANNEL_WAIT_STATUS_ERROR, \"wait status error, status: \".concat(a))) : b(void 0);\n        });\n        this.once(\"dispose\", () => {\n          window.clearTimeout(e);\n          c(new n(l.WS_ABORT));\n        });\n      });\n    }\n\n    request(a) {\n      var _this85 = this;\n\n      return _asyncToGenerator(function* () {\n        if (\"closed\" === _this85.ws.state) throw new n(l.WS_DISCONNECT);\n\n        let b = () => new A((a, b) => {\n          _this85.ws.once(S.CLOSED, () => b(new n(l.WS_ABORT)));\n\n          _this85.ws.once(S.CONNECTED, a);\n        });\n\n        \"connected\" !== _this85.ws.state && (yield b());\n\n        let c = _this85.sendMessage(a);\n\n        a = yield new A((a, b) => {\n          const e = () => {\n            b(new n(l.WS_ABORT));\n          };\n\n          _this85.ws.once(S.RECONNECTING, e);\n\n          _this85.ws.once(S.CLOSED, e);\n\n          _this85.once(\"req_\".concat(c), a);\n\n          wb(3E3).then(() => {\n            _this85.removeAllListeners(\"req_\".concat(c));\n\n            _this85.ws.off(S.RECONNECTING, e);\n\n            _this85.ws.off(S.CLOSED, e);\n\n            b(new n(l.TIMEOUT, \"cross channel ws request timeout\"));\n          });\n        });\n        if (!a || 200 !== a.code) throw new n(l.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, \"response: \".concat(w(a)));\n        return a;\n      })();\n    }\n\n    connect(a) {\n      var _this86 = this;\n\n      return _asyncToGenerator(function* () {\n        _this86.ws.removeAllListeners(S.REQUEST_NEW_URLS);\n\n        _this86.ws.on(S.REQUEST_NEW_URLS, b => {\n          b(a);\n        });\n\n        yield _this86.ws.init(a);\n      })();\n    }\n\n    dispose() {\n      this.clearHeartBeatCheck();\n      this.emit(\"dispose\");\n      this.removeAllListeners();\n      this.ws.close();\n    }\n\n    sendPing(a) {\n      let b = this.requestId++;\n      return a.requestId = b, this.ws.sendMessage(a), b;\n    }\n\n    startHeartBeatCheck() {\n      this.heartBeatTimer = window.setInterval(() => {\n        this.sendPing({\n          command: \"ping\",\n          appId: this.joinInfo.appId,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid.toString(),\n          sid: this.joinInfo.sid,\n          ts: +new Date(),\n          requestId: 0\n        });\n      }, 3E3);\n    }\n\n    clearHeartBeatCheck() {\n      window.clearInterval(this.heartBeatTimer);\n      this.heartBeatTimer = void 0;\n    }\n\n  }\n\n  class No extends Sa {\n    constructor(a, b, c, e) {\n      var _this87;\n\n      super();\n      _this87 = this;\n      this.cancelToken = zb.CancelToken.source();\n      this.requestId = 0;\n      this._state = \"RELAY_STATE_IDLE\";\n      this.errorCode = \"RELAY_OK\";\n\n      this.onStatus = a => {\n        var b;\n        k.debug(m(b = \"[\".concat(this.clientId, \"] ChannelMediaStatus: \")).call(b, w(a)));\n        a && a.command && (\"onAudioPacketReceived\" === a.command && this.emit(\"event\", \"PACKET_RECEIVED_AUDIO_FROM_SRC\"), \"onVideoPacketReceived\" === a.command && this.emit(\"event\", \"PACKET_RECEIVED_VIDEO_FROM_SRC\"), \"onSrcTokenPrivilegeDidExpire\" === a.command && (this.errorCode = \"SRC_TOKEN_EXPIRED\", this.state = \"RELAY_STATE_FAILURE\"), \"onDestTokenPrivilegeDidExpire\" === a.command && (this.errorCode = \"DEST_TOKEN_EXPIRED\", this.state = \"RELAY_STATE_FAILURE\"));\n      };\n\n      this.onReconnect = /*#__PURE__*/_asyncToGenerator(function* () {\n        k.debug(\"[\".concat(_this87.clientId, \"] ChannelMediaSocket disconnect, reconnecting\"));\n\n        _this87.emit(\"event\", \"NETWORK_DISCONNECTED\");\n\n        _this87.state = \"RELAY_STATE_IDLE\";\n        _this87.prevChannelMediaConfig && _this87.sendStartRelayMessage(_this87.prevChannelMediaConfig).catch(a => {\n          \"RELAY_STATE_IDLE\" !== _this87.state && (k.error(\"auto restart channel media relay failed\", a.toString()), _this87.errorCode = \"SERVER_CONNECTION_LOST\", _this87.state = \"RELAY_STATE_FAILURE\");\n        });\n      });\n      this.joinInfo = a;\n      this.clientId = b;\n      this.signal = new Mo(this.joinInfo, this.clientId, c);\n      this.httpRetryConfig = e;\n    }\n\n    set state(a) {\n      a !== this._state && (\"RELAY_STATE_FAILURE\" !== a && (this.errorCode = \"RELAY_OK\"), this.emit(\"state\", a, this.errorCode), this._state = a);\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    startChannelMediaRelay(a) {\n      var _this88 = this;\n\n      return _asyncToGenerator(function* () {\n        if (\"RELAY_STATE_IDLE\" !== _this88.state) throw new n(l.INVALID_OPERATION);\n        _this88.state = \"RELAY_STATE_CONNECTING\";\n        yield _this88.connect();\n        k.debug(\"[\".concat(_this88.clientId, \"] startChannelMediaRelay: connect success\"));\n\n        try {\n          yield _this88.sendStartRelayMessage(a);\n        } catch (b) {\n          if (b.data && b.data.serverResponse && \"SetSourceChannel\" === b.data.serverResponse.command) throw new n(l.CROSS_CHANNEL_FAILED_JOIN_SRC);\n          if (b.data && b.data.serverResponse && \"SetDestChannelStatus\" === b.serverResponse.command) throw new n(l.CROSS_CHANNEL_FAILED_JOIN_DEST);\n          if (b.data && b.data.serverResponse && \"StartPacketTransfer\" === b.serverResponse.command) throw new n(l.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);\n          throw b;\n        }\n\n        _this88.prevChannelMediaConfig = a;\n      })();\n    }\n\n    updateChannelMediaRelay(a) {\n      var _this89 = this;\n\n      return _asyncToGenerator(function* () {\n        if (\"RELAY_STATE_RUNNING\" !== _this89.state) throw new n(l.INVALID_OPERATION);\n        yield _this89.sendUpdateMessage(a);\n        _this89.prevChannelMediaConfig = a;\n      })();\n    }\n\n    stopChannelMediaRelay() {\n      var _this90 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this90.sendStopRelayMessage();\n        k.debug(\"[\".concat(_this90.clientId, \"] stopChannelMediaRelay: send stop message success\"));\n        _this90.state = \"RELAY_STATE_IDLE\";\n\n        _this90.dispose();\n      })();\n    }\n\n    dispose() {\n      k.debug(\"[\".concat(this.clientId, \"] disposeChannelMediaRelay\"));\n      this.cancelToken.cancel();\n      this.cancelToken = zb.CancelToken.source();\n      this.state = \"RELAY_STATE_IDLE\";\n      this.emit(\"dispose\");\n      this.signal.dispose();\n      this.prevChannelMediaConfig = void 0;\n    }\n\n    connect() {\n      var _this91 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = yield xl(_this91.joinInfo, _this91.cancelToken.token, _this91.httpRetryConfig);\n        _this91.workerToken = a.workerToken;\n        yield _this91.signal.connect(a.addressList);\n\n        _this91.emit(\"event\", \"NETWORK_CONNECTED\");\n\n        _this91.signal.on(\"status\", _this91.onStatus);\n\n        _this91.signal.on(\"reconnecting\", _this91.onReconnect);\n      })();\n    }\n\n    sendStartRelayMessage(a) {\n      var _this92 = this;\n\n      return _asyncToGenerator(function* () {\n        var b = _this92.genMessage(Ea.StopPacketTransfer);\n\n        yield _this92.signal.request(b);\n        yield _this92.signal.waitStatus(\"Normal Quit\");\n        k.debug(\"[\".concat(_this92.clientId, \"] startChannelMediaRelay: StopPacketTransfer success\"));\n        b = _this92.genMessage(Ea.SetSdkProfile, a);\n        yield _this92.signal.request(b);\n        k.debug(\"[\".concat(_this92.clientId, \"] startChannelMediaRelay: SetSdkProfile success\"));\n        b = _this92.genMessage(Ea.SetSourceChannel, a);\n        yield _this92.signal.request(b);\n        yield _this92.signal.waitStatus(\"SetSourceChannelStatus\");\n\n        _this92.emit(\"event\", \"PACKET_JOINED_SRC_CHANNEL\");\n\n        k.debug(\"[\".concat(_this92.clientId, \"] startChannelMediaRelay: SetSourceChannel success\"));\n        b = _this92.genMessage(Ea.SetSourceUserId, a);\n        yield _this92.signal.request(b);\n        k.debug(\"[\".concat(_this92.clientId, \"] startChannelMediaRelay: SetSourceUserId success\"));\n        b = _this92.genMessage(Ea.SetDestChannel, a);\n        yield _this92.signal.request(b);\n        yield _this92.signal.waitStatus(\"SetDestChannelStatus\");\n\n        _this92.emit(\"event\", \"PACKET_JOINED_DEST_CHANNEL\");\n\n        k.debug(\"[\".concat(_this92.clientId, \"] startChannelMediaRelay: SetDestChannel success\"));\n        a = _this92.genMessage(Ea.StartPacketTransfer, a);\n        yield _this92.signal.request(a);\n\n        _this92.emit(\"event\", \"PACKET_SENT_TO_DEST_CHANNEL\");\n\n        _this92.state = \"RELAY_STATE_RUNNING\";\n        k.debug(\"[\".concat(_this92.clientId, \"] startChannelMediaRelay: StartPacketTransfer success\"));\n      })();\n    }\n\n    sendUpdateMessage(a) {\n      var _this93 = this;\n\n      return _asyncToGenerator(function* () {\n        a = _this93.genMessage(Ea.UpdateDestChannel, a);\n        yield _this93.signal.request(a);\n\n        _this93.emit(\"event\", \"PACKET_UPDATE_DEST_CHANNEL\");\n\n        k.debug(\"[\".concat(_this93.clientId, \"] sendUpdateMessage: UpdateDestChannel success\"));\n      })();\n    }\n\n    sendStopRelayMessage() {\n      var _this94 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = _this94.genMessage(Ea.StopPacketTransfer);\n\n        yield _this94.signal.request(a);\n        k.debug(\"[\".concat(_this94.clientId, \"] sendStopRelayMessage: StopPacketTransfer success\"));\n      })();\n    }\n\n    genMessage(a, b) {\n      let c = [],\n          e = [],\n          g = [];\n      this.requestId += 1;\n      let h = {\n        appId: this.joinInfo.appId,\n        cname: this.joinInfo.cname,\n        uid: this.joinInfo.uid.toString(),\n        sdkVersion: Ta,\n        sid: this.joinInfo.sid,\n        ts: x(),\n        requestId: this.requestId,\n        seq: this.requestId,\n        allocate: !0,\n        clientRequest: {}\n      };\n      \"4.5.0\" === h.sdkVersion && (h.sdkVersion = \"0.0.1\");\n      let k = null,\n          m = null;\n\n      switch (a) {\n        case Ea.SetSdkProfile:\n          return h.clientRequest = {\n            command: \"SetSdkProfile\",\n            type: \"multi_channel\"\n          }, h;\n\n        case Ea.SetSourceChannel:\n          if (m = b && b.getSrcChannelMediaInfo(), !m) throw new n(l.UNEXPECTED_ERROR, \"can not find source config\");\n          return h.clientRequest = {\n            command: \"SetSourceChannel\",\n            uid: \"0\",\n            channelName: m.channelName,\n            token: m.token || this.joinInfo.appId\n          }, h;\n\n        case Ea.SetSourceUserId:\n          if (m = b && b.getSrcChannelMediaInfo(), !m) throw new n(l.UNEXPECTED_ERROR, \"can not find source config\");\n          return h.clientRequest = {\n            command: \"SetSourceUserId\",\n            uid: m.uid + \"\"\n          }, h;\n\n        case Ea.SetDestChannel:\n          if (k = b && b.getDestChannelMediaInfo(), !k) throw new n(l.UNEXPECTED_ERROR, \"can not find dest config\");\n          return q(k).call(k, a => {\n            c.push(a.channelName);\n            e.push(a.uid + \"\");\n            g.push(a.token || this.joinInfo.appId);\n          }), h.clientRequest = {\n            command: \"SetDestChannel\",\n            channelName: c,\n            uid: e,\n            token: g\n          }, h;\n\n        case Ea.StartPacketTransfer:\n          return h.clientRequest = {\n            command: \"StartPacketTransfer\"\n          }, h;\n\n        case Ea.Reconnect:\n          return h.clientRequest = {\n            command: \"Reconnect\"\n          }, h;\n\n        case Ea.StopPacketTransfer:\n          return h.clientRequest = {\n            command: \"StopPacketTransfer\"\n          }, h;\n\n        case Ea.UpdateDestChannel:\n          if (k = b && b.getDestChannelMediaInfo(), !k) throw new n(l.UNEXPECTED_ERROR, \"can not find dest config\");\n          return q(k).call(k, a => {\n            c.push(a.channelName);\n            e.push(a.uid + \"\");\n            g.push(a.token || this.joinInfo.appId);\n          }), h.clientRequest = {\n            command: \"UpdateDestChannel\",\n            channelName: c,\n            uid: e,\n            token: g\n          }, h;\n      }\n\n      return h;\n    }\n\n  }\n\n  class Oo {\n    constructor(a, b) {\n      this._trust_stream_added_state_ = this._trust_video_mute_state_ = this._trust_audio_mute_state_ = this._trust_video_enabled_state_ = this._trust_audio_enabled_state_ = this._trust_in_room_ = !0;\n      this._video_muted_ = this._audio_muted_ = !1;\n      this._video_enabled_ = this._audio_enabled_ = !0;\n      this._video_added_ = this._audio_added_ = !1;\n      this.uid = a;\n      this._uintid = b;\n    }\n\n    get hasVideo() {\n      return this._video_enabled_ && !this._video_muted_ && this._video_added_;\n    }\n\n    get hasAudio() {\n      return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;\n    }\n\n    get audioTrack() {\n      if (this.hasAudio) return this._audioTrack;\n    }\n\n    get videoTrack() {\n      if (this.hasVideo) return this._videoTrack;\n    }\n\n  }\n\n  let Po = /*#__PURE__*/function () {\n    var _ref16 = _asyncToGenerator(function* (a) {\n      var b = Ge(\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\\nxQiYDz3vqa6bP29adwIDAQAB\");\n      b = yield window.crypto.subtle.importKey(\"spki\", b, {\n        name: \"RSA-OAEP\",\n        hash: \"SHA-256\"\n      }, !0, [\"encrypt\"]);\n      a = (c = a, new TextEncoder().encode(c));\n      var c;\n      c = yield window.crypto.subtle.encrypt({\n        name: \"RSA-OAEP\"\n      }, b, a);\n      return Dd(new Uint8Array(c));\n    });\n\n    return function Po(_x47) {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n\n  var ig = function (a, b, c, e) {\n    var g,\n        h = arguments.length,\n        k = 3 > h ? b : null === e ? e = Z(b, c) : e;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) k = Reflect.decorate(a, b, c, e);else for (var l = a.length - 1; 0 <= l; l--) (g = a[l]) && (k = (3 > h ? g(k) : 3 < h ? g(b, c, k) : g(b, c)) || k);\n    return 3 < h && k && Y(b, c, k), k;\n  },\n      Ob = function (a, b) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(a, b);\n  };\n\n  class re extends Sa {\n    constructor(a) {\n      var b, c, e, g;\n      let h;\n      if (super(), this._users = [], this._sessionId = null, this._bindEnabledTracks = [], this._leaveMutex = new Mb(\"client-leave\"), this._publishMutex = new Mb(\"client-publish\"), this._subscribeMutex = new aa(), this._remoteStream = new aa(), this._encryptionMode = \"none\", this._encryptionSecret = null, this._encryptionSalt = null, this._turnServer = {\n        servers: [],\n        mode: \"auto\"\n      }, this._cloudProxyServerMode = \"disabled\", this._isDualStreamEnabled = !1, this._streamFallbackTypeCacheMap = new aa(), this._remoteStreamTypeCacheMap = new aa(), this._axiosCancelSource = zb.CancelToken.source(), this._networkQualitySensitivity = \"normal\", this._handleLocalTrackEnable = (a, b, c) => {\n        this.publish(a, !1).then(b).catch(c);\n      }, this._handleLocalTrackDisable = (a, b, c) => {\n        this.unpublish(a, !1).then(b).catch(c);\n      }, this._handleUserOnline = a => {\n        var b;\n        this.isStringUID && \"string\" != typeof a.uid && k.error(\"[\".concat(this._clientId, \"] StringUID is Mixed with UintUID\"));\n        let c = R(b = this._users).call(b, b => b.uid === a.uid);\n        c ? c._trust_in_room_ = !0 : (b = new Oo(a.uid, a.uint_id || a.uid), this._users.push(b), k.debug(\"[\".concat(this._clientId, \"] user online\"), a.uid), this.emit(P.USER_JOINED, b));\n      }, this._handleUserOffline = a => {\n        var b;\n        let c = R(b = this._users).call(b, b => b.uid === a.uid);\n        c && (this._handleRemoveStream(a), Nc(this._users, c), this._remoteStreamTypeCacheMap.delete(c.uid), this._streamFallbackTypeCacheMap.delete(c.uid), k.debug(\"[\".concat(this._clientId, \"] user offline\"), a.uid, \"reason:\", a.reason), this.emit(P.USER_LEAVED, c, a.reason));\n      }, this._handleAddAudioOrVideoStream = (a, b, c) => {\n        var e, g, h;\n        let l = R(e = this._users).call(e, a => a.uid === b);\n        if (!l) return void k.error(\"[\".concat(this._clientId, \"] can not find target user!(on_add_stream)\"));\n        k.debug(m(g = m(h = \"[\".concat(this._clientId, \"] stream added with uid \")).call(h, b, \", type \")).call(g, a));\n        e = \"audio\" === a ? l.hasAudio : l.hasVideo;\n        var p, n;\n        (l._uintid || (l._uintid = c || b), l._trust_stream_added_state_ = !0, \"audio\" === a ? l._audio_added_ = !0 : l._video_added_ = !0, (\"audio\" === a ? l.hasAudio : l.hasVideo) && !e) && (k.info(m(p = m(n = \"[\".concat(this._clientId, \"] remote user \")).call(n, l.uid, \" published \")).call(p, a)), this.emit(P.USER_PUBLISHED, l, a));\n        \"video\" === a ? u.onGatewayStream(this._sessionId, Ca.ON_ADD_VIDEO_STREAM, ma.ON_ADD_VIDEO_STREAM, {\n          peer: c || b\n        }) : u.onGatewayStream(this._sessionId, Ca.ON_ADD_AUDIO_STREAM, ma.ON_ADD_AUDIO_STREAM, {\n          peer: c || b\n        });\n        (a = this._remoteStream.get(b)) && a.readyToReconnect && \"connecting\" === a.connectionState && a.reconnectPC().catch(a => {\n          k.error(\"[\".concat(this._clientId, \"] resubscribe error\"), a.toString());\n        });\n      }, this._handleRemoveStream = a => {\n        var b, c;\n        let e = R(b = this._users).call(b, b => b.uid === a.uid);\n        if (!e) return void k.warning(\"[\".concat(this._clientId, \"] can not find target user!(on_remove_stream)\"));\n        k.debug(m(c = \"[\".concat(this._clientId, \"] stream removed with uid \")).call(c, a.uid));\n\n        b = () => {};\n\n        e.hasAudio && e.hasVideo ? b = () => {\n          var a, b;\n          k.info(m(a = \"[\".concat(this._clientId, \"] remote user \")).call(a, e.uid, \" unpublished audio track\"));\n          this.emit(P.USER_UNPUBLISHED, e, \"audio\");\n          k.info(m(b = \"[\".concat(this._clientId, \"] remote user \")).call(b, e.uid, \" unpublished video track\"));\n          this.emit(P.USER_UNPUBLISHED, e, \"video\");\n        } : e.hasVideo ? b = () => {\n          var a;\n          k.info(m(a = \"[\".concat(this._clientId, \"] remote user \")).call(a, e.uid, \" unpublished video track\"));\n          this.emit(P.USER_UNPUBLISHED, e, \"video\");\n        } : e.hasAudio && (b = () => {\n          var a;\n          k.info(m(a = \"[\".concat(this._clientId, \"] remote user \")).call(a, e.uid, \" unpublished audio track\"));\n          this.emit(P.USER_UNPUBLISHED, e, \"audio\");\n        });\n        e._trust_stream_added_state_ = !0;\n        e._audio_added_ = !1;\n        e._video_added_ = !1;\n        (c = this._remoteStream.get(e.uid)) && (c.closeP2PConnection(), this._remoteStream.delete(e.uid));\n        u.onGatewayStream(this._sessionId, Ca.ON_REMOVE_STREAM, ma.ON_REMOVE_STREAM, {\n          peer: a.uint_id || a.uid\n        });\n        b();\n      }, this._handleSetStreamLocalEnable = (a, b, c) => {\n        var e, g, h, l, p, n;\n        let r = R(e = this._users).call(e, a => a.uid === b);\n        if (!r) return void k.error(\"[\".concat(this._clientId, \"] can not find target user!(disable_local)\"));\n        k.debug(m(g = m(h = m(l = \"[\".concat(this._clientId, \"] local \")).call(l, a, \" \")).call(h, c ? \"enabled\" : \"disabled\", \" with uid \")).call(g, b));\n        e = \"audio\" === a ? r.hasAudio : r.hasVideo;\n\n        if (\"audio\" === a) {\n          r._trust_audio_enabled_state_ = !0;\n          var t = r._audio_enabled_;\n          if (r._audio_enabled_ = c, r._audio_enabled_ === t) return;\n          var q, y;\n          c = r._audio_enabled_ ? \"enable-local-audio\" : \"disable-local-audio\";\n          k.debug(m(q = m(y = \"[\".concat(this._clientId, \"] user-info-updated, uid: \")).call(y, b, \", msg: \")).call(q, c));\n          this.emit(P.USER_INFO_UPDATED, b, c);\n        } else {\n          r._trust_video_enabled_state_ = !0;\n          q = r._video_enabled_;\n          if (r._video_enabled_ = c, r._video_enabled_ === q) return;\n          var u;\n          c = r._video_enabled_ ? \"enable-local-video\" : \"disable-local-video\";\n          k.debug(m(t = m(u = \"[\".concat(this._clientId, \"] user-info-update, uid: \")).call(u, b, \", msg: \")).call(t, c));\n          this.emit(P.USER_INFO_UPDATED, b, c);\n        }\n\n        c = \"audio\" === a ? r.hasAudio : r.hasVideo;\n\n        if (e !== c) {\n          var v, w;\n          if (!e && c) return k.info(m(v = m(w = \"[\".concat(this._clientId, \"] remote user \")).call(w, b, \" published \")).call(v, a)), void this.emit(P.USER_PUBLISHED, r, a);\n          if (v = this._remoteStream.get(b)) w = qc({}, v.subscribeOptions), w.audio = !!r.hasAudio && w.audio, w.video = !!r.hasVideo && w.video, w.audio || w.video ? v.setSubscribeOptions(w) : (v.closeP2PConnection().catch(a => {\n            k.warning(\"close sub pc error\", a);\n          }), this._remoteStream.delete(r.uid));\n          k.info(m(p = m(n = \"[\".concat(this._clientId, \"] remote user \")).call(n, r.uid, \" unpublished \")).call(p, a));\n          this.emit(P.USER_UNPUBLISHED, r, a);\n        }\n      }, this._handleMuteStream = (a, b, c) => {\n        var e, g, h;\n        k.debug(\"[\".concat(this._clientId, \"] receive mute message\"), a, b, c);\n        let l = R(e = this._users).call(e, b => b.uid === a);\n        var p;\n        if (!l) return void k.warning(m(p = \"[\".concat(this._clientId, \"] can not find remote user, ignore mute event, uid: \")).call(p, a));\n        e = \"audio\" === b ? l.hasAudio : l.hasVideo;\n\n        if (\"audio\" === b) {\n          l._trust_audio_mute_state_ = !0;\n          var n = l._audio_muted_;\n          if (l._audio_muted_ = c, l._audio_muted_ === n) return;\n          var r, t;\n          c = l._audio_muted_ ? \"mute-audio\" : \"unmute-audio\";\n          k.debug(m(r = m(t = \"[\".concat(this._clientId, \"] user-info-update, uid: \")).call(t, a, \", msg: \")).call(r, c));\n          this.emit(P.USER_INFO_UPDATED, a, c);\n        } else {\n          l._trust_video_mute_state_ = !0;\n          r = l._video_muted_;\n          if (l._video_muted_ = c, l._video_muted_ === r) return;\n          var q;\n          c = l._video_muted_ ? \"mute-video\" : \"unmute-video\";\n          k.debug(m(n = m(q = \"[\".concat(this._clientId, \"] user-info-update, uid: \")).call(q, a, \", msg: \")).call(n, c));\n          this.emit(P.USER_INFO_UPDATED, a, c);\n        }\n\n        c = \"audio\" === b ? l.hasAudio : l.hasVideo;\n\n        if (e !== c) {\n          var u, y;\n          if (!e && c) return k.info(m(u = m(y = \"[\".concat(this._clientId, \"] remote user \")).call(y, a, \" published \")).call(u, b)), void this.emit(P.USER_PUBLISHED, l, b);\n          if (u = this._remoteStream.get(a)) y = qc({}, u.subscribeOptions), y.audio = !!l.hasAudio && y.audio, y.video = !!l.hasVideo && y.video, \"video\" === b && u.pc._statsFilter.setVideoIsReady(!1), y.audio || y.video ? u.setSubscribeOptions(y) : (u.closeP2PConnection().catch(a => {\n            k.warning(\"close sub pc error\", a);\n          }), this._remoteStream.delete(l.uid));\n          k.info(m(g = m(h = \"[\".concat(this._clientId, \"] remote user \")).call(h, a, \" unpublished \")).call(g, b));\n          this.emit(P.USER_UNPUBLISHED, l, b);\n        }\n      }, this._handleP2PLost = a => {\n        k.debug(\"[\".concat(this._clientId, \"] receive p2p lost\"), a);\n        let b = null;\n        if (this._highStream && this._highStream.pc.ID === a.p2pid) b = this._highStream;else if (this._lowStream && this._lowStream.pc.ID === a.p2pid) b = this._lowStream;else {\n          var c;\n          q(c = this._remoteStream).call(c, c => {\n            c.pc.ID === a.p2pid && (b = c);\n          });\n        }\n        b ? b.emit(H.GATEWAY_P2P_LOST, a.p2pid) : k.warning(\"P2PLost stream not found\", a);\n      }, this._handleTokenWillExpire = () => {\n        k.debug(\"[\".concat(this._clientId, \"] received message onTokenPrivilegeWillExpire\"));\n        this.emit(P.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);\n      }, this._handleBeforeUnload = a => {\n        void 0 !== a.returnValue && \"\" !== a.returnValue || (this.leave(), k.info(\"[\".concat(this._clientId, \"] auto leave onbeforeunload\")));\n      }, this._handleUpdateNetworkQuality = () => {\n        var a;\n\n        if (\"normal\" !== this._networkQualitySensitivity) {\n          if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.emit(P.NETWORK_QUALITY, {\n            downlinkNetworkQuality: 6,\n            uplinkNetworkQuality: 6\n          });\n          var b = {\n            downlinkNetworkQuality: 0,\n            uplinkNetworkQuality: 0\n          };\n          this._highStream && !this._highStream.detecting && (b.uplinkNetworkQuality = this._highStream.getNetworkQuality());\n          var c = 0;\n          q(a = this._remoteStream).call(a, a => c += a.getNetworkQuality());\n          0 < this._remoteStream.size && (b.downlinkNetworkQuality = Math.round(c / this._remoteStream.size));\n          this.emit(P.NETWORK_QUALITY, b);\n        }\n      }, this._codec = a.codec, this._mode = a.mode, a.proxyServer && (this._proxyServer = a.proxyServer, u.setProxyServer(this._proxyServer), k.setProxyServer(this._proxyServer)), a.turnServer && (this._turnServer = qc({}, this._turnServer, {\n        mode: \"manual\"\n      }, a.turnServer)), this._clientId = qa(5, \"client-\"), k.info(m(b = m(c = m(e = m(g = \"[\".concat(this._clientId, \"] Initializing AgoraRTC client v\")).call(g, Ta, \" build: \")).call(e, \"v4.5.0-0-g87245ad6(5/25/2021, 3:25:26 PM)\", \", mode: \")).call(c, this._mode, \", codec: \")).call(b, this._codec)), a.clientRoleOptions) try {\n        hh(a.clientRoleOptions), h = Ga({}, a.clientRoleOptions);\n      } catch (r) {\n        var l;\n        k.warning(m(l = \"[\".concat(this._clientId, \"] \")).call(l, r.toString()));\n      }\n      this._statsCollector = new kd(this._clientId);\n\n      this._statsCollector.onStatsException = (a, b, c) => {\n        var e, g, h;\n        k.debug(m(e = m(g = m(h = \"[\".concat(this._clientId, \"] receive exception msg, code: \")).call(h, a, \", msg: \")).call(g, b, \", uid: \")).call(e, c));\n        this.emit(P.EXCEPTION, {\n          code: a,\n          msg: b,\n          uid: c\n        });\n      };\n\n      this._statsCollector.onUploadPublishDuration = (a, b, c, e) => {\n        var g;\n        let h = R(g = this._users).call(g, b => b.uid === a);\n        h && u.peerPublishStatus(this._sessionId, {\n          subscribeElapse: e,\n          audioPublishDuration: b,\n          videoPublishDuration: c,\n          peer: h._uintid\n        });\n      };\n\n      this._gateway = new oo({\n        clientId: this._clientId,\n        mode: this._mode,\n        codec: this._codec,\n        websocketRetryConfig: a.websocketRetryConfig || Qa,\n        httpRetryConfig: a.httpRetryConfig || Qa,\n        forceWaitGatewayResponse: void 0 === a.forceWaitGatewayResponse || a.forceWaitGatewayResponse,\n        statsCollector: this._statsCollector,\n        role: a.role,\n        clientRoleOptions: h\n      });\n      this._config = a;\n      this._configDistribute = qo;\n\n      this._handleGatewayEvents();\n\n      Wj.push(this);\n    }\n\n    get connectionState() {\n      return this._gateway.state;\n    }\n\n    get remoteUsers() {\n      return this._users;\n    }\n\n    get localTracks() {\n      return this._highStream ? this._highStream.getAllTracks() : [];\n    }\n\n    get uid() {\n      return this._uid;\n    }\n\n    get channelName() {\n      return this._channelName;\n    }\n\n    get isStringUID() {\n      return !!this._joinInfo && !!this._joinInfo.stringUid;\n    }\n\n    join(a, b, c, e, g) {\n      var _this95 = this;\n\n      return _asyncToGenerator(function* () {\n        var h;\n        let p = u.reportApiInvoke(_this95._sessionId, {\n          name: C.JOIN,\n          options: [a, b, c, e],\n          tag: B.TRACER\n        });\n\n        try {\n          if (!c && null !== c) throw new n(l.INVALID_PARAMS, \"Invalid token: \".concat(c, \". If you don not use token, set it to null\"));\n          c && Fa(c, \"token\", 1, 2047);\n          a && Fa(a, \"appid\", 1, 2047);\n          Ce(b);\n          e && De(e);\n          g && Fa(g, \"optionalInfo\", 1, 2047);\n        } catch (y) {\n          throw p.onError(y), y;\n        }\n\n        if (k.info(m(h = \"[\".concat(_this95._clientId, \"] start join channel \")).call(h, b)), _this95._leaveMutex.isLocked) k.debug(\"[\".concat(_this95._clientId, \"] join: waiting leave operation\")), (yield _this95._leaveMutex.lock())(), k.debug(\"[\".concat(_this95._clientId, \"] join: continue\"));\n        if (\"DISCONNECTED\" !== _this95.connectionState) throw a = new n(l.INVALID_OPERATION, \"[\".concat(_this95._clientId, \"] Client already in connecting/connected state\")), p.onError(a), a;\n        _this95._sessionId || (_this95._sessionId = qa(32, \"\").toUpperCase());\n        _this95._gateway.state = \"CONNECTING\";\n        g = {\n          clientId: _this95._clientId,\n          appId: a,\n          sid: _this95._sessionId,\n          cname: b,\n          uid: \"string\" != typeof e ? e : null,\n          turnServer: _this95._turnServer,\n          proxyServer: _this95._proxyServer,\n          token: c || a,\n          cloudProxyServer: _this95._cloudProxyServerMode,\n          optionalInfo: g\n        };\n        \"string\" == typeof e && (g.stringUid = e, _this95._uintUid ? (g.uid = _this95._uintUid, _this95._uintUid = void 0) : g.uid = 0);\n        \"none\" !== _this95._encryptionMode && _this95._encryptionSecret && (g.aesmode = _this95._encryptionMode, g.aespassword = yield Po(_this95._encryptionSecret), _this95._encryptionSalt && (g.aessalt = _this95._encryptionSalt));\n\n        _this95._startSession(_this95._sessionId, {\n          channel: b,\n          appId: a\n        });\n\n        Ub(() => {\n          \"CONNECTING\" === _this95.connectionState && u.joinChannelTimeout(_this95._sessionId, 5);\n        }, 5E3);\n\n        try {\n          var r;\n\n          if (yield vl(g, _this95._axiosCancelSource.token, _this95._config.httpRetryConfig || Qa), g.stringUid && !g.uid) {\n            var t;\n            let a = yield Hh(g.stringUid, g, _this95._axiosCancelSource.token, _this95._config.httpRetryConfig || Qa);\n            k.debug(m(t = \"getUserAccount Success \".concat(g.stringUid, \" => \")).call(t, a));\n            g.uid = a;\n          }\n\n          _this95._configDistribute.startGetConfigDistribute(g, _this95._axiosCancelSource.token);\n\n          _this95._configDistribute.on(hd.UPDATE_BITRATE_LIMIT, a => {\n            _this95._highStream && _this95._highStream.handleUpdateBitrateLimit(a.uplink);\n            a.low_stream_uplink && _this95._lowStream && _this95._lowStream.handleUpdateBitrateLimit({\n              max_bitrate: a.low_stream_uplink.bitrate,\n              min_bitrate: a.low_stream_uplink.bitrate || 0\n            });\n          });\n\n          let e = yield Gh(g, _this95._axiosCancelSource.token, _this95._config.httpRetryConfig || Qa);\n          _this95._key = c || a;\n          _this95._joinInfo = qc({}, g, {\n            cid: e.gatewayInfo.cid,\n            uid: g.uid ? g.uid : e.gatewayInfo.uid,\n            vid: e.gatewayInfo.vid,\n            apResponse: e.gatewayInfo.res,\n            uni_lbs_ip: e.gatewayInfo.uni_lbs_ip,\n            gatewayAddrs: e.gatewayInfo.gatewayAddrs\n          });\n          let h = yield _this95._gateway.join(_this95._joinInfo, _this95._key);\n          return p.onSuccess(h), _this95._appId = a, _this95._channelName = g.cname, _this95._uid = h, _this95._networkQualityInterval && window.clearInterval(_this95._networkQualityInterval), _this95._networkQualityInterval = window.setInterval(_this95._handleUpdateNetworkQuality, 2E3), window.addEventListener(\"beforeunload\", _this95._handleBeforeUnload), k.info(m(r = \"[\".concat(_this95._clientId, \"] Joining channel success: \")).call(r, b)), Ub(() => {\n            k.startUpload();\n          }, 5E3), h;\n        } catch (y) {\n          throw a = Pb(y) ? y[0] : y, k.error(\"[\".concat(_this95._clientId, \"] Joining channel failed, rollback\"), a), a.code !== l.OPERATION_ABORTED && (_this95._gateway.state = \"DISCONNECTED\", _this95._reset()), p.onError(a), a;\n        }\n      })();\n    }\n\n    leave() {\n      var _this96 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = u.reportApiInvoke(_this96._sessionId, {\n          name: C.LEAVE,\n          options: [],\n          tag: B.TRACER\n        });\n        k.info(\"[\".concat(_this96._clientId, \"] Leaving channel\"));\n        window.removeEventListener(\"beforeunload\", _this96._handleBeforeUnload);\n\n        _this96._reset();\n\n        let b = yield _this96._leaveMutex.lock();\n        if (\"DISCONNECTED\" === _this96.connectionState) return k.info(\"[\".concat(_this96._clientId, \"] Leaving channel repeated, success\")), b(), a.onSuccess();\n        yield _this96._gateway.leave(\"CONNECTED\" !== _this96.connectionState);\n        k.info(\"[\".concat(_this96._clientId, \"] Leaving channel success\"));\n        b();\n        a.onSuccess();\n      })();\n    }\n\n    publish(a, b = !0) {\n      var _this97 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e;\n        Pb(a) || (a = [a]);\n        let g = u.reportApiInvoke(_this97._sessionId, {\n          name: C.PUBLISH,\n          options: E(a).call(a, a => a ? Object(a).toString() : \"null\"),\n          tag: B.TRACER\n        });\n        if (0 === a.length) return a = new n(l.INVALID_PARAMS, \"track list is empty\"), g.onError(a), a.throw();\n        if (\"live\" === _this97._mode && \"audience\" === _this97._gateway.role) return a = new n(l.INVALID_OPERATION, \"audience can not publish stream\"), g.onError(a), a.throw();\n\n        for (let c of a) {\n          if (!(c instanceof ne)) return a = new n(l.INVALID_PARAMS, \"pamameter is not local track\"), g.onError(a), a.throw();\n          if (!c._enabled && b) return a = new n(l.TRACK_IS_DISABLED, \"can not publish a disabled track: \".concat(c.getTrackId())), g.onError(a), a.throw();\n        }\n\n        k.info(m(c = \"[\".concat(_this97._clientId, \"] Publishing tracks, id \")).call(c, E(a).call(a, a => \"\".concat(a.getTrackId(), \" \"))));\n        yield _this97._configDistribute.awaitConfigDistributeComplete();\n        b && q(a).call(a, a => {\n          var b;\n\n          let c = _this97._configDistribute.getBitrateLimit();\n\n          a instanceof Ma && c && a.setBitrateLimit(c.uplink);\n          -1 === J(b = _this97._bindEnabledTracks).call(b, a) && (a.addListener(M.NEED_ADD_TRACK, _this97._handleLocalTrackEnable), a.addListener(M.NEED_REMOVE_TRACK, _this97._handleLocalTrackDisable), _this97._bindEnabledTracks.push(a));\n        });\n        c = yield _this97._publishMutex.lock();\n\n        try {\n          let b = yield _this97._publishHighStream(a),\n              e = (b.audioTrack, b.videoTrack);\n          _this97._isDualStreamEnabled && e && !_this97._lowStream && (yield _this97._publishLowStream(e));\n          c();\n          g.onSuccess();\n        } catch (h) {\n          throw c(), b && q(a).call(a, a => {\n            var b, c;\n            let e = J(b = _this97._bindEnabledTracks).call(b, a);\n            -1 !== e && (a.off(M.NEED_ADD_TRACK, _this97._handleLocalTrackEnable), a.off(M.NEED_REMOVE_TRACK, _this97._handleLocalTrackDisable), Ia(c = _this97._bindEnabledTracks).call(c, e, 1));\n          }), g.onError(h), k.error(\"[\".concat(_this97._clientId, \"] publish error\"), h.toString()), h;\n        }\n\n        k.info(m(e = \"[\".concat(_this97._clientId, \"] Publish success, id \")).call(e, E(a).call(a, a => \"\".concat(a.getTrackId(), \" \"))));\n      })();\n    }\n\n    unpublish(a, b = !0) {\n      var _this98 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e, g;\n        if (!_this98._highStream) return void k.warning(\"[\".concat(_this98._clientId, \"] Could not find tracks to unpublish\"));\n\n        var h = _this98._highStream.getAllTracks();\n\n        a ? Pb(a) || (a = [a]) : a = _this98._highStream.getAllTracks();\n\n        h = function (a, b) {\n          if (a.length !== b.length) return !1;\n\n          for (let c = 0; c < a.length; c += 1) {\n            const e = a[c];\n            if (I(a).call(a, a => a === e).length !== I(b).call(b, a => a === e).length) return !1;\n          }\n\n          return !0;\n        }(h, a);\n\n        let p = u.reportApiInvoke(_this98._sessionId, {\n          name: C.UNPUBLISH,\n          options: E(a).call(a, a => a.getTrackId()),\n          tag: B.TRACER\n        });\n        k.info(m(c = m(e = \"[\".concat(_this98._clientId, \"] Unpublish tracks, tracks \")).call(e, E(a).call(a, a => \"\".concat(a.getTrackId(), \" \")), \", isClosePC: \")).call(c, h));\n        c = h ? void 0 : yield _this98._publishMutex.lock();\n        if (!_this98._highStream) return k.warning(\"[\".concat(_this98._clientId, \"] Could not find tracks to unpublish\")), void (c && c());\n\n        try {\n          _this98._lowStream && 0 < I(a).call(a, a => \"video\" === a.trackMediaType).length && (yield _this98._lowStream.closeP2PConnection(), _this98._lowStream = void 0), h ? yield _this98._highStream.closeP2PConnection() : yield _this98._highStream.removeTracks(a, b), c && c();\n        } catch (r) {\n          if (r.code !== l.OPERATION_ABORTED) throw p.onError(r), k.error(\"[\".concat(_this98._clientId, \"] unpublish error\"), r.toString()), c && c(), r;\n          k.debug(\"[\".concat(_this98._clientId, \"] ignore unpub operation abort\"));\n          c && c();\n        }\n\n        _this98._highStream && \"disconnected\" === _this98._highStream.connectionState && (_this98._highStream = void 0, _this98._lowStream = void 0);\n        b && q(a).call(a, a => {\n          var b, c;\n          let e = J(b = _this98._bindEnabledTracks).call(b, a);\n          -1 !== e && (a.off(M.NEED_ADD_TRACK, _this98._handleLocalTrackEnable), a.off(M.NEED_REMOVE_TRACK, _this98._handleLocalTrackDisable), Ia(c = _this98._bindEnabledTracks).call(c, e, 1));\n        });\n        k.info(m(g = \"[\".concat(_this98._clientId, \"] Unpublish success,tracks \")).call(g, E(a).call(a, a => \"\".concat(a.getTrackId()))));\n        p.onSuccess();\n      })();\n    }\n\n    subscribe(a, b) {\n      var _this99 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e, g, h;\n        Ka(b, \"mediaType\", [\"audio\", \"video\"]);\n        let p = u.reportApiInvoke(_this99._sessionId, {\n          name: C.SUBSCRIBE,\n          options: [a.uid, b],\n          tag: B.TRACER\n        });\n        if (!_this99._joinInfo) throw b = new n(l.INVALID_OPERATION, \"Can't subscribe stream, not joined\"), p.onError(b), b;\n        if (\"CONNECTED\" !== _this99.connectionState && \"RECONNECTING\" !== _this99.connectionState) throw b = new n(l.INVALID_OPERATION, \"Can't subscribe stream in \".concat(_this99.connectionState, \" state\")), p.onError(b), b;\n\n        if (!R(c = _this99._users).call(c, b => b === a)) {\n          var r;\n          b = new n(l.INVALID_REMOTE_USER, \"user is not in the channel\");\n          throw k.error(m(r = \"[\".concat(_this99._clientId, \"] can not subscribe \")).call(r, a.uid, \", this user is not in the channel\")), p.onError(b), b;\n        }\n\n        if (!a.hasAudio && !a.hasVideo) {\n          var t;\n          b = new n(l.INVALID_REMOTE_USER, \"user is not published\");\n          throw k.error(m(t = \"[\".concat(_this99._clientId, \"] can not subscribe \")).call(t, a.uid, \", user is not published\")), p.onError(b), b;\n        }\n\n        r = {\n          audio: \"audio\" === b,\n          video: \"video\" === b\n        };\n\n        if (!a.hasAudio && r.audio || !a.hasVideo && r.video) {\n          var q, v;\n          var D = new n(l.REMOTE_USER_IS_NOT_PUBLISHED);\n          throw k.error(m(q = m(v = \"[\".concat(_this99._clientId, \"] can not subscribe \")).call(v, a.uid, \" with mediaType \")).call(q, b, \", remote track is not published\")), p.onError(D), D;\n        }\n\n        (q = _this99._subscribeMutex.get(a.uid)) || (q = new Mb(\"sub-\".concat(a.uid)), _this99._subscribeMutex.set(a.uid, q));\n        k.info(m(e = m(g = \"[\".concat(_this99._clientId, \"] subscribe user \")).call(g, a.uid, \", mediaType: \")).call(e, b));\n        e = yield q.lock();\n        g = _this99._remoteStream.get(a.uid);\n\n        try {\n          if (g) r.audio = r.audio || g.subscribeOptions.audio, r.video = r.video || g.subscribeOptions.video, yield _this99._gateway.subscribeChange(g, r);else {\n            g = new Jo(a, _this99._statsCollector, _this99._joinInfo, r);\n\n            _this99._remoteStream.set(a.uid, g);\n\n            try {\n              yield _this99._gateway.subscribe(g);\n            } catch (z) {\n              throw _this99._remoteStream.delete(a.uid), z;\n            }\n\n            g.on(H.CONNECTION_STATE_CHANGE, (b, c) => {\n              \"connecting\" === b ? _this99.emit(P.MEDIA_RECONNECT_START, a.uid) : \"connected\" === b && _this99.emit(P.MEDIA_RECONNECT_END, a.uid);\n            });\n          }\n          e();\n        } catch (z) {\n          var w;\n          throw p.onError(z), e(), k.error(m(w = \"[\".concat(_this99._clientId, \"] subscribe user \")).call(w, a.uid, \" error\"), z), z;\n        }\n\n        k.info(m(D = m(h = \"[\".concat(_this99._clientId, \"] subscribe success user \")).call(h, a.uid, \", mediaType: \")).call(D, b));\n        _this99._defaultStreamFallbackType && _this99.setStreamFallbackOption(a.uid, _this99._defaultStreamFallbackType).catch(a => {\n          k.warning(\"[\".concat(_this99._clientId, \"] auto set fallback failed\"), a);\n        });\n        b = \"audio\" === b ? a.audioTrack : a.videoTrack;\n        return b ? (p.onSuccess(b.getTrackId()), b) : (b = new n(l.UNEXPECTED_ERROR, \"can not find remote track in user object\"), p.onError(b), b.throw());\n      })();\n    }\n\n    unsubscribe(a, b) {\n      var _this100 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e, g, h, p;\n        b && Ka(b, \"mediaType\", [\"audio\", \"video\"]);\n        let r = u.reportApiInvoke(_this100._sessionId, {\n          name: C.UNSUBSCRIBE,\n          options: [a.uid, b],\n          tag: B.TRACER\n        });\n\n        if (!R(c = _this100._users).call(c, b => b === a)) {\n          var t;\n          b = new n(l.INVALID_REMOTE_USER, \"user is not in the channel\");\n          throw k.error(m(t = \"[\".concat(_this100._clientId, \"] can not subscribe \")).call(t, a.uid, \", user is not in the channel\")), r.onError(b), b;\n        }\n\n        k.info(m(e = m(g = \"[\".concat(_this100._clientId, \"] unsubscribe uid: \")).call(g, a.uid, \", mediaType: \")).call(e, b));\n        (t = _this100._subscribeMutex.get(a.uid)) || (t = new Mb(\"sub-\".concat(a.uid)), _this100._subscribeMutex.set(a.uid, t));\n        t = yield t.lock();\n        c = _this100._remoteStream.get(a.uid);\n        var q;\n        if (!c) return k.warning(m(q = \"[\".concat(_this100._clientId, \"]: you have not subscribe the remote user \")).call(q, a.uid)), r.onSuccess(), void t();\n        q = qc({}, c.subscribeOptions);\n        \"audio\" === b ? q.audio = !1 : \"video\" === b ? (q.video = !1, c.pc._statsFilter.setVideoIsReady(!1)) : (q.audio = !1, q.video = !1);\n\n        try {\n          q.audio || q.video ? yield _this100._gateway.subscribeChange(c, q) : (yield c.closeP2PConnection(), _this100._remoteStream.delete(a.uid)), t();\n        } catch (D) {\n          var v;\n          if (D.code !== l.OPERATION_ABORTED) throw r.onError(D), t(), k.error(m(v = \"[\".concat(_this100._clientId, \"] unsubscribe user \")).call(v, a.uid, \" error\"), D.toString()), D;\n          t();\n          k.debug(\"[\".concat(_this100._clientId, \"] ignore unsub operation abort\"));\n        }\n\n        k.info(m(h = m(p = \"[\".concat(_this100._clientId, \"] unsubscribe success uid: \")).call(p, a.uid, \", mediaType: \")).call(h, b));\n        r.onSuccess();\n      })();\n    }\n\n    setLowStreamParameter(a) {\n      if (!a) throw new n(l.INVALID_PARAMS);\n      null == a.width || W(a.width, \"streamParameter.width\");\n      null == a.height || W(a.height, \"streamParameter.height\");\n      null == a.framerate || W(a.framerate, \"streamParameter.framerate\");\n      null == a.bitrate || W(a.bitrate, \"streamParameter.bitrate\");\n      !0;\n      let b = u.reportApiInvoke(this._sessionId, {\n        name: C.SET_LOW_STREAM_PARAMETER,\n        options: [a],\n        tag: B.TRACER\n      });\n      (!a.width && a.height || a.width && !a.height) && k.warning(\"[\".concat(this._clientId, \"] The width and height parameters take effect only when both are set\"));\n      k.info(\"[\".concat(this._clientId, \"] set low stream parameter to\"), w(a));\n\n      let c = this._configDistribute.getLowStreamConfigDistribute();\n\n      c && c.bitrate && a.bitrate && c.bitrate < a.bitrate && (a.bitrate = c.bitrate);\n      this._lowStreamParameter = a;\n      b.onSuccess();\n    }\n\n    enableDualStream() {\n      var _this101 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = u.reportApiInvoke(_this101._sessionId, {\n          name: C.ENABLE_DUAL_STREAM,\n          options: [],\n          tag: B.TRACER\n        });\n\n        if (!ha.supportDualStream) {\n          u.streamSwitch(_this101._sessionId, {\n            lts: x(),\n            isdual: !0,\n            succ: !1\n          });\n          var b = new n(l.NOT_SUPPORTED, \"Your browser is not support dual stream\");\n          throw a.onError(b), b;\n        }\n\n        if (_this101._isDualStreamEnabled) throw b = new n(l.INVALID_OPERATION, \"Dual stream is already enabled\"), a.onError(b), b;\n        if (_this101._highStream && \"connected\" === _this101._highStream.connectionState && _this101._highStream.videoTrack) try {\n          yield _this101._publishLowStream(_this101._highStream.videoTrack);\n        } catch (c) {\n          throw u.streamSwitch(_this101._sessionId, {\n            lts: x(),\n            isdual: !0,\n            succ: !1\n          }), a.onError(c), c;\n        }\n        _this101._isDualStreamEnabled = !0;\n        u.streamSwitch(_this101._sessionId, {\n          lts: x(),\n          isdual: !0,\n          succ: !0\n        });\n        k.info(\"[\".concat(_this101._clientId, \"] enable dual stream\"));\n        a.onSuccess();\n      })();\n    }\n\n    disableDualStream() {\n      var _this102 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = u.reportApiInvoke(_this102._sessionId, {\n          name: C.DISABLE_DUAL_STREAM,\n          options: [],\n          tag: B.TRACER\n        });\n        if (_this102._lowStream) try {\n          yield _this102._lowStream.closeP2PConnection();\n        } catch (b) {\n          throw u.streamSwitch(_this102._sessionId, {\n            lts: x(),\n            isdual: !1,\n            succ: !1\n          }), a.onError(b), b;\n        }\n        _this102._lowStream = void 0;\n        _this102._isDualStreamEnabled = !1;\n        _this102._highStream && (_this102._highStream.lowStreamConnection = void 0);\n        u.streamSwitch(_this102._sessionId, {\n          lts: x(),\n          isdual: !1,\n          succ: !0\n        });\n        k.info(\"[\".concat(_this102._clientId, \"] disable dual stream\"));\n        a.onSuccess();\n      })();\n    }\n\n    setClientRole(a, b) {\n      var _this103 = this;\n\n      return _asyncToGenerator(function* () {\n        Ka(a, \"role\", [\"audience\", \"host\"]);\n        !0;\n        b && hh(b);\n        let c = u.reportApiInvoke(_this103._sessionId, {\n          name: C.SET_CLIENT_ROLE,\n          options: [a, b],\n          tag: B.TRACER\n        });\n        if (\"rtc\" === _this103._mode) return k.warning(\"[\".concat(_this103._clientId, \"]rtc mode can not use setClientRole\")), a = new n(l.INVALID_OPERATION, \"rtc mode can not use setClientRole\"), c.onError(a), a.throw();\n        if (b && b.level && \"host\" === a) return a = new n(l.INVALID_OPERATION, \"host mode can not set audience latency level\"), c.onError(a), a.throw();\n\n        try {\n          var e, g;\n\n          if (\"audience\" === a && _this103._highStream) {\n            let a = new n(l.INVALID_OPERATION, \"can not set client role to audience when publishing stream\");\n            return c.onError(a), a.throw();\n          }\n\n          yield _this103._gateway.setClientRole(a, b);\n          k.info(m(e = m(g = \"[\".concat(_this103._clientId, \"] set client role to \")).call(g, a, \", level: \")).call(e, b && b.level));\n          c.onSuccess();\n        } catch (h) {\n          throw c.onError(h), h;\n        }\n      })();\n    }\n\n    setProxyServer(a) {\n      Fa(a, \"proxyServer\");\n      let b = u.reportApiInvoke(this._sessionId, {\n        name: C.SET_PROXY_SERVER,\n        options: [a],\n        tag: B.TRACER\n      });\n      if (\"DISCONNECTED\" !== this.connectionState) throw new n(l.INVALID_OPERATION, \"Set proxy server before join channel\");\n      if (\"disabled\" !== this._cloudProxyServerMode) throw new n(l.INVALID_OPERATION, \"You have already set the proxy\");\n      this._proxyServer = a;\n      u.setProxyServer(this._proxyServer);\n      k.setProxyServer(this._proxyServer);\n      b.onSuccess();\n    }\n\n    setTurnServer(a) {\n      if (Pb(a) || (a = [a]), \"DISCONNECTED\" !== this.connectionState) throw new n(l.INVALID_OPERATION, \"Set turn server before join channel\");\n      if (\"disabled\" !== this._cloudProxyServerMode) throw new n(l.INVALID_OPERATION, \"You have already set the proxy\");\n      var b;\n      if (fh(a)) return this._turnServer = {\n        servers: a,\n        mode: \"original-manual\"\n      }, void k.info(m(b = \"[\".concat(this._clientId, \"] Set original turnserver success: \")).call(b, E(a).call(a, a => a.urls).join(\",\"), \".\"));\n      q(a).call(a, a => gh(a));\n      this._turnServer = {\n        servers: a,\n        mode: \"manual\"\n      };\n      k.info(\"[\".concat(this._clientId, \"] Set turnserver success.\"));\n    }\n\n    startProxyServer(a) {\n      let b = u.reportApiInvoke(this._sessionId, {\n        name: C.START_PROXY_SERVER,\n        options: [],\n        tag: B.TRACER\n      });\n      if (\"DISCONNECTED\" !== this.connectionState) throw a = new n(l.INVALID_OPERATION, \"Start proxy server before join channel\"), b.onError(a), a;\n      if (this._proxyServer || \"manual\" === this._turnServer.mode) throw a = new n(l.INVALID_OPERATION, \"You have already set the proxy\"), b.onError(a), a;\n      let c = [1, 2, 3, 4, 5];\n\n      switch (void 0 === a && (a = 1), a) {\n        case 1:\n          this._cloudProxyServerMode = \"normal\";\n          break;\n\n        case 2:\n          this._cloudProxyServerMode = \"443only\";\n          break;\n\n        case 3:\n          this._cloudProxyServerMode = \"proxy3\";\n          break;\n\n        case 4:\n          this._cloudProxyServerMode = \"proxy4\";\n          break;\n\n        case 5:\n          this._cloudProxyServerMode = \"proxy5\";\n          break;\n\n        default:\n          throw a = new n(l.INVALID_PARAMS, \"proxy server mode must be \".concat(c.join(\"|\"))), b.onError(a), a;\n      }\n\n      k.info(\"[\".concat(this._clientId, \"] set cloud proxy server mode to\"), this._cloudProxyServerMode);\n      b.onSuccess();\n    }\n\n    stopProxyServer() {\n      let a = u.reportApiInvoke(this._sessionId, {\n        name: C.STOP_PROXY_SERVER,\n        options: [],\n        tag: B.TRACER\n      });\n      if (\"DISCONNECTED\" !== this.connectionState) throw new n(l.INVALID_OPERATION, \"Stop proxy server after leave channel\");\n      u.setProxyServer();\n      k.setProxyServer();\n      this._cloudProxyServerMode = \"disabled\";\n      k.info(\"[\".concat(this._clientId, \"] set cloud proxy server mode to\"), this._cloudProxyServerMode);\n      this._proxyServer = void 0;\n      this._turnServer = {\n        mode: \"auto\",\n        servers: []\n      };\n      a.onSuccess();\n    }\n\n    setRemoteVideoStreamType(a, b) {\n      var _this104 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e;\n        Ka(b, \"streamType\", [0, 1]);\n        let g = u.reportApiInvoke(_this104._sessionId, {\n          name: C.SET_REMOTE_VIDEO_STREAM_TYPE,\n          options: [a, b],\n          tag: B.TRACER\n        });\n\n        try {\n          yield _this104._gateway.setRemoteVideoStreamType(a, b), Ub(() => {\n            var b;\n            let c = R(b = _this104._users).call(b, b => b.uid === a);\n            c && c.videoTrack && c.videoTrack.updateMediaStreamTrackResolution();\n          }, 2E3);\n        } catch (h) {\n          throw g.onError(h), k.error(\"[\".concat(_this104._clientId, \"] set remote video stream type error\"), h.toString()), h;\n        }\n\n        k.info(m(c = m(e = \"[\".concat(_this104._clientId, \"] set remote \")).call(e, a, \" video stream type to \")).call(c, b));\n\n        _this104._remoteStreamTypeCacheMap.set(a, b);\n\n        g.onSuccess();\n      })();\n    }\n\n    setStreamFallbackOption(a, b) {\n      var _this105 = this;\n\n      return _asyncToGenerator(function* () {\n        var c, e;\n        Ka(b, \"fallbackType\", [0, 1, 2]);\n        let g = u.reportApiInvoke(_this105._sessionId, {\n          name: C.SET_STREAM_FALLBACK_OPTION,\n          options: [\"too long to show\", b],\n          tag: B.TRACER\n        });\n\n        try {\n          yield _this105._gateway.setStreamFallbackOption(a, b);\n        } catch (h) {\n          throw g.onError(h), k.error(\"[\".concat(_this105._clientId, \"] set stream fallback option\"), h.toString()), h;\n        }\n\n        k.info(m(c = m(e = \"[\".concat(_this105._clientId, \"] set remote \")).call(e, a, \" stream fallback type to \")).call(c, b));\n\n        _this105._streamFallbackTypeCacheMap.set(a, b);\n\n        g.onSuccess();\n      })();\n    }\n\n    setEncryptionConfig(a, b, c) {\n      Ka(a, \"encryptionMode\", \"aes-128-xts aes-256-xts aes-128-ecb sm4-128-ecb aes-128-gcm aes-256-gcm aes-128-gcm2 aes-256-gcm2 none\".split(\" \"));\n      !0;\n      Fa(b, \"secret\");\n      let e = [\"aes-128-gcm2\", \"aes-256-gcm2\"];\n\n      if (ba(e).call(e, a)) {\n        if (!(c && c instanceof Uint8Array && 32 === c.length)) throw new n(l.INVALID_PARAMS, \"salt must be an Uint8Array and exactly equal to 32 bytes\");\n      } else if (c) throw new n(l.INVALID_PARAMS, \"current encrypt mode does not need salt\");\n\n      /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\"|{}\\[\\]])(?=.{8,})/.test(b) || k.warning(\"The secret is not strong:\\n      The secret must contain at least 1 lowercase alphabetical character,\\n      The secret must contain at least 1 uppercase alphabetical character,\\n      The secret must contain at least 1 numeric character,\\n      The secret must contain at least one special character,\\n      The secret must be eight characters or longer.\\n      \");\n      this._encryptionMode = a;\n      this._encryptionSecret = b;\n      c && (this._encryptionSalt = Dd(c));\n    }\n\n    renewToken(a) {\n      var _this106 = this;\n\n      return _asyncToGenerator(function* () {\n        Fa(a, \"token\", 1, 2047);\n        let b = u.reportApiInvoke(_this106._sessionId, {\n          name: C.RENEW_TOKEN,\n          options: [a],\n          tag: B.TRACER\n        });\n        if (!_this106._key) return a = new n(l.INVALID_OPERATION, \"renewToken should not be called before user join\"), b.onError(a), a.throw();\n        _this106._key = a;\n\n        try {\n          yield _this106._gateway.renewToken(a);\n        } catch (c) {\n          throw b.onError(c), k.error(\"[\".concat(_this106._clientId, \"] renewToken failed\"), c.toString()), c;\n        }\n\n        k.debug(\"[\".concat(_this106._clientId, \"] renewToken success\"));\n        b.onSuccess();\n      })();\n    }\n\n    enableAudioVolumeIndicator() {\n      let a = u.reportApiInvoke(this._sessionId, {\n        name: C.ENABLE_AUDIO_VOLUME_INDICATOR,\n        options: [],\n        tag: B.TRACER\n      });\n      if (this._audioVolumeIndicationInterval) return k.warning(\"you have already enabled audio volume indicator!\"), a.onSuccess();\n      this._audioVolumeIndicationInterval = window.setInterval(() => {\n        var a, c, e;\n        let g = dd(a = E(c = Gb(ic(e = this._remoteStream).call(e))).call(c, a => ({\n          level: a.user.audioTrack ? 100 * a.user.audioTrack._source.getAudioAvgLevel() : 0,\n          uid: a.getUserId()\n        }))).call(a, (a, b) => a.level - b.level);\n        this._highStream && this._highStream.audioTrack && (g.push({\n          level: 100 * this._highStream.audioTrack._source.getAudioAvgLevel(),\n          uid: this._highStream._userId\n        }), g = dd(g).call(g, (a, b) => a.level - b.level));\n        this.emit(P.VOLUME_INDICATOR, g);\n      }, v.AUDIO_VOLUME_INDICATION_INTERVAL || 2E3);\n      a.onSuccess();\n    }\n\n    getRTCStats() {\n      let a = this._statsCollector.getRTCStats(),\n          b = this._gateway.getInChannelInfo();\n\n      return a.Duration = Math.round(b.duration / 1E3), a;\n    }\n\n    startLiveStreaming(a, b) {\n      let c = u.reportApiInvoke(this._sessionId, {\n        name: C.START_LIVE_STREAMING,\n        options: [a, b],\n        tag: B.TRACER\n      });\n\n      if (!b) {\n        if (\"h264\" !== this._codec) return a = new n(l.LIVE_STREAMING_INVALID_RAW_STREAM, \"raw streaming is only support h264\"), c.onError(a), A.reject(a);\n        if (!this._highStream) return a = new n(l.LIVE_STREAMING_INVALID_RAW_STREAM, \"can not find stream to raw streaming\"), c.onError(a), A.reject(a);\n      }\n\n      if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(a) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(a)) return a = new n(l.LIVE_STREAMING_TASK_CONFLICT), c.onError(a), A.reject(a);\n      b = b ? oa.TRANSCODE : oa.RAW;\n      return this._createLiveStreamingClient(b).startLiveStreamingTask(a, b).then(() => c.onSuccess()).catch(a => {\n        throw c.onError(a), a;\n      });\n    }\n\n    setLiveTranscoding(a) {\n      let b = u.reportApiInvoke(this._sessionId, {\n        name: C.SET_LIVE_TRANSCODING,\n        options: [a],\n        tag: B.TRACER\n      });\n      return this._createLiveStreamingClient(oa.TRANSCODE).setTranscodingConfig(a).then(() => b.onSuccess()).catch(a => {\n        throw b.onError(a), a;\n      });\n    }\n\n    stopLiveStreaming(a) {\n      var b;\n      let c = u.reportApiInvoke(this._sessionId, {\n        name: C.STOP_LIVE_STREAMING,\n        options: [a],\n        tag: B.TRACER\n      }),\n          e = I(b = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient]).call(b, b => b && b.hasUrl(a));\n      return e.length ? A.all(E(e).call(e, b => b && b.stopLiveStreamingTask(a))).then(() => c.onSuccess()).catch(a => {\n        throw c.onError(a), a;\n      }) : (b = new n(l.INVALID_PARAMS, \"can not find live streaming url to stop\"), c.onError(b), A.reject(b));\n    }\n\n    addInjectStreamUrl(a, b) {\n      var _this107 = this;\n\n      return _asyncToGenerator(function* () {\n        let c = u.reportApiInvoke(_this107._sessionId, {\n          name: C.ADD_INJECT_STREAM_URL,\n          options: [a, b],\n          tag: B.TRACER\n        });\n\n        try {\n          if (!_this107._joinInfo) throw new n(l.INVALID_OPERATION, \"can not addInjectStreamUrl, no joininfo\");\n\n          let c = _this107._createLiveStreamingClient(oa.INJECT);\n\n          c.setInjectStreamConfig(b, 0);\n          yield c.startLiveStreamingTask(a, oa.INJECT);\n        } catch (e) {\n          throw c.onError(e), e;\n        }\n\n        c.onSuccess();\n      })();\n    }\n\n    removeInjectStreamUrl() {\n      var _this108 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = u.reportApiInvoke(_this108._sessionId, {\n          name: C.REMOVE_INJECT_STREAM_URL,\n          options: [],\n          tag: B.TRACER\n        });\n\n        try {\n          var b, c;\n\n          let a = _this108._createLiveStreamingClient(oa.INJECT),\n              g = R(b = Gb(ic(c = a.streamingTasks).call(c))).call(b, a => a.mode === oa.INJECT);\n\n          if (!_this108._joinInfo || !g) throw new n(l.INVALID_OPERATION, \"can remove addInjectStreamUrl, no joininfo or inject task\");\n          yield a.stopLiveStreamingTask(g.url);\n        } catch (e) {\n          throw a.onError(e), e;\n        }\n\n        a.onSuccess();\n      })();\n    }\n\n    startChannelMediaRelay(a) {\n      var _this109 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = u.reportApiInvoke(_this109._sessionId, {\n          name: C.START_CHANNEL_MEDIA_RELAY,\n          options: [a],\n          tag: B.TRACER\n        });\n\n        try {\n          Yh(a), yield _this109._createChannelMediaRelayClient().startChannelMediaRelay(a);\n        } catch (c) {\n          return b.onError(c), c.throw();\n        }\n\n        b.onSuccess();\n      })();\n    }\n\n    updateChannelMediaRelay(a) {\n      var _this110 = this;\n\n      return _asyncToGenerator(function* () {\n        let b = u.reportApiInvoke(_this110._sessionId, {\n          name: C.UPDATE_CHANNEL_MEDIA_RELAY,\n          options: [a],\n          tag: B.TRACER\n        });\n\n        try {\n          Yh(a), yield _this110._createChannelMediaRelayClient().updateChannelMediaRelay(a);\n        } catch (c) {\n          return b.onError(c), c.throw();\n        }\n\n        b.onSuccess();\n      })();\n    }\n\n    stopChannelMediaRelay() {\n      var _this111 = this;\n\n      return _asyncToGenerator(function* () {\n        let a = u.reportApiInvoke(_this111._sessionId, {\n          name: C.STOP_CHANNEL_MEDIA_RELAY,\n          options: [],\n          tag: B.TRACER\n        });\n\n        try {\n          yield _this111._createChannelMediaRelayClient().stopChannelMediaRelay();\n        } catch (b) {\n          return a.onError(b), b.throw();\n        }\n\n        a.onSuccess();\n      })();\n    }\n\n    sendStreamMessage(a) {\n      if (!this._joinInfo) throw new n(l.INVALID_OPERATION, \"can not send data stream, not joined\");\n      \"string\" == typeof a && (a = new TextEncoder().encode(a));\n      if (1024 < new Blob([a]).size) throw new n(l.INVALID_PARAMS, \"stream message out of range.\");\n      return this._gateway.signal.request(da.DATA_STREAM, {\n        payload: Dd(a)\n      });\n    }\n\n    sendMetadata(a) {\n      if (!this._joinInfo) throw new n(l.INVALID_OPERATION, \"can not send metadata, not joined\");\n      if (1024 < new Blob([a]).size) throw new n(l.METADATA_OUT_OF_RANGE);\n      return this._gateway.signal.request(da.SEND_METADATA, {\n        session_id: this._joinInfo.sid,\n        metadata: Dd(a)\n      });\n    }\n\n    sendCustomReportMessage(a) {\n      var _this112 = this;\n\n      return _asyncToGenerator(function* () {\n        Pb(a) || (a = [a]);\n        q(a).call(a, kl);\n        let b = u.reportApiInvoke(_this112._sessionId, {\n          name: C.SEND_CUSTOM_REPORT_MESSAGE,\n          options: [],\n          tag: B.TRACER\n        });\n        if (!_this112._joinInfo) return a = new n(l.INVALID_OPERATION, \"can not send custom report, not joined\"), b.onError(a), a.throw();\n        yield u.sendCustomReportMessage(_this112._joinInfo.sid, a);\n      })();\n    }\n\n    getLocalAudioStats() {\n      return this._highStream ? this._statsCollector.getLocalAudioTrackStats(this._highStream.connectionId) : ke;\n    }\n\n    getRemoteAudioStats() {\n      var a;\n      let b = {};\n      return q(a = this._remoteStream).call(a, (a, e) => {\n        b[e] = this._statsCollector.getRemoteAudioTrackStats(a.connectionId);\n      }), b;\n    }\n\n    getLocalVideoStats() {\n      return this._highStream ? this._statsCollector.getLocalVideoTrackStats(this._highStream.connectionId) : le;\n    }\n\n    getRemoteVideoStats() {\n      var a;\n      let b = {};\n      return q(a = this._remoteStream).call(a, (a, e) => {\n        b[e] = this._statsCollector.getRemoteVideoTrackStats(a.connectionId);\n      }), b;\n    }\n\n    getRemoteNetworkQuality() {\n      var a;\n      let b = {};\n      return q(a = this._remoteStream).call(a, (a, e) => {\n        b[e] = this._statsCollector.getRemoteNetworkQualityStats(a.connectionId);\n      }), b;\n    }\n\n    pickSVCLayer(a, b) {\n      var _this113 = this;\n\n      return _asyncToGenerator(function* () {\n        Ka(b.spatialLayer, \"spatialLayer\", [0, 1, 2, 3]);\n        Ka(b.temporalLayer, \"temporalLayer\", [0, 1, 2, 3]);\n\n        try {\n          yield _this113._gateway.pickSVCLayer(a, b);\n        } catch (c) {\n          throw k.error(\"[\".concat(_this113._clientId, \"] pick SVC layer failed\"), c.toString()), c;\n        }\n      })();\n    }\n\n    _reset() {\n      var a, b, c;\n      k.debug(\"[\".concat(this._clientId, \"] reset client\"));\n\n      this._axiosCancelSource.cancel();\n\n      this._axiosCancelSource = zb.CancelToken.source();\n      this._streamFallbackTypeCacheMap = new aa();\n      this._remoteStreamTypeCacheMap = new aa();\n\n      this._configDistribute.stopGetConfigDistribute();\n\n      this._defaultStreamFallbackType = this._proxyServer = this._joinInfo = void 0;\n      this._sessionId = null;\n\n      this._statsCollector.reset();\n\n      this._channelName = this._uid = this._appId = this._key = void 0;\n      q(a = this._users).call(a, a => {\n        a.audioTrack && (a.audioTrack.stop(), a.audioTrack._isDestroyed = !0);\n        a.videoTrack && (a.videoTrack.stop(), a.videoTrack._isDestroyed = !0);\n      });\n      this._users = [];\n      this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0);\n      this._highStream && (this._highStream.closeP2PConnection(!0), this._highStream = void 0);\n      q(b = this._bindEnabledTracks).call(b, a => {\n        a.off(M.NEED_ADD_TRACK, this._handleLocalTrackEnable);\n        a.off(M.NEED_REMOVE_TRACK, this._handleLocalTrackDisable);\n      });\n      this._bindEnabledTracks = [];\n      this._lowStream && (this._lowStream.closeP2PConnection(!0), this._lowStream = void 0);\n      q(c = this._remoteStream).call(c, a => {\n        a.closeP2PConnection(!0);\n      });\n      this._remoteStream = new aa();\n      this._publishMutex = new Mb(\"client-publish\");\n      this._subscribeMutex = new aa();\n      this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0);\n      this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0);\n      this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0);\n      this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0);\n      this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0);\n    }\n\n    _startSession(a, b) {\n      var c, e, g;\n      let h = a || qa(32, \"\").toUpperCase();\n      a ? k.debug(m(c = \"[\".concat(this._clientId, \"] new Session \")).call(c, h)) : k.debug(m(e = m(g = \"[\".concat(this._clientId, \"] renewSession \")).call(g, this._sessionId, \" => \")).call(e, h));\n      this._sessionId = h;\n      b ? u.sessionInit(this._sessionId, {\n        lts: new Date().getTime(),\n        cname: b.channel,\n        appid: b.appId,\n        mode: this._mode\n      }) : this._joinInfo ? u.sessionInit(this._sessionId, {\n        lts: new Date().getTime(),\n        cname: this._joinInfo.cname,\n        appid: this._joinInfo.appId,\n        mode: this._mode\n      }) : this._gateway.joinInfo && u.sessionInit(this._sessionId, {\n        lts: new Date().getTime(),\n        cname: this._gateway.joinInfo.cname,\n        appid: this._gateway.joinInfo.appId,\n        mode: this._mode\n      });\n      this._joinInfo && (this._joinInfo.sid = h);\n      this._gateway.joinInfo && (this._gateway.joinInfo.sid = h);\n    }\n\n    _publishHighStream(a) {\n      var _this114 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this114._joinInfo) throw new n(l.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n        if (\"CONNECTED\" !== _this114.connectionState && \"RECONNECTING\" !== _this114.connectionState) throw new n(l.INVALID_OPERATION, \"can not publish stream in \".concat(_this114.connectionState, \" state\"));\n        if (\"auto\" === _this114._turnServer.mode && v.FORCE_TURN && !v.TURN_ENABLE_TCP && !v.TURN_ENABLE_UDP) throw new n(l.UNEXPECTED_ERROR, \"force TURN With No TURN Configuration\");\n        if (k.debug(\"[\".concat(_this114._clientId, \"] publish high stream\")), _this114._highStream) return yield _this114._highStream.addTracks(a), _this114._highStream;\n        _this114._highStream = new Wk(_this114._statsCollector, _this114._joinInfo, _this114._codec);\n        yield _this114._highStream.addTracks(a);\n\n        try {\n          yield _this114._gateway.publish(_this114._highStream, \"high\");\n        } catch (b) {\n          throw _this114._highStream = void 0, b;\n        }\n\n        return _this114._highStream.on(H.CONNECTION_STATE_CHANGE, (a, c) => {\n          _this114._highStream && (\"connected\" === a ? _this114.emit(P.MEDIA_RECONNECT_END, _this114._highStream.getUserId()) : \"connecting\" === a && _this114.emit(P.MEDIA_RECONNECT_START, _this114._highStream.getUserId()));\n        }), _this114._highStream;\n      })();\n    }\n\n    _publishLowStream(a) {\n      var _this115 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this115._joinInfo) throw new n(l.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n        if (\"CONNECTED\" !== _this115.connectionState && \"RECONNECTING\" !== _this115.connectionState) throw new n(l.INVALID_OPERATION, \"can not publish stream in \".concat(_this115.connectionState, \" state\"));\n        if (!_this115._highStream || \"connected\" !== _this115._highStream.connectionState) throw new n(l.UNEXPECTED_ERROR, \"Could not find high stream\");\n        if (_this115._lowStream) return new n(l.UNEXPECTED_ERROR, \"[\".concat(_this115._clientId, \"] Can't publish low stream when stream already publish\")).throw();\n        k.debug(\"[\".concat(_this115._clientId, \"] publish low stream\"));\n        _this115._lowStream = new Wk(_this115._statsCollector, _this115._joinInfo, _this115._codec, !0);\n\n        let b = _this115._configDistribute.getLowStreamConfigDistribute();\n\n        b && b.bitrate && (_this115._lowStreamParameter || (_this115._lowStreamParameter = {\n          width: 160,\n          height: 120,\n          framerate: 15,\n          bitrate: 50\n        }), _this115._lowStreamParameter && _this115._lowStreamParameter.bitrate && b.bitrate < _this115._lowStreamParameter.bitrate && (_this115._lowStreamParameter.bitrate = b.bitrate));\n        _this115._lowStream.lowStreamParameter = _this115._lowStreamParameter;\n        yield _this115._lowStream.addTracks([a]);\n\n        try {\n          yield _this115._gateway.publish(_this115._lowStream, \"low\");\n        } catch (c) {\n          throw _this115._lowStream = void 0, c;\n        }\n\n        _this115._highStream.lowStreamConnection = _this115._lowStream;\n      })();\n    }\n\n    _createLiveStreamingClient(a) {\n      if (!this._joinInfo || !this._appId) return new n(l.INVALID_OPERATION, \"can not create live streaming client, please join channel first\").throw();\n\n      let b = () => new Lo(this._joinInfo, this._config.websocketRetryConfig || Qa, this._config.httpRetryConfig || Qa),\n          c = a => {\n        a.onLiveStreamError = (a, b) => {\n          u.reportApiInvoke(this._sessionId, {\n            name: C.ON_LIVE_STREAM_ERROR,\n            options: [a, b],\n            tag: B.TRACER\n          }).onSuccess();\n          this.emit(P.LIVE_STREAMING_ERROR, a, b);\n        };\n\n        a.onLiveStreamWarning = (a, b) => {\n          u.reportApiInvoke(this._sessionId, {\n            name: C.ON_LIVE_STREAM_WARNING,\n            options: [a, b],\n            tag: B.TRACER\n          }).onSuccess();\n          this.emit(P.LIVE_STREAMING_WARNING, a, b);\n        };\n\n        a.on(Ec.REQUEST_WORKER_MANAGER_LIST, (a, b, c) => {\n          if (!this._joinInfo) return c(new n(l.INVALID_OPERATION, \"can not find join info to get worker manager\"));\n          Ih(a, this._joinInfo, this._axiosCancelSource.token, Qa).then(b).catch(c);\n        });\n      };\n\n      switch (a) {\n        case oa.RAW:\n          return this._liveRawStreamingClient || (this._liveRawStreamingClient = b(), c(this._liveRawStreamingClient)), this._liveRawStreamingClient;\n\n        case oa.TRANSCODE:\n          return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = b(), c(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;\n\n        case oa.INJECT:\n          return this._injectStreamingClient || (this._injectStreamingClient = b(), this._injectStreamingClient.on(Ec.REQUEST_WORKER_MANAGER_LIST, (a, b, c) => {\n            if (!this._joinInfo) return c(new n(l.INVALID_OPERATION, \"can not find join info to get worker manager\"));\n            Ih(a, this._joinInfo, this._axiosCancelSource.token, Qa).then(b).catch(c);\n          }), this._injectStreamingClient.onInjectStatusChange = (a, b, c) => {\n            this.emit(P.INJECT_STREAM_STATUS, a, b, c);\n          }), this._injectStreamingClient;\n      }\n    }\n\n    _createChannelMediaRelayClient() {\n      return this._joinInfo ? (this._channelMediaRelayClient || (this._channelMediaRelayClient = new No(this._joinInfo, this._clientId, this._config.websocketRetryConfig || Qa, this._config.httpRetryConfig || Qa), this._channelMediaRelayClient.on(\"state\", a => {\n        \"RELAY_STATE_FAILURE\" === a && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose();\n        this.emit(P.CHANNEL_MEDIA_RELAY_STATE, a);\n      }), this._channelMediaRelayClient.on(\"event\", a => {\n        this.emit(P.CHANNEL_MEDIA_RELAY_EVENT, a);\n      })), this._channelMediaRelayClient) : new n(l.INVALID_OPERATION, \"can not create channel media relay client, please join channel first\").throw();\n    }\n\n    _handleGatewayEvents() {\n      this._gateway.on(xa.DISCONNECT_P2P, () => {\n        var a;\n        k.debug(\"[\".concat(this._clientId, \"] start full reconnect\"));\n        this._highStream && \"disconnected\" !== this._highStream.connectionState && (k.debug(\"[\".concat(this._clientId, \"] ready to reconnect high stream\")), this._highStream.readyToReconnectPC());\n        this._lowStream && \"disconnected\" !== this._lowStream.connectionState && (k.debug(\"[\".concat(this._clientId, \"] ready to reconnect low stream\")), this._lowStream.readyToReconnectPC());\n        q(a = this._remoteStream).call(a, (a, c) => {\n          var b;\n          k.debug(m(b = \"[\".concat(this._clientId, \"] ready to reconnect remote stream \")).call(b, c));\n          a.readyToReconnectPC();\n        });\n      });\n\n      this._gateway.on(xa.CONNECTION_STATE_CHANGE, (a, b, c) => {\n        var e, g;\n\n        let h = () => {\n          this.emit(P.CONNECTION_STATE_CHANGE, a, b, c);\n        };\n\n        if (k.info(m(e = m(g = \"[\".concat(this._clientId, \"] connection state change: \")).call(g, b, \" -> \")).call(e, a)), \"DISCONNECTED\" === a) return this._reset(), void h();\n        var l, n;\n        if (\"RECONNECTING\" === a) this._highStream && \"connecting\" === this._highStream.connectionState && (k.debug(\"[\".concat(this._clientId, \"] ready to reconnect high stream\")), this._highStream.readyToReconnectPC()), this._lowStream && \"connecting\" === this._lowStream.connectionState && (k.debug(\"[\".concat(this._clientId, \"] ready to reconnect low stream\")), this._lowStream.readyToReconnectPC()), q(l = this._remoteStream).call(l, (a, b) => {\n          var c;\n          \"connecting\" === a.connectionState && (k.debug(m(c = \"[\".concat(this._clientId, \"] ready to reconnect remote stream \")).call(c, b)), a.readyToReconnectPC());\n        }), q(n = this._users).call(n, a => {\n          a._trust_in_room_ = !1;\n          a._trust_audio_enabled_state_ = !1;\n          a._trust_video_enabled_state_ = !1;\n          a._trust_audio_mute_state_ = !1;\n          a._trust_video_mute_state_ = !1;\n          a._trust_stream_added_state_ = !1;\n        }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._streamRemovedTimeout = this._userOfflineTimeout = void 0;else if (\"CONNECTED\" === a) {\n          var t, u;\n          q(t = this._streamFallbackTypeCacheMap).call(t, (a, b) => {\n            this._gateway.setStreamFallbackOption(b, a).catch(a => k.warning(\"[\".concat(this._clientId, \"] auto set stream fallback option failed\"), a));\n          });\n          q(u = this._remoteStreamTypeCacheMap).call(u, (a, b) => {\n            this._gateway.setRemoteVideoStreamType(b, a).catch(a => k.warning(\"[\".concat(this._clientId, \"] auto set remote stream type failed\"), a));\n          });\n          this._highStream && \"connecting\" === this._highStream.connectionState ? this._highStream.reconnectPC().then(() => {\n            this._lowStream && \"connecting\" === this._lowStream.connectionState && this._lowStream.reconnectPC().catch(a => {\n              k.error(\"[\".concat(this._clientId, \"] republish low stream error\"), a.toString());\n              this.emit(P.ERROR, {\n                reason: a\n              });\n            });\n          }).catch(a => {\n            k.error(\"[\".concat(this._clientId, \"] republish high stream error\"), a.toString());\n            this.emit(P.ERROR, {\n              reason: a\n            });\n          }) : this._lowStream && \"connecting\" === this._lowStream.connectionState && this._lowStream.reconnectPC().catch(a => {\n            k.error(\"[\".concat(this._clientId, \"] republish low stream error\"), a.toString());\n            this.emit(P.ERROR, {\n              reason: a\n            });\n          });\n          this._userOfflineTimeout = window.setTimeout(() => {\n            var a;\n\n            if (\"CONNECTED\" === this.connectionState) {\n              this._userOfflineTimeout = void 0;\n              var b = I(a = this._users).call(a, a => !a._trust_in_room_);\n              q(b).call(b, a => {\n                var b;\n                k.debug(m(b = \"[\".concat(this._clientId, \"] user offline timeout, emit user offline \")).call(b, a.uid));\n\n                this._handleUserOffline({\n                  uid: a.uid\n                });\n              });\n            }\n          }, 3E3);\n          this._streamRemovedTimeout = window.setTimeout(() => {\n            var a;\n            \"CONNECTED\" === this.connectionState && (this._streamRemovedTimeout = void 0, q(a = this._users).call(a, a => {\n              var b, c, e, g, h;\n              a._trust_audio_mute_state_ || (k.debug(m(b = \"[\".concat(this._clientId, \"] auto dispatch audio unmute event \")).call(b, a.uid)), this._handleMuteStream(a.uid, \"audio\", !1));\n              a._trust_video_mute_state_ || (k.debug(m(c = \"[\".concat(this._clientId, \"] auto dispatch video unmute event \")).call(c, a.uid)), this._handleMuteStream(a.uid, \"video\", !1));\n              a._trust_audio_enabled_state_ || (k.debug(m(e = \"[\".concat(this._clientId, \"] auto dispatch enable local audio \")).call(e, a.uid)), this._handleSetStreamLocalEnable(\"audio\", a.uid, !0));\n              !a._trust_video_enabled_state_ && a._video_enabled_ && (k.debug(m(g = \"[\".concat(this._clientId, \"] auto dispatch enable local video \")).call(g, a.uid)), this._handleSetStreamLocalEnable(\"video\", a.uid, !0));\n              a._trust_stream_added_state_ || (k.debug(m(h = \"[\".concat(this._clientId, \"] auto dispatch stream remove \")).call(h, a.uid)), this._handleRemoveStream({\n                uid: a.uid,\n                uint_id: a._uintid\n              }));\n            }));\n          }, 1E3);\n        }\n        h();\n      });\n\n      this._gateway.on(xa.REQUEST_NEW_GATEWAY_LIST, (a, b) => {\n        if (!this._joinInfo) return b(new n(l.UNEXPECTED_ERROR, \"can not recover, no join info\"));\n        Gh(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || Qa).then(b => {\n          var c;\n          this._joinInfo && (this._joinInfo.apResponse = b.gatewayInfo.res);\n          a(E(c = b.gatewayInfo.gatewayAddrs).call(c, a => {\n            if (this._joinInfo && this._joinInfo.proxyServer) {\n              var b, c;\n              a = a.split(\":\");\n              return m(b = m(c = \"wss://\".concat(this._joinInfo.proxyServer, \"/ws/?h=\")).call(c, a[0], \"&p=\")).call(b, a[1]);\n            }\n\n            return \"wss://\".concat(a);\n          }));\n        }).catch(b);\n      });\n\n      this._gateway.on(xa.NETWORK_QUALITY, a => {\n        \"normal\" === this._networkQualitySensitivity && this.emit(P.NETWORK_QUALITY, a);\n      });\n\n      this._gateway.on(xa.STREAM_TYPE_CHANGE, (a, b) => {\n        this.emit(P.STREAM_TYPE_CHANGED, a, b);\n        u.reportApiInvoke(this._sessionId, {\n          name: C.STREAM_TYPE_CHANGE,\n          options: [a, b],\n          tag: B.TRACER\n        }).onSuccess(w({\n          uid: a,\n          streamType: b\n        }));\n      });\n\n      this._gateway.on(xa.IS_P2P_DISCONNECTED, a => {\n        var b, c, e;\n        let g = [];\n        return this._highStream && g.push(this._highStream), q(b = this._remoteStream).call(b, a => g.push(a)), 0 === g.length || 0 === I(g).call(g, a => \"connected\" === a.connectionState).length ? a(!0) : (k.debug(m(c = \"[\".concat(this._clientId, \"] \")).call(c, E(e = I(g).call(g, a => \"connected\" === a.connectionState)).call(e, a => a.connectionId), \" is connected\")), void a(!1));\n      });\n\n      this._gateway.on(xa.NEED_RENEW_SESSION, () => {\n        this._startSession();\n      });\n\n      this._gateway.signal.on(U.ON_USER_ONLINE, this._handleUserOnline);\n\n      this._gateway.signal.on(U.ON_USER_OFFLINE, this._handleUserOffline);\n\n      this._gateway.signal.on(U.ON_ADD_AUDIO_STREAM, a => this._handleAddAudioOrVideoStream(\"audio\", a.uid, a.uint_id));\n\n      this._gateway.signal.on(U.ON_ADD_VIDEO_STREAM, a => this._handleAddAudioOrVideoStream(\"video\", a.uid, a.uint_id));\n\n      this._gateway.signal.on(U.ON_REMOVE_STREAM, this._handleRemoveStream);\n\n      this._gateway.signal.on(U.ON_P2P_LOST, this._handleP2PLost);\n\n      this._gateway.signal.on(U.MUTE_AUDIO, a => this._handleMuteStream(a.uid, \"audio\", !0));\n\n      this._gateway.signal.on(U.UNMUTE_AUDIO, a => this._handleMuteStream(a.uid, \"audio\", !1));\n\n      this._gateway.signal.on(U.MUTE_VIDEO, a => this._handleMuteStream(a.uid, \"video\", !0));\n\n      this._gateway.signal.on(U.UNMUTE_VIDEO, a => this._handleMuteStream(a.uid, \"video\", !1));\n\n      this._gateway.signal.on(U.RECEIVE_METADATA, a => {\n        let b = Ge(a.metadata);\n        this.emit(P.RECEIVE_METADATA, a.uid, b);\n      });\n\n      this._gateway.signal.on(U.ON_DATA_STREAM, a => {\n        a.seq && delete a.seq;\n        a.payload = Ge(a.payload);\n        this.emit(P.STREAM_MESSAGE, a.uid, a.payload);\n        this.onStreamMessage && this.onStreamMessage(a);\n      });\n\n      this._gateway.signal.on(U.ON_CRYPT_ERROR, () => {\n        Oc(() => {\n          k.warning(\"[\".concat(this._clientId, \"] on crypt error\"));\n          this.emit(P.CRYPT_ERROR);\n        }, this._sessionId);\n      });\n\n      this._gateway.signal.on(U.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire);\n\n      this._gateway.signal.on(U.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        k.warning(\"[\".concat(this._clientId, \"] received message onTokenPrivilegeDidExpire, please get new token and join again\"));\n\n        this._reset();\n\n        this._gateway.leave(!0);\n\n        this.emit(P.ON_TOKEN_PRIVILEGE_DID_EXPIRE);\n      });\n\n      this._gateway.signal.on(U.ON_STREAM_FALLBACK_UPDATE, a => {\n        var b, c;\n        k.debug(m(b = m(c = \"[\".concat(this._clientId, \"] stream fallback peerId: \")).call(c, a.stream_id, \", attr: \")).call(b, a.stream_type));\n        this.emit(P.STREAM_FALLBACK, a.stream_id, 1 === a.stream_type ? \"fallback\" : \"recover\");\n      });\n\n      this._gateway.signal.on(U.ON_PUBLISH_STREAM, a => {\n        var b;\n        this.uid === this._uid && (this._highStream && this._highStream._waitingSuccessResponse && \"connected\" === this._highStream.connectionState ? (this._highStream.reportPublishEvent(!0, null, w({\n          proxy: a.proxy\n        })), k.info(m(b = \"[\".concat(this._clientId, \"] on publish stream, \")).call(b, w(a))), void 0 !== a.proxy && this.emit(P.IS_USING_CLOUD_PROXY, !!a.proxy)) : this._lowStream ? this._lowStream.reportPublishEvent(!0, null, w({\n          proxy: a.proxy\n        })) : k.warning(\"get on_publish_stream message but cannot handle\"));\n      });\n\n      this._gateway.signal.on(U.ENABLE_LOCAL_VIDEO, a => {\n        this._handleSetStreamLocalEnable(\"video\", a.uid, !0);\n      });\n\n      this._gateway.signal.on(U.DISABLE_LOCAL_VIDEO, a => {\n        this._handleSetStreamLocalEnable(\"video\", a.uid, !1);\n      });\n\n      this._gateway.signal.on(Q.REQUEST_TIMEOUT, (a, b) => {\n        if (this._joinInfo) switch (a) {\n          case da.PUBLISH:\n            var c;\n            if (!b) break;\n            a = \"high\" === b.stream_type ? this._highStream : this._lowStream;\n            if (!a) break;\n            \"offer\" === b.state && u.publish(this._joinInfo.sid, {\n              lts: a.startTime,\n              succ: !1,\n              ec: l.TIMEOUT,\n              audio: b.audio,\n              video: b.video,\n              p2pid: b.p2p_id,\n              publishRequestid: a.ID,\n              screenshare: !(!a.videoTrack || -1 === J(c = a.videoTrack._hints).call(c, rb.SCREEN_TRACK)),\n              audioName: a.audioTrack && a.audioTrack.getTrackLabel(),\n              videoName: a.videoTrack && a.videoTrack.getTrackLabel()\n            });\n            break;\n\n          case da.SUBSCRIBE:\n            (c = this._remoteStream.get(b.stream_id)) && b && u.subscribe(this._joinInfo.sid, {\n              lts: c.startTime,\n              succ: !1,\n              ec: l.TIMEOUT,\n              audio: !!b.audio,\n              video: !!b.video,\n              peerid: b.stream_id,\n              subscribeRequestid: c.ID,\n              p2pid: c.pc.ID\n            });\n        }\n      });\n    }\n\n  }\n\n  ig([Je(), Ob(\"design:type\", Function), Ob(\"design:paramtypes\", [Object]), Ob(\"design:returntype\", void 0)], re.prototype, \"setTurnServer\", null);\n  ig([Je({\n    report: u\n  }), Ob(\"design:type\", Function), Ob(\"design:paramtypes\", [String, String, Uint8Array]), Ob(\"design:returntype\", void 0)], re.prototype, \"setEncryptionConfig\", null);\n  ig([function (a = {\n    report: u\n  }) {\n    return function (b, c, e) {\n      let g = b[c];\n\n      if (\"function\" == typeof g) {\n        let h = \"AgoraRTCClient\" === b.constructor.name ? \"Client\" : b.constructor.name;\n\n        e.value = /*#__PURE__*/function () {\n          var _ref17 = _asyncToGenerator(function* (...b) {\n            var e;\n            let k = a.report.reportApiInvoke(this._sessionId || null, {\n              name: m(e = \"\".concat(h, \".\")).call(e, c),\n              options: b,\n              tag: B.TRACER\n            });\n\n            try {\n              let a = yield g.apply(this, b);\n              return k.onSuccess(), a;\n            } catch (y) {\n              throw k.onError(y), y;\n            }\n          });\n\n          return function () {\n            return _ref17.apply(this, arguments);\n          };\n        }();\n      }\n\n      return e;\n    };\n  }({\n    report: u\n  }), Ob(\"design:type\", Function), Ob(\"design:paramtypes\", [Object, Object]), Ob(\"design:returntype\", A)], re.prototype, \"pickSVCLayer\", null);\n\n  class Qo extends Ck {\n    constructor(a, b = {}) {\n      super();\n      this.currentLoopCount = this.pausePlayTime = this.startPlayOffset = this.startPlayTime = 0;\n      this._currentState = \"stopped\";\n      this.audioBuffer = a;\n      this.options = b;\n      this.startPlayOffset = this.options.startPlayTime || 0;\n    }\n\n    set currentState(a) {\n      a !== this._currentState && (this._currentState = a, this.emit(ib.AUDIO_SOURCE_STATE_CHANGE, this._currentState));\n    }\n\n    get currentState() {\n      return this._currentState;\n    }\n\n    createWebAudioDiagram() {\n      return this.context.createGain();\n    }\n\n    get duration() {\n      return this.audioBuffer.duration;\n    }\n\n    get currentTime() {\n      return \"stopped\" === this.currentState ? 0 : \"paused\" === this.currentState ? this.pausePlayTime : (this.context.currentTime - this.startPlayTime + this.startPlayOffset) % this.audioBuffer.duration;\n    }\n\n    updateOptions(a) {\n      \"stopped\" === this.currentState ? (this.options = a, this.startPlayOffset = this.options.startPlayTime || 0) : k.warning(\"can not set audio source options\");\n    }\n\n    startProcessAudioBuffer() {\n      this.sourceNode && this.stopProcessAudioBuffer();\n      this.sourceNode = this.createSourceNode();\n      this.startSourceNode();\n      this.currentState = \"playing\";\n    }\n\n    pauseProcessAudioBuffer() {\n      this.sourceNode && \"playing\" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = \"paused\");\n    }\n\n    seekAudioBuffer(a) {\n      this.sourceNode && (this.sourceNode.onended = null, \"playing\" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), \"playing\" === this.currentState ? (this.startPlayOffset = a, this.startSourceNode()) : \"paused\" === this.currentState && (this.pausePlayTime = a));\n    }\n\n    resumeProcessAudioBuffer() {\n      \"paused\" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = \"playing\");\n    }\n\n    stopProcessAudioBuffer() {\n      if (this.sourceNode) {\n        this.sourceNode.onended = null;\n\n        try {\n          this.sourceNode.stop();\n        } catch (a) {}\n\n        this.reset();\n      }\n    }\n\n    startSourceNode() {\n      var a;\n      this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = ra(a = this.handleSourceNodeEnded).call(a, this));\n    }\n\n    createSourceNode() {\n      let a = this.context.createBufferSource();\n      return a.buffer = this.audioBuffer, a.loop = !!this.options.loop, a.connect(this.outputNode), a;\n    }\n\n    handleSourceNodeEnded() {\n      if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();\n      this.reset();\n    }\n\n    reset() {\n      this.startPlayOffset = this.options.startPlayTime || 0;\n      this.currentState = \"stopped\";\n      this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0);\n      this.currentLoopCount = 0;\n    }\n\n  }\n\n  let ai = new aa();\n  var Ro = ia.setInterval;\n  let Yk = na().name;\n\n  class od {\n    constructor(a, b) {\n      this.id = 0;\n      od.count += 1;\n      this.id = od.count;\n      this.element = a;\n      this.context = b;\n    }\n\n    initPeers() {\n      this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()];\n\n      this.peerPair[1].ontrack = a => {\n        let b = document.createElement(\"audio\");\n        b.srcObject = new MediaStream([a.track]);\n        b.play();\n        this.audioPlayerElement = b;\n      };\n    }\n\n    switchSdp() {\n      var _this116 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this116.peerPair) {\n          var a = /*#__PURE__*/function () {\n            var _ref18 = _asyncToGenerator(function* (_a, b) {\n              b = \"offer\" === b ? yield _a.createOffer() : yield _a.createAnswer();\n              return yield _a.setLocalDescription(b), \"complete\" === _a.iceGatheringState ? _a.localDescription : new A(b => {\n                _a.onicegatheringstatechange = () => {\n                  \"complete\" === _a.iceGatheringState && b(_a.localDescription);\n                };\n              });\n            });\n\n            return function a(_x48, _x49) {\n              return _ref18.apply(this, arguments);\n            };\n          }(),\n              b = /*#__PURE__*/function () {\n            var _ref19 = _asyncToGenerator(function* (a, _b) {\n              return yield a.setRemoteDescription(_b);\n            });\n\n            return function b(_x50, _x51) {\n              return _ref19.apply(this, arguments);\n            };\n          }();\n\n          try {\n            let c = yield a(_this116.peerPair[0], \"offer\");\n            yield b(_this116.peerPair[1], c);\n            let e = yield a(_this116.peerPair[1], \"answer\");\n            yield b(_this116.peerPair[0], e);\n          } catch (c) {\n            throw new n(l.LOCAL_AEC_ERROR, c.toString()).print();\n          }\n        }\n      })();\n    }\n\n    getTracksFromMediaElement(a) {\n      var _this117 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this117.audioTrack) return _this117.audioTrack;\n        let b;\n\n        try {\n          a instanceof HTMLVideoElement && (a.captureStream ? a.captureStream() : a.mozCaptureStream()), b = _this117.context.createMediaStreamDestination(), _this117.context.createMediaElementSource(a).connect(b);\n        } catch (c) {\n          throw new n(l.LOCAL_AEC_ERROR, c.toString()).print();\n        }\n\n        if (!b) throw new n(l.LOCAL_AEC_ERROR, \"no dest node when local aec\").print();\n        a = b.stream.getAudioTracks()[0];\n        return _this117.audioTrack = a, a;\n      })();\n    }\n\n    getElement() {\n      return this.element;\n    }\n\n    startEchoCancellation() {\n      var _this118 = this;\n\n      return _asyncToGenerator(function* () {\n        _this118.context.resume();\n\n        _this118.peerPair && _this118.close();\n\n        _this118.initPeers();\n\n        let a = yield _this118.getTracksFromMediaElement(_this118.element);\n        _this118.peerPair && _this118.peerPair[0].addTrack(a);\n        yield _this118.switchSdp();\n      })();\n    }\n\n    close() {\n      var a;\n      k.debug(\"close echo cancellation unit, id is\", this.id);\n      this.audioPlayerElement && this.audioPlayerElement.pause();\n      this.peerPair && q(a = this.peerPair).call(a, a => {\n        a.close();\n      });\n      this.audioPlayerElement = this.peerPair = void 0;\n    }\n\n  }\n\n  od.count = 0;\n\n  var jg = function (a, b) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(a, b);\n  };\n\n  let So = window.AudioContext || window.webkitAudioContext;\n\n  class Zk {\n    constructor() {\n      this.units = [];\n      this._doesEnvironmentNeedAEC() && (this.context = new So());\n    }\n\n    processExternalMediaAEC(a) {\n      var b;\n      if (!this.context || !this._doesEnvironmentNeedAEC()) return k.debug(\"the system does not need to process local aec\"), -1;\n      let c = R(b = this.units).call(b, b => b && b.getElement() === a);\n      return c || (c = new od(a, this.context), this.units.push(c)), c.startEchoCancellation(), k.debug(\"start processing local audio echo cancellation, id is\", c.id), c.id;\n    }\n\n    _doesEnvironmentNeedAEC() {\n      return na().name !== ca.SAFARI;\n    }\n\n  }\n\n  (function (a, b, c, e) {\n    var g,\n        h = arguments.length,\n        k = 3 > h ? b : null === e ? e = Z(b, c) : e;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) k = Reflect.decorate(a, b, c, e);else for (var l = a.length - 1; 0 <= l; l--) (g = a[l]) && (k = (3 > h ? g(k) : 3 < h ? g(b, c, k) : g(b, c)) || k);\n    return 3 < h && k && Y(b, c, k), k;\n  })([Je({\n    report: u\n  }), jg(\"design:type\", Function), jg(\"design:paramtypes\", [HTMLAudioElement]), jg(\"design:returntype\", Number)], Zk.prototype, \"processExternalMediaAEC\", null);\n\n  let To = new Zk();\n  var $k, al, bl, cl;\n  Yb(\"PROCESS_ID\", m($k = m(al = m(bl = m(cl = \"process-\".concat(qa(8, \"\"), \"-\")).call(cl, qa(4, \"\"), \"-\")).call(bl, qa(4, \"\"), \"-\")).call(al, qa(4, \"\"), \"-\")).call($k, qa(12, \"\")));\n\n  (function () {\n    let a = na();\n    var b = navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia ? !0 : !1;\n    ha.getDisplayMedia = b;\n    ha.getStreamFromExtension = a.name === ca.CHROME && 34 < Number(a.version);\n\n    ha.supportUnifiedPlan = function () {\n      if (!(window.RTCRtpTransceiver && \"currentDirection\" in RTCRtpTransceiver.prototype)) return !1;\n      let a = new RTCPeerConnection(),\n          b = !1;\n\n      try {\n        a.addTransceiver(\"audio\"), b = !0;\n      } catch (g) {}\n\n      return a.close(), b;\n    }();\n\n    ha.supportMinBitrate = a.name === ca.CHROME || a.name === ca.EDGE;\n\n    ha.supportSetRtpSenderParameters = function () {\n      let a = na();\n      return window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters ? !!Bd() || a.name === ca.SAFARI || a.name === ca.FIREFOX && 64 <= Number(a.version) : !1;\n    }();\n\n    a.name !== ca.SAFARI && na().name !== ca.WECHAT || (ha.supportDualStream = !1);\n\n    ha.webAudioMediaStreamDest = function () {\n      let a = na();\n      return a.name === ca.SAFARI && 12 > Number(a.version) ? !1 : !0;\n    }();\n\n    ha.supportReplaceTrack = window.RTCRtpSender ? \"function\" == typeof RTCRtpSender.prototype.replaceTrack ? !0 : !1 : !1;\n    ha.supportWebGL = \"undefined\" != typeof WebGLRenderingContext;\n    ha.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack;\n    Bd() || (ha.webAudioWithAEC = !0);\n\n    ha.supportShareAudio = function () {\n      let a = na();\n      return (a.os === X.WIN_10 || a.os === X.WIN_81 || a.os === X.WIN_7 || a.os === X.LINUX || a.os === X.MAC_OS || a.os === X.MAC_OS_X) && a.name === ca.CHROME && 74 <= Number(a.version) ? !0 : !1;\n    }();\n\n    ha.supportDualStreamEncoding = function () {\n      let a = na();\n      return a.name === ca.CHROME && 87 === Number(a.version);\n    }();\n\n    k.info(\"browser compatibility\", w(ha), w(a));\n  })();\n\n  let tb = {\n    VERSION: Ta,\n    BUILD: \"v4.5.0-0-g87245ad6(5/25/2021, 3:25:26 PM)\",\n    setParameter: Yb,\n    getParameter: function (a) {\n      return v[a];\n    },\n    getSupportedCodec: function () {\n      var _ref20 = _asyncToGenerator(function* (a) {\n        let b = null;\n        a ? (b = new Lk({}), b.addStream(a)) : b = new Mk({});\n        a = Ph(yield b.createOfferSDP());\n        return b.close(), a;\n      });\n\n      return function getSupportedCodec(_x52) {\n        return _ref20.apply(this, arguments);\n      };\n    }(),\n    checkSystemRequirements: function () {\n      const a = u.reportApiInvoke(null, {\n        name: C.CHECK_SYSTEM_REQUIREMENTS,\n        options: [],\n        tag: B.TRACER\n      });\n      var b = !1;\n\n      try {\n        var c = navigator.mediaDevices && navigator.mediaDevices.getUserMedia,\n            e = window.WebSocket;\n        b = !!(window.RTCPeerConnection && c && e);\n      } catch (g) {\n        return k.error(\"check system requirement failed: \", g), !1;\n      }\n\n      c = !1;\n      e = na();\n      e.name === ca.CHROME && 58 <= Number(e.version) && e.os !== X.IOS && (c = !0);\n      e.name === ca.FIREFOX && 56 <= Number(e.version) && (c = !0);\n      e.name === ca.OPERA && 45 <= Number(e.version) && (c = !0);\n      e.name === ca.SAFARI && 11 <= Number(e.version) && (c = !0);\n      na().name !== ca.WECHAT && na().name !== ca.QQ || e.os === X.IOS || (c = !0);\n      k.debug(\"checkSystemRequirements, api:\", b, \"browser\", c);\n      b = b && c;\n      return a.onSuccess(b), b;\n    },\n    getDevices: function (a) {\n      return cb.enumerateDevices(!0, !0, a);\n    },\n    getMicrophones: function (a) {\n      return cb.getRecordingDevices(a);\n    },\n    getCameras: function (a) {\n      return cb.getCamerasDevices(a);\n    },\n    getElectronScreenSources: th,\n    getPlaybackDevices: function (a) {\n      return cb.getSpeakers(a);\n    },\n    createClient: function (a = {\n      codec: \"vp8\",\n      mode: \"rtc\"\n    }) {\n      const b = u.reportApiInvoke(null, {\n        name: C.CREATE_CLIENT,\n        options: [a],\n        tag: B.TRACER\n      });\n\n      try {\n        Ka(a.codec, \"config.codec\", [\"vp8\", \"vp9\", \"av1\", \"h264\"]), Ka(a.mode, \"config.mode\", [\"rtc\", \"live\"]), void 0 !== a.proxyServer && Fa(a.proxyServer, \"config.proxyServer\", 1, 1E4), void 0 !== a.turnServer && gh(a.turnServer), void 0 !== a.httpRetryConfig && eh(a.httpRetryConfig), void 0 !== a.websocketRetryConfig && eh(a.websocketRetryConfig), !0;\n      } catch (c) {\n        throw b.onError(c), c;\n      }\n\n      return b.onSuccess(), new re(qc({\n        forceWaitGatewayResponse: !0\n      }, a, {\n        role: \"rtc\" === a.mode ? \"host\" : a.role\n      }));\n    },\n    createCameraVideoTrack: function () {\n      var _ref21 = _asyncToGenerator(function* (a = {\n        encoderConfig: \"480p_1\"\n      }) {\n        const b = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CREATE_CAM_VIDEO_TRACK,\n          options: [$e({}, a)]\n        }),\n              c = Ve(a);\n        var e = qa(8, \"track-\");\n        let g = null;\n        k.info(\"start create camera video track with config\", w(a), \"trackId\", e);\n\n        try {\n          g = (yield xb({\n            video: c\n          }, e)).getVideoTracks()[0] || null;\n        } catch (h) {\n          throw b.onError(h), h;\n        }\n\n        if (!g) return e = new n(l.UNEXPECTED_ERROR, \"can not find track in media stream\"), b.onError(e), e.throw();\n        a.optimizationMode && af(e, g, a, a.encoderConfig && kc(a.encoderConfig));\n        a = new Tk(g, a, c, a.scalabiltyMode ? ud(a.scalabiltyMode) : {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }, a.optimizationMode, e);\n        return b.onSuccess(a.getTrackId()), k.info(\"create camera video success, trackId:\", e), a;\n      });\n\n      return function createCameraVideoTrack() {\n        return _ref21.apply(this, arguments);\n      };\n    }(),\n    createCustomVideoTrack: function (a) {\n      const b = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.CREATE_CUSTOM_VIDEO_TRACK,\n        options: [a]\n      }),\n            c = new Ma(a.mediaStreamTrack, {\n        bitrateMax: a.bitrateMax,\n        bitrateMin: a.bitrateMin\n      }, a.scalabiltyMode ? ud(a.scalabiltyMode) : {\n        numSpatialLayers: 1,\n        numTemporalLayers: 1\n      }, a.optimizationMode);\n      return b.onSuccess(c.getTrackId()), k.info(\"create custom video track success with config\", a, \"trackId\", c.getTrackId()), c;\n    },\n    createScreenVideoTrack: function () {\n      var _ref22 = _asyncToGenerator(function* (a = {}, b = \"disable\") {\n        const c = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CREATE_SCREEN_VIDEO_TRACK,\n          options: [$e({}, a), b]\n        });\n        a.encoderConfig ? \"string\" == typeof a.encoderConfig || a.encoderConfig.width && a.encoderConfig.height || (a.encoderConfig.width = {\n          max: 1920\n        }, a.encoderConfig.height = {\n          max: 1080\n        }) : a.encoderConfig = \"1080p_2\";\n        var e = {};\n        a.screenSourceType && (e.mediaSource = a.screenSourceType);\n        a.extensionId && Kc() && (e.extensionId = a.extensionId);\n        a.electronScreenSourceId && (e.sourceId = a.electronScreenSourceId);\n        var g = a.encoderConfig ? ye(a.encoderConfig) : null;\n        g = (e.mandatory = {\n          chromeMediaSource: \"desktop\",\n          maxWidth: g ? g.width : void 0,\n          maxHeight: g ? g.height : void 0\n        }, g && g.frameRate && (\"number\" == typeof g.frameRate ? (e.mandatory.maxFrameRate = g.frameRate, e.mandatory.minFrameRate = g.frameRate) : (e.mandatory.maxFrameRate = g.frameRate.max || g.frameRate.ideal || g.frameRate.exact || void 0, e.mandatory.minFrameRate = g.frameRate.min || g.frameRate.ideal || g.frameRate.exact || void 0), e.frameRate = g.frameRate), g && g.width && (e.width = g.width), g && g.height && (e.height = g.height), e);\n        const h = qa(8, \"track-\");\n        let m = null;\n        e = null;\n        const r = ha;\n        if (!r.supportShareAudio && \"enable\" === b) return a = new n(l.NOT_SUPPORTED, \"your browser or platform is not support share-screen with audio\"), c.onError(a), a.throw();\n        k.info(\"start create screen video track with config\", a, \"withAudio\", b, \"trackId\", h);\n\n        try {\n          const a = yield xb({\n            screen: g,\n            screenAudio: \"auto\" === b ? r.supportShareAudio : \"enable\" === b\n          }, h);\n          m = a.getVideoTracks()[0] || null;\n          e = a.getAudioTracks()[0] || null;\n        } catch (t) {\n          throw c.onError(t), t;\n        }\n\n        if (!m) return a = new n(l.UNEXPECTED_ERROR, \"can not find track in media stream\"), c.onError(a), a.throw();\n        if (!e && \"enable\" === b) return m && m.stop(), a = new n(l.SHARE_AUDIO_NOT_ALLOWED), c.onError(a), a.throw();\n        a.optimizationMode || (a.optimizationMode = \"detail\");\n        a.optimizationMode && (af(h, m, a, a.encoderConfig && ye(a.encoderConfig)), a.encoderConfig && \"string\" != typeof a.encoderConfig && (a.encoderConfig.bitrateMin = a.encoderConfig.bitrateMax));\n        a = new Ma(m, a.encoderConfig ? ye(a.encoderConfig) : {}, a.scalabiltyMode ? ud(a.scalabiltyMode) : {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }, a.optimizationMode, h);\n        if (a._hints.push(rb.SCREEN_TRACK), !e) return c.onSuccess(a.getTrackId()), k.info(\"create screen video track success\", \"video:\", a.getTrackId()), a;\n        b = new Ya(e);\n        return c.onSuccess([a.getTrackId(), b.getTrackId()]), k.info(\"create screen video track success\", \"video:\", a.getTrackId(), \"audio:\", b.getTrackId()), [a, b];\n      });\n\n      return function createScreenVideoTrack() {\n        return _ref22.apply(this, arguments);\n      };\n    }(),\n    createMicrophoneAndCameraTracks: function () {\n      var _ref23 = _asyncToGenerator(function* (a = {}, b = {\n        encoderConfig: \"480p_1\"\n      }) {\n        var c, e, g;\n        const h = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CREATE_MIC_AND_CAM_TRACKS,\n          options: [a, b]\n        }),\n              p = Ve(b),\n              r = Nh(a),\n              q = qa(8, \"track-\"),\n              v = qa(8, \"track-\");\n        let x = null,\n            A = null;\n        k.info(m(c = m(e = m(g = \"start create camera video track(\".concat(v, \") and microphone audio track(\")).call(g, q, \") with config, audio: \")).call(e, w(a), \", video: \")).call(c, w(b)));\n\n        try {\n          var E;\n          const a = yield xb({\n            audio: r,\n            video: p\n          }, m(E = \"\".concat(q, \"-\")).call(E, v));\n          x = a.getAudioTracks()[0];\n          A = a.getVideoTracks()[0];\n        } catch (ka) {\n          throw h.onError(ka), ka;\n        }\n\n        if (!x || !A) {\n          var z = new n(l.UNEXPECTED_ERROR, \"can not find tracks in media stream\");\n          return h.onError(z), z.throw();\n        }\n\n        b.optimizationMode && af(v, A, b, b.encoderConfig && kc(b.encoderConfig));\n        a = new dg(x, a, r, q);\n        b = new Tk(A, b, p, b.scalabiltyMode ? ud(b.scalabiltyMode) : {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }, b.optimizationMode, v);\n        return h.onSuccess([a.getTrackId(), b.getTrackId()]), k.info(m(z = \"create camera video track(\".concat(v, \") and microphone audio track(\")).call(z, q, \") success\")), [a, b];\n      });\n\n      return function createMicrophoneAndCameraTracks() {\n        return _ref23.apply(this, arguments);\n      };\n    }(),\n    createMicrophoneAudioTrack: function () {\n      var _ref24 = _asyncToGenerator(function* (a = {}) {\n        const b = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CREATE_MIC_AUDIO_TRACK,\n          options: [a]\n        }),\n              c = Nh(a);\n        var e = qa(8, \"track-\");\n        let g = null;\n        k.info(\"start create microphone audio track with config\", w(a), \"trackId\", e);\n\n        try {\n          g = (yield xb({\n            audio: c\n          }, e)).getAudioTracks()[0] || null;\n        } catch (h) {\n          throw b.onError(h), h;\n        }\n\n        if (!g) return e = new n(l.UNEXPECTED_ERROR, \"can not find track in media stream\"), b.onError(e), e.throw();\n        a = new dg(g, a, c, e);\n        return b.onSuccess(a.getTrackId()), k.info(\"create microphone audio track success, trackId:\", e), a;\n      });\n\n      return function createMicrophoneAudioTrack() {\n        return _ref24.apply(this, arguments);\n      };\n    }(),\n    createCustomAudioTrack: function (a) {\n      const b = u.reportApiInvoke(null, {\n        tag: B.TRACER,\n        name: C.CREATE_CUSTOM_AUDIO_TRACK,\n        options: [a]\n      }),\n            c = new Ya(a.mediaStreamTrack, a.encoderConfig ? vd(a.encoderConfig) : {});\n      return k.info(\"create custom audio track success with config\", a, \"trackId\", c.getTrackId()), b.onSuccess(c.getTrackId()), c;\n    },\n    createBufferSourceAudioTrack: function () {\n      var _ref25 = _asyncToGenerator(function* (a) {\n        const b = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CREATE_BUFFER_AUDIO_TRACK,\n          options: [a]\n        }),\n              c = qa(8, \"track-\");\n        k.info(\"start create buffer source audio track with config\", w(a), \"trackId\", c);\n        const e = a.source;\n        if (!(a.source instanceof AudioBuffer)) try {\n          a.source = yield Bl(a.source, a.cacheOnlineFile);\n        } catch (h) {\n          return b.onError(h), h.throw();\n        }\n        const g = new Qo(a.source);\n        a = new no(e, g, a.encoderConfig ? vd(a.encoderConfig) : {}, c);\n        return k.info(\"create buffer source audio track success, trackId:\", c), b.onSuccess(a.getTrackId()), a;\n      });\n\n      return function createBufferSourceAudioTrack(_x53) {\n        return _ref25.apply(this, arguments);\n      };\n    }(),\n    setLogLevel: function (a) {\n      k.setLogLevel(a);\n    },\n    enableLogUpload: function () {\n      k.enableLogUpload();\n    },\n    disableLogUpload: function () {\n      k.disableLogUpload();\n    },\n    createChannelMediaRelayConfiguration: function () {\n      return new Zh();\n    },\n    checkAudioTrackIsActive: function () {\n      var _ref26 = _asyncToGenerator(function* (a, b = 5E3) {\n        const c = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CHECK_AUDIO_TRACK_IS_ACTIVE,\n          options: [b]\n        });\n\n        if (!(a instanceof Ya || a instanceof nd)) {\n          var e = new n(l.INVALID_TRACK, \"the parameter is not a audio track\");\n          return c.onError(e), e.throw();\n        }\n\n        b && 1E3 > b && (b = 1E3);\n        const g = a instanceof Ya ? a.getTrackLabel() : \"remote_track\";\n        let h = e = a.getVolumeLevel(),\n            p = e;\n        const r = x();\n        return new A(e => {\n          const l = Ro(() => {\n            var n = a.getVolumeLevel();\n            h = n > h ? n : h;\n            p = n < p ? n : p;\n            n = 1E-4 < h - p;\n            var q = x() - r;\n\n            if (n || q > b) {\n              var t;\n              clearInterval(l);\n              q = {\n                duration: q,\n                deviceLabel: g,\n                maxVolumeLevel: h,\n                result: n\n              };\n              k.info(m(t = \"[track-\".concat(a.getTrackId(), \"] check audio track active completed. \")).call(t, w(q)));\n              c.onSuccess(q);\n              e(n);\n            }\n          }, 200);\n        });\n      });\n\n      return function checkAudioTrackIsActive(_x54) {\n        return _ref26.apply(this, arguments);\n      };\n    }(),\n    checkVideoTrackIsActive: function () {\n      var _ref27 = _asyncToGenerator(function* (a, b = 5E3) {\n        var c;\n        const e = u.reportApiInvoke(null, {\n          tag: B.TRACER,\n          name: C.CHECK_VIDEO_TRACK_IS_ACTIVE,\n          options: [b]\n        });\n        if (!(a instanceof Ma || a instanceof md)) return a = new n(l.INVALID_TRACK, \"the parameter is not a video track\"), e.onError(a), a.throw();\n        b && 1E3 > b && (b = 1E3);\n        var g = a instanceof Ma ? a.getTrackLabel() : \"remote_track\",\n            h = a.getMediaStreamTrack(!0);\n        const p = document.createElement(\"video\");\n        p.style.width = \"1px\";\n        p.style.height = \"1px\";\n        p.setAttribute(\"muted\", \"\");\n        p.muted = !0;\n        p.setAttribute(\"playsinline\", \"\");\n        p.controls = !1;\n        Yk === ca.SAFARI && (p.style.opacity = \"0.01\", p.style.position = \"fixed\", p.style.left = \"0\", p.style.top = \"0\", document.body.appendChild(p));\n        p.srcObject = new MediaStream([h]);\n        p.play();\n        const r = document.createElement(\"canvas\");\n        r.width = 160;\n        r.height = 120;\n        let q = h = 0;\n\n        try {\n          const a = x();\n          h = yield function (a, b, c, e) {\n            let g,\n                h = 0,\n                m = null;\n            return new A((p, r) => {\n              Ub(() => {\n                g && (g(), p(h));\n              }, b);\n              g = Le(() => {\n                a: {\n                  h > e && g && (g(), p(h));\n                  var b = c.getContext(\"2d\");\n\n                  if (b) {\n                    b.drawImage(a, 0, 0, 160, 120);\n                    b = b.getImageData(0, 0, c.width, c.height);\n                    var q = Math.floor(b.data.length / 3);\n                    if (m) for (let a = 0; a < q; a += 3) if (b.data[a] !== m[a]) {\n                      h += 1;\n                      m = b.data;\n                      break a;\n                    }\n                    m = b.data;\n                  } else b = new n(l.UNEXPECTED_ERROR, \"can not get canvas 2d context.\"), k.error(b.toString()), r(b);\n                }\n              }, 30);\n            });\n          }(p, b, r, 4);\n          q = x() - a;\n        } catch (y) {\n          throw e.onError(y), y;\n        }\n\n        Yk === ca.SAFARI && (p.pause(), p.remove());\n        p.srcObject = null;\n        b = 4 < h;\n        g = {\n          duration: q,\n          changedPicNum: h,\n          deviceLabel: g,\n          result: b\n        };\n        return k.info(m(c = \"[track-\".concat(a.getTrackId(), \"] check video track active completed. \")).call(c, w(g))), e.onSuccess(g), b;\n      });\n\n      return function checkVideoTrackIsActive(_x55) {\n        return _ref27.apply(this, arguments);\n      };\n    }(),\n    setArea: function (a) {\n      const b = u.reportApiInvoke(null, {\n        name: C.SET_AREA,\n        options: a,\n        tag: B.TRACER\n      });\n\n      try {\n        var c;\n        let b = [];\n\n        if (\"string\" == typeof a && (b = [a]), Pb(a) && (q(a).call(a, a => {\n          if (!ba(hk).call(hk, a)) throw new n(l.INVALID_PARAMS, \"invalid area code\");\n        }), b = a), \"[object Object]\" === Object.prototype.toString.call(a)) {\n          const {\n            areaCode: c,\n            excludedArea: e\n          } = a;\n          if (!c) throw new n(l.INVALID_PARAMS, \"area code is needed\");\n          a = c;\n          \"string\" == typeof c && (a = [c]);\n          b = e ? po(a, e) : a;\n        }\n\n        Yb(\"AREAS\", b);\n\n        const g = (a => {\n          const b = {\n            CODE: \"\",\n            WEBCS_DOMAIN: [],\n            WEBCS_DOMAIN_BACKUP_LIST: [],\n            PROXY_CS: [],\n            CDS_AP: [],\n            ACCOUNT_REGISTER: [],\n            UAP_AP: [],\n            EVENT_REPORT_DOMAIN: [],\n            EVENT_REPORT_BACKUP_DOMAIN: [],\n            LOG_UPLOAD_SERVER: [],\n            PROXY_SERVER_TYPE3: []\n          };\n          return E(a).call(a, a => {\n            const c = Tf[a];\n            (a = V(c)) && E(a).call(a, a => {\n              var e;\n              \"CODE\" !== a && (b[a] = m(e = b[a]).call(e, c[a]));\n            });\n          }), b;\n        })(b);\n\n        E(c = V(g)).call(c, a => {\n          \"LOG_UPLOAD_SERVER\" === a || \"EVENT_REPORT_DOMAIN\" === a || \"EVENT_REPORT_BACKUP_DOMAIN\" === a || \"PROXY_SERVER_TYPE3\" === a ? Yb(a, g[a][0]) : Yb(a, g[a]);\n        });\n        k.debug(\"set area success:\", b.join(\",\"));\n      } catch (e) {\n        throw b.onError(e), e;\n      }\n\n      b.onSuccess();\n    },\n    loadModule: function (a, b) {\n      a.moduleInit ? a.moduleInit({\n        logger: k,\n        report: u\n      }, b) : k.debug(\"Invalid Plugin\");\n    },\n    processExternalMediaAEC: function (a) {\n      To.processExternalMediaAEC(a);\n    }\n  };\n  return cb.on(Kb.CAMERA_DEVICE_CHANGED, a => {\n    k.info(\"camera device changed\", w(a));\n    tb.onCameraChanged && tb.onCameraChanged(a);\n  }), cb.on(Kb.RECORDING_DEVICE_CHANGED, a => {\n    k.info(\"microphone device changed\", w(a));\n    tb.onMicrophoneChanged && tb.onMicrophoneChanged(a);\n  }), cb.on(Kb.PLAYOUT_DEVICE_CHANGED, a => {\n    k.debug(\"playout device changed\", w(a));\n    tb.onPlaybackDeviceChanged && tb.onPlaybackDeviceChanged(a);\n  }), db.onAutoplayFailed = () => {\n    k.info(\"detect audio element autoplay failed\");\n    tb.onAudioAutoplayFailed && tb.onAudioAutoplayFailed();\n  }, Pc.on(\"autoplay-failed\", () => {\n    k.info(\"detect webaudio autoplay failed\");\n    tb.onAudioAutoplayFailed && tb.onAudioAutoplayFailed();\n  }), tb;\n}); //# sourceMappingURL=AgoraRTC_N-production.js.map","map":null,"metadata":{},"sourceType":"script"}